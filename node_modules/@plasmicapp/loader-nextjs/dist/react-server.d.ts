/// <reference types="node" />

import { fetchExtractedHeadMetadata as __EXPERMIENTAL__fetchExtractedHeadMetadata } from '@plasmicapp/nextjs-app-router/react-server';
import { fetchExtractedQueryData as __EXPERMIENTAL__fetchExtractedQueryData } from '@plasmicapp/nextjs-app-router/react-server';
import { withPlasmicMetadata as __EXPERMIENTAL__withPlasmicMetadata } from '@plasmicapp/nextjs-app-router/react-server';
import { CodeComponentMeta } from '@plasmicapp/loader-react';
import { ComponentLookupSpec } from '@plasmicapp/loader-react';
import { ComponentMeta } from '@plasmicapp/loader-react/react-server-conditional';
import { ComponentRenderData } from '@plasmicapp/loader-react/react-server-conditional';
import { CustomFunctionMeta } from '@plasmicapp/loader-react';
import { DataCtxReader } from '@plasmicapp/loader-react';
import { DataProvider } from '@plasmicapp/loader-react';
import { ExtractPlasmicQueryData } from '@plasmicapp/nextjs-app-router';
import { FetchComponentDataOpts as FetchComponentDataOpts_2 } from '@plasmicapp/loader-react';
import { GlobalActionsContext } from '@plasmicapp/loader-react';
import { GlobalActionsProvider } from '@plasmicapp/loader-react';
import { IncomingMessage } from 'http';
import { InitOptions } from '@plasmicapp/loader-react/react-server-conditional';
import { InternalPlasmicComponentLoader } from '@plasmicapp/loader-react/react-server';
import { InternalPlasmicComponentLoader as InternalPlasmicComponentLoader_2 } from '@plasmicapp/loader-react';
import { PageMeta } from '@plasmicapp/loader-react/react-server-conditional';
import { PageMetadata } from '@plasmicapp/loader-react/react-server-conditional';
import { PageParamsProvider } from '@plasmicapp/loader-react';
import { PlasmicCanvasContext } from '@plasmicapp/loader-react';
import { PlasmicCanvasHost } from '@plasmicapp/loader-react';
import { PlasmicComponent } from '@plasmicapp/loader-react';
import { PlasmicComponentLoader } from '@plasmicapp/loader-react/react-server';
import { PlasmicComponentLoader as PlasmicComponentLoader_2 } from '@plasmicapp/loader-react';
import { plasmicPrepass } from '@plasmicapp/loader-react';
import { PlasmicRootProvider as PlasmicRootProvider_2 } from '@plasmicapp/loader-react';
import { PlasmicTranslator } from '@plasmicapp/loader-react';
import { PlasmicTranslatorContext } from '@plasmicapp/loader-react';
import { PropType } from '@plasmicapp/loader-react';
import { default as React_2 } from 'react';
import * as React_3 from 'react';
import { repeatedElement } from '@plasmicapp/loader-react';
import { ServerResponse } from 'http';
import { TokenRegistration } from '@plasmicapp/loader-react';
import { useDataEnv } from '@plasmicapp/loader-react';
import { usePlasmicCanvasComponentInfo } from '@plasmicapp/loader-react';
import { usePlasmicCanvasContext } from '@plasmicapp/loader-react';
import { usePlasmicComponent } from '@plasmicapp/loader-react';
import { usePlasmicQueryData } from '@plasmicapp/loader-react';
import { useSelector } from '@plasmicapp/loader-react';
import { useSelectors } from '@plasmicapp/loader-react';

export declare const __EXPERMIENTAL__extractPlasmicQueryData: (element: React_2.ReactElement, loader: ClientExports.NextJsPlasmicComponentLoader) => Promise<Record<string, any>>;

export { __EXPERMIENTAL__fetchExtractedHeadMetadata }

export { __EXPERMIENTAL__fetchExtractedQueryData }

/**
 * Helper function to extract Plasmic data.
 *
 * Given the <PlasmicClientRootProvider> element and current pathname + search
 * params, returns:
 * - The extracted query data, if `plasmicSsr` search param is set
 * - A copy of the root provider element with the extracted query data, otherwise
 */
export declare function __EXPERMIENTAL__withExtractPlasmicQueryData(plasmicRootProvider: React_2.ReactElement, { pathname, searchParams, }: {
    pathname: string;
    searchParams: Record<string, string | string[]> | undefined;
}): Promise<React_2.JSX.Element>;

export { __EXPERMIENTAL__withPlasmicMetadata }

declare namespace ClientExports {
    export {
        initPlasmicLoader_2 as initPlasmicLoader,
        extractPlasmicQueryData,
        PlasmicRootProvider,
        DataCtxReader,
        DataProvider,
        GlobalActionsContext,
        GlobalActionsProvider,
        PageParamsProvider,
        PlasmicCanvasContext,
        PlasmicCanvasHost,
        PlasmicComponent,
        PlasmicTranslatorContext,
        plasmicPrepass,
        repeatedElement,
        useDataEnv,
        usePlasmicCanvasComponentInfo,
        usePlasmicCanvasContext,
        usePlasmicComponent,
        usePlasmicQueryData,
        useSelector,
        useSelectors,
        CodeComponentMeta,
        CustomFunctionMeta,
        PlasmicTranslator,
        PropType,
        TokenRegistration,
        ExtractPlasmicQueryData as __EXPERMIENTAL__ExtractPlasmicQueryData,
        FetchComponentDataOpts,
        NextJsPlasmicComponentLoader_2 as NextJsPlasmicComponentLoader,
        NextInitOptions,
        ComponentMeta,
        ComponentRenderData,
        InitOptions,
        PageMeta,
        PageMetadata
    }
}

export { ComponentMeta }

export { ComponentRenderData }

/**
 * Performs a prepass over Plasmic content, kicking off the necessary
 * data fetches, and populating the fetched data into a cache.  This
 * cache can be passed as prefetchedQueryData into PlasmicRootProvider.
 *
 * To limit rendering errors that can occur when you do this, we recommend
 * that you pass in _only_ the PlasmicComponents that you are planning to use
 * as the argument.  For example:
 *
 *   const cache = await extractPlasmicQueryData(
 *     <PlasmicRootProvider loader={PLASMIC} prefetchedData={plasmicData}>
 *       <PlasmicComponent component="Home" componentProps={{
 *         // Specify the component prop overrides you are planning to use
 *         // to render the page, as they may change what data is fetched.
 *         ...
 *       }} />
 *       <PlasmicComponent component="NavBar" componentProps={{
 *         ...
 *       }} />
 *       ...
 *     </PlasmicRootProvider>
 *   );
 *
 * If your PlasmicComponent will be wrapping components that require special
 * context set up, you should also wrap the element above with those context
 * providers.
 *
 * You should avoid passing in elements that are not related to Plasmic, as any
 * rendering errors from those elements during the prepass may result in data
 * not being populated in the cache.
 *
 * @param element a React element containing instances of PlasmicComponent.
 *   Will attempt to satisfy all data needs from usePlasmicDataQuery()
 *   in this element tree.
 * @returns an object mapping query key to fetched data
 */
declare function extractPlasmicQueryData(element: React_3.ReactElement): Promise<Record<string, any>>;

declare interface FetchComponentDataOpts extends FetchComponentDataOpts_2 {
    /**
     * Defer loading code chunks to script tags, reducing initial payload size.
     */
    deferChunks?: boolean;
}

export { InitOptions }

export declare function initPlasmicLoader(opts: NextInitOptions): NextJsPlasmicComponentLoader;

declare function initPlasmicLoader_2(opts: NextInitOptions): NextJsPlasmicComponentLoader_2;

export declare interface NextInitOptions extends InitOptions {
    /**
     * next/navigation doesn't exist prior to Next.js 13, so Plasmic can't assume the dependency exists.
     * If you use the App Router (which depends on next/navigation), you'll need to pass the module here.
     *
     * ```tsx
     * import { initPlasmicLoader } from "@plasmicapp/loader-nextjs/react-server-conditional";
     * import * as NextNavigation from "next/navigation";
     *
     * export const PLASMIC = initPlasmicLoader({
     *   nextNavigation: NextNavigation,
     *   projects: [
     *     // your projects
     *   ],
     * });
     * ```
     */
    nextNavigation?: {
        notFound: unknown;
        redirect: unknown;
        useParams: unknown;
        usePathname: unknown;
        useRouter: unknown;
        useSearchParams: unknown;
    };
}

export declare class NextJsPlasmicComponentLoader extends PlasmicComponentLoader {
    constructor(internal: InternalPlasmicComponentLoader);
    getActiveVariation(opts: {
        req?: ServerRequest;
        res?: ServerResponse;
        known?: Record<string, string>;
        traits: Record<string, string | number | boolean>;
    }): Promise<Record<string, string>>;
}

declare class NextJsPlasmicComponentLoader_2 extends PlasmicComponentLoader_2 {
    constructor(internal: InternalPlasmicComponentLoader_2);
    getActiveVariation(opts: {
        req?: ServerRequest_2;
        res?: ServerResponse;
        known?: Record<string, string>;
        traits: Record<string, string | number | boolean>;
    }): Promise<Record<string, string>>;
    maybeFetchComponentData(specs: ComponentLookupSpec[], opts?: FetchComponentDataOpts): Promise<ComponentRenderData | null>;
    maybeFetchComponentData(...specs: ComponentLookupSpec[]): Promise<ComponentRenderData | null>;
    fetchComponentData(...specs: ComponentLookupSpec[]): Promise<ComponentRenderData>;
    fetchComponentData(specs: ComponentLookupSpec[], opts?: FetchComponentDataOpts): Promise<ComponentRenderData>;
}

export { PageMeta }

export { PageMetadata }

declare function PlasmicRootProvider(props: Omit<React_3.ComponentProps<typeof PlasmicRootProvider_2>, "Head"> & {
    skipChunks?: boolean;
}): React_3.JSX.Element;

declare type ServerRequest = IncomingMessage & {
    cookies: {
        [key: string]: string;
    };
};

declare type ServerRequest_2 = IncomingMessage & {
    cookies: Partial<{
        [key: string]: string;
    }>;
};

export { }
