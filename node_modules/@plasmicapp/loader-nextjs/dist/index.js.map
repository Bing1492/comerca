{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/cache.ts", "../src/server-require.ts", "../src/mocks.tsx"],
  "sourcesContent": ["import type { CodeModule } from \"@plasmicapp/loader-core\";\nimport {\n  PlasmicRootProvider as CommonPlasmicRootProvider,\n  ComponentLookupSpec,\n  FetchComponentDataOpts as InternalFetchComponentDataOpts,\n  InternalPlasmicComponentLoader,\n  PlasmicComponentLoader,\n  extractPlasmicQueryData as internalExtractPlasmicQueryData,\n} from \"@plasmicapp/loader-react\";\nimport { IncomingMessage, ServerResponse } from \"http\";\nexport {\n  DataCtxReader,\n  DataProvider,\n  GlobalActionsContext,\n  GlobalActionsProvider,\n  PageParamsProvider,\n  PlasmicCanvasContext,\n  PlasmicCanvasHost,\n  PlasmicComponent,\n  PlasmicTranslatorContext,\n  plasmicPrepass,\n  repeatedElement,\n  useDataEnv,\n  usePlasmicCanvasComponentInfo,\n  usePlasmicCanvasContext,\n  usePlasmicComponent,\n  usePlasmicQueryData,\n  useSelector,\n  useSelectors,\n} from \"@plasmicapp/loader-react\";\nexport type {\n  CodeComponentMeta,\n  CustomFunctionMeta,\n  PlasmicTranslator,\n  PropType,\n  TokenRegistration,\n} from \"@plasmicapp/loader-react\";\nexport { ExtractPlasmicQueryData as __EXPERMIENTAL__ExtractPlasmicQueryData } from \"@plasmicapp/nextjs-app-router\";\nexport * from \"./shared-exports\";\n// NextHead and NextLink must be default imported (`import Pkg`) instead of a namespace import (`import * as Pkg`).\n// Otherwise, there's a Next.js 12 bug when referencing these dependencies due to default import interop.\n// The transpiled CommonJS code would create a `default` field on the package,\n// causing React to think it's an invalid React object:\n// ```\n// const NextHead = __defaultInterop(require('next/head.js'))\n// assert(typeof NextHead === 'object')\n// assert(typeof NextHead.default === 'function')\n// ```\nimport NextHead from \"next/head.js\";\nimport NextLink from \"next/link.js\";\nimport * as NextRouter from \"next/router.js\";\nimport Script from \"next/script\";\nimport * as React from \"react\";\nimport { initPlasmicLoaderWithCache } from \"./cache\";\nimport { wrapRouterContext } from \"./mocks\";\nimport type { ComponentRenderData, NextInitOptions } from \"./shared-exports\";\n\ntype ServerRequest = IncomingMessage & {\n  cookies: Partial<{\n    [key: string]: string;\n  }>;\n};\n\nconst reactMajorVersion = +React.version.split(\".\")[0];\n\nfunction filterCodeFromRenderData(data: ComponentRenderData) {\n  if (reactMajorVersion >= 18 && !!data.bundle.bundleKey) {\n    // Keep the entrypoints\n    const entrypoints = new Set([\n      ...data.entryCompMetas.map((compMeta) => compMeta.entry),\n      \"root-provider.js\",\n      ...data.bundle.projects\n        .map((x) => x.globalContextsProviderFileName)\n        .filter((x) => !!x),\n      ...data.bundle.components\n        .filter((c) => c.isGlobalContextProvider)\n        .map((c) => c.entry),\n      ...data.bundle.globalGroups.map((g) => g.contextFile),\n    ]);\n\n    data.bundle.modules.browser = data.bundle.modules.browser.map((module) => {\n      if (module.type !== \"code\" || entrypoints.has(module.fileName)) {\n        return module;\n      }\n      return { ...module, code: \"\" };\n    });\n  }\n}\n\nexport interface FetchComponentDataOpts extends InternalFetchComponentDataOpts {\n  /**\n   * Defer loading code chunks to script tags, reducing initial payload size.\n   */\n  deferChunks?: boolean;\n}\n\nexport class NextJsPlasmicComponentLoader extends PlasmicComponentLoader {\n  constructor(internal: InternalPlasmicComponentLoader) {\n    super(internal);\n  }\n\n  async getActiveVariation(opts: {\n    req?: ServerRequest;\n    res?: ServerResponse;\n    known?: Record<string, string>;\n    traits: Record<string, string | number | boolean>;\n  }) {\n    const extractBuiltinTraits = () => {\n      const url = new URL(\n        opts.req?.url ?? \"/\",\n        `https://${opts.req?.headers.host ?? \"server.side\"}`\n      );\n      return {\n        pageUrl: url.href,\n      };\n    };\n\n    return this._getActiveVariation({\n      enableUnseededExperiments: true,\n      traits: {\n        ...extractBuiltinTraits(),\n        ...opts.traits,\n      },\n      getKnownValue: (key: string) => {\n        if (opts.known) {\n          return opts.known[key];\n        } else {\n          return opts.req?.cookies[`plasmic:${key}`] ?? undefined;\n        }\n      },\n      updateKnownValue: (key: string, value: string) => {\n        if (opts.res) {\n          const cookie = `plasmic:${key}=${value}`;\n          const resCookie = opts.res?.getHeader(\"Set-Cookie\") ?? [];\n          let newCookies: string[] = [];\n          if (Array.isArray(resCookie)) {\n            newCookies = [...resCookie, `plasmic:${key}=${value}`];\n          } else {\n            newCookies = [`${resCookie}`, cookie];\n          }\n\n          opts.res?.setHeader(\"Set-Cookie\", newCookies);\n        }\n      },\n    });\n  }\n\n  maybeFetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData | null>;\n  maybeFetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...args: any[]\n  ): Promise<ComponentRenderData | null> {\n    const data = await super.maybeFetchComponentData(...args);\n    const { opts } = parseFetchComponentDataArgs(...args);\n    if (\n      data &&\n      (opts?.deferChunks ||\n        (opts?.deferChunks === undefined && data.bundle.deferChunksByDefault))\n    ) {\n      filterCodeFromRenderData(data);\n    }\n    return data;\n  }\n\n  fetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData>;\n  fetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData>;\n  async fetchComponentData(...args: any[]): Promise<ComponentRenderData> {\n    const data = await super.fetchComponentData(...args);\n    const { opts } = parseFetchComponentDataArgs(...args);\n    if (\n      opts?.deferChunks ||\n      (opts?.deferChunks === undefined && data.bundle.deferChunksByDefault)\n    ) {\n      filterCodeFromRenderData(data);\n    }\n    return data;\n  }\n}\n\nfunction parseFetchComponentDataArgs(\n  specs: ComponentLookupSpec[],\n  opts?: FetchComponentDataOpts\n): { specs: ComponentLookupSpec[]; opts?: FetchComponentDataOpts };\nfunction parseFetchComponentDataArgs(...specs: ComponentLookupSpec[]): {\n  specs: ComponentLookupSpec[];\n  opts?: FetchComponentDataOpts;\n};\nfunction parseFetchComponentDataArgs(...args: any[]) {\n  let specs: ComponentLookupSpec[];\n  let opts: FetchComponentDataOpts | undefined;\n  if (Array.isArray(args[0])) {\n    specs = args[0];\n    opts = args[1];\n  } else {\n    specs = args;\n    opts = undefined;\n  }\n  return { specs, opts };\n}\n\nexport function initPlasmicLoader(opts: NextInitOptions) {\n  const loader = initPlasmicLoaderWithCache<NextJsPlasmicComponentLoader>(\n    (opts) =>\n      new NextJsPlasmicComponentLoader(\n        new InternalPlasmicComponentLoader(opts)\n      ),\n    opts\n  );\n  loader.registerModules({\n    \"next/head\": NextHead,\n    \"next/link\": NextLink,\n    \"next/router\": NextRouter,\n  });\n  if (opts.nextNavigation) {\n    loader.registerModules({\n      \"next/navigation\": opts.nextNavigation,\n    });\n  }\n  return loader;\n}\n\n/**\n * Performs a prepass over Plasmic content, kicking off the necessary\n * data fetches, and populating the fetched data into a cache.  This\n * cache can be passed as prefetchedQueryData into PlasmicRootProvider.\n *\n * To limit rendering errors that can occur when you do this, we recommend\n * that you pass in _only_ the PlasmicComponents that you are planning to use\n * as the argument.  For example:\n *\n *   const cache = await extractPlasmicQueryData(\n *     <PlasmicRootProvider loader={PLASMIC} prefetchedData={plasmicData}>\n *       <PlasmicComponent component=\"Home\" componentProps={{\n *         // Specify the component prop overrides you are planning to use\n *         // to render the page, as they may change what data is fetched.\n *         ...\n *       }} />\n *       <PlasmicComponent component=\"NavBar\" componentProps={{\n *         ...\n *       }} />\n *       ...\n *     </PlasmicRootProvider>\n *   );\n *\n * If your PlasmicComponent will be wrapping components that require special\n * context set up, you should also wrap the element above with those context\n * providers.\n *\n * You should avoid passing in elements that are not related to Plasmic, as any\n * rendering errors from those elements during the prepass may result in data\n * not being populated in the cache.\n *\n * @param element a React element containing instances of PlasmicComponent.\n *   Will attempt to satisfy all data needs from usePlasmicDataQuery()\n *   in this element tree.\n * @returns an object mapping query key to fetched data\n */\nexport async function extractPlasmicQueryData(element: React.ReactElement) {\n  return internalExtractPlasmicQueryData(await wrapRouterContext(element));\n}\n\nconst PlasmicNextLink = React.forwardRef(function PlasmicNextLink(\n  props: React.ComponentProps<typeof NextLink>,\n  ref: React.Ref<HTMLAnchorElement>\n) {\n  // Basically renders NextLink, except when href is undefined,\n  // which freaks out NextLink :-/\n  if (props.href) {\n    const {\n      href,\n      replace,\n      scroll,\n      shallow,\n      passHref,\n      prefetch,\n      locale,\n      ...rest\n    } = props;\n    // If this is a fragment identifier link, then we set\n    // scroll={false} so that smooth scrolling works\n    const isFragment = typeof href === \"string\" && href.startsWith(\"#\");\n    // We use legacyBehavior, because we don't know which\n    // version of next the user has installed\n    return (\n      <NextLink\n        href={href}\n        replace={replace}\n        scroll={scroll != null ? scroll : isFragment ? false : undefined}\n        shallow={shallow}\n        passHref={passHref}\n        prefetch={prefetch}\n        locale={locale}\n        {...({ legacyBehavior: true } as any)}\n      >\n        <a {...rest} ref={ref} />\n      </NextLink>\n    );\n  } else {\n    return <a {...props} href={undefined} ref={ref} />;\n  }\n});\n\nexport function PlasmicRootProvider(\n  // We omit Head but still allow override for Link\n  props: Omit<\n    React.ComponentProps<typeof CommonPlasmicRootProvider>,\n    \"Head\"\n  > & { skipChunks?: boolean }\n) {\n  return (\n    <>\n      {!props.skipChunks &&\n        renderDynamicPayloadScripts(props.loader, props.prefetchedData)}\n      <CommonPlasmicRootProvider\n        Head={NextHead}\n        Link={PlasmicNextLink}\n        {...props}\n      />\n    </>\n  );\n}\n\nfunction renderDynamicPayloadScripts(\n  loader: PlasmicComponentLoader,\n  prefetchedData: ComponentRenderData | undefined\n) {\n  const missingModulesData =\n    prefetchedData &&\n    prefetchedData.bundle.modules.browser.filter(\n      (module): module is CodeModule => module.type === \"code\" && !module.code\n    );\n  if (!missingModulesData || missingModulesData.length === 0) {\n    return null;\n  }\n\n  const isBrowser = typeof window !== \"undefined\";\n\n  if (isBrowser) {\n    // `next/script` seems to not be correctly added to `<head>` in the initial\n    // HTML sometimes when using custom documents:\n    // https://linear.app/plasmic/issue/PLA-10652\n\n    // Make sure to create the promises in this case - the script to actually fetch\n    // the chunks will be added once hydration is completed.\n    if (!(globalThis as any).__PlasmicBundlePromises) {\n      (globalThis as any).__PlasmicBundlePromises = {};\n    }\n    for (const { fileName } of missingModulesData) {\n      if (!(globalThis as any).__PlasmicBundlePromises[fileName]) {\n        (globalThis as any).__PlasmicBundlePromises[fileName] = new Promise(\n          (resolve) => {\n            (globalThis as any).__PlasmicBundlePromises[\n              \"__promise_resolve_\" + fileName\n            ] = resolve;\n          }\n        );\n      }\n    }\n  }\n\n  return (\n    <>\n      <Script\n        strategy=\"beforeInteractive\"\n        key={\"init:\" + missingModulesData.map((m) => m.fileName).join(\";\")}\n        id={\"init:\" + missingModulesData.map((m) => m.fileName).join(\";\")}\n        dangerouslySetInnerHTML={{\n          __html: `\n            if (!globalThis.__PlasmicBundlePromises) {\n              globalThis.__PlasmicBundlePromises = {};\n            }\n            ${missingModulesData\n              .map(\n                (\n                  module\n                ) => `if (!globalThis.__PlasmicBundlePromises[${JSON.stringify(\n                  module.fileName\n                )}]) {\n                  globalThis.__PlasmicBundlePromises[${JSON.stringify(\n                    module.fileName\n                  )}] = new Promise((resolve) => {\n                    globalThis.__PlasmicBundlePromises[${JSON.stringify(\n                      \"__promise_resolve_\" + module.fileName\n                    )}] = resolve;\n                  })\n                }\n              `\n              )\n              .join(\"\\n\")}`.trim(),\n        }}\n      ></Script>\n      <Script\n        strategy=\"beforeInteractive\"\n        key={\"load:\" + missingModulesData.map((m) => m.fileName).join(\";\")}\n        id={\"load:\" + missingModulesData.map((m) => m.fileName).join(\";\")}\n        defer\n        async\n        src={loader.getChunksUrl(prefetchedData.bundle, missingModulesData)}\n      />\n    </>\n  );\n}\n", "import { LoaderBundleOutput } from \"@plasmicapp/loader-core\";\nimport type { InitOptions } from \"@plasmicapp/loader-react/react-server-conditional\";\nimport type * as Watcher from \"@plasmicapp/watcher\";\nimport { PHASE_PRODUCTION_BUILD } from \"next/constants\";\nimport path from \"path\";\nimport { serverRequire, serverRequireFs } from \"./server-require\";\nimport type { NextInitOptions } from \"./shared-exports\";\n\nclass FileCache {\n  constructor(private filePath: string) {}\n\n  async get() {\n    const fs = await serverRequireFs();\n    try {\n      await fs.promises.mkdir(path.dirname(this.filePath), { recursive: true });\n      const data = (await fs.promises.readFile(this.filePath)).toString();\n      return JSON.parse(data);\n    } catch {\n      return undefined;\n    }\n  }\n\n  async set(data: LoaderBundleOutput) {\n    const fs = await serverRequireFs();\n    try {\n      await fs.promises.writeFile(this.filePath, JSON.stringify(data));\n    } catch (err) {\n      console.warn(`Error writing to Plasmic cache: ${err}`);\n    }\n  }\n\n  async clear() {\n    const fs = await serverRequireFs();\n    try {\n      await fs.promises.unlink(this.filePath);\n    } catch (err) {\n      // noop\n    }\n  }\n}\n\nfunction hashString(str: string) {\n  let h = 0,\n    i = 0;\n  for (; i < str.length; h &= h) h = 31 * h + str.charCodeAt(i++);\n  return Math.abs(h);\n}\n\nfunction makeCache(opts: InitOptions) {\n  const cacheDir = path.resolve(process.cwd(), \".next\", \".plasmic\");\n  const cachePath = path.join(\n    cacheDir,\n    `plasmic-${hashString(\n      [...opts.projects.map((p) => `${p.id}@${p.version ?? \"\"}`)]\n        .sort()\n        .join(\"-\")\n    )}${opts.preview ? \"-preview\" : \"\"}-cache.json`\n  );\n  return new FileCache(cachePath);\n}\n\nexport function initPlasmicLoaderWithCache<\n  T extends {\n    clearCache(): void;\n  }\n>(\n  initFn: (opts: InitOptions) => T,\n  { nextNavigation, ...opts }: NextInitOptions\n): T {\n  const isBrowser = typeof window !== \"undefined\";\n  const isProd = process.env.NODE_ENV === \"production\";\n  const isBuildPhase = process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD;\n  const cache = isBrowser || isProd ? undefined : makeCache(opts);\n  const loader = initFn({\n    onClientSideFetch: \"warn\",\n    ...opts,\n    cache,\n    platform: \"nextjs\",\n    platformOptions: {\n      nextjs: {\n        appDir: !!nextNavigation,\n      },\n    },\n    // For Nextjs 12, revalidate may in fact re-use an existing instance\n    // of PlasmicComponentLoader that's already in memory, so we need to\n    // make sure we don't re-use the data cached in memory.\n    // We also enforce this for dev mode, so that we don't have to restart\n    // the dev server, in case getStaticProps() re-uses the same PlasmicComponentLoader\n    // We also enforce that during build phase, we re-use the data cached in memory\n    // to avoid re-fetching the data from Plasmic servers.\n    alwaysFresh: !isBuildPhase && !isBrowser,\n  });\n\n  if (!isProd) {\n    const stringOpts = JSON.stringify(opts);\n\n    if (process.env.PLASMIC_OPTS && process.env.PLASMIC_OPTS !== stringOpts) {\n      console.warn(\n        `PLASMIC: We detected that you created a new PlasmicLoader with different configurations. You may need to restart your dev server.\\n`\n      );\n    }\n\n    process.env.PLASMIC_OPTS = stringOpts;\n  }\n\n  if (cache) {\n    if (!isProd) {\n      if (process.env.PLASMIC_WATCHED !== \"true\") {\n        (async () => {\n          process.env.PLASMIC_WATCHED = \"true\";\n          console.log(`Subscribing to Plasmic changes...`);\n\n          // Import using serverRequire, so webpack doesn't bundle us into client bundle\n          try {\n            const PlasmicRemoteChangeWatcher = (\n              await serverRequire<typeof Watcher>(\"@plasmicapp/watcher\")\n            ).PlasmicRemoteChangeWatcher;\n            const watcher = new PlasmicRemoteChangeWatcher({\n              projects: opts.projects,\n              host: opts.host,\n            });\n\n            const clearCache = () => {\n              cache.clear();\n              loader.clearCache();\n            };\n\n            watcher.subscribe({\n              onUpdate: () => {\n                if (opts.preview) {\n                  clearCache();\n                }\n              },\n              onPublish: () => {\n                if (!opts.preview) {\n                  clearCache();\n                }\n              },\n            });\n          } catch (e) {\n            console.warn(\"Couldn't subscribe to Plasmic changes\", e);\n          }\n        })();\n      }\n    } else {\n      cache.clear();\n      loader.clearCache();\n    }\n  }\n  return loader;\n}\n", "import type * as FS from \"fs\";\n\nlet secretRequire: ((module: string) => any) | undefined;\ntry {\n  // Secretly use require/import without webpack knowing\n  // eslint-disable-next-line\n  secretRequire = eval(\"require\");\n} catch (err) {\n  try {\n    // eslint-disable-next-line\n    secretRequire = eval(\"(module) => import(module)\");\n  } catch (err) {\n    secretRequire = undefined;\n  }\n}\n\nexport async function serverRequire<T>(module: string): Promise<T> {\n  if (!secretRequire) {\n    throw new Error(\n      `Unexpected serverRequire() -- can only do this from a Node server!`\n    );\n  }\n  return secretRequire(module) as Promise<T>;\n}\n\nexport async function tryServerRequire<T>(\n  module: string\n): Promise<T | undefined> {\n  try {\n    const require = await serverRequire<T>(module);\n    return require;\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function tryServerRequires<T>(\n  modules: string[]\n): Promise<T | undefined> {\n  for (const module of modules) {\n    const require = await tryServerRequire<T>(module);\n    if (require != null) {\n      return require;\n    }\n  }\n  return undefined;\n}\n\nexport async function serverRequireFs() {\n  return serverRequire<typeof FS>(\"fs\");\n}\n", "import type * as RouterContextType from \"next/dist/shared/lib/router-context.shared-runtime\";\nimport type { NextRouter } from \"next/router\";\nimport * as React from \"react\";\nimport { tryServerRequires } from \"./server-require\";\n\nconst fakeRouter: NextRouter = {\n  push: async () => {\n    return true;\n  },\n  replace: async () => {\n    return true;\n  },\n  reload: () => {},\n  back: () => {},\n  forward: () => {},\n  prefetch: async () => {\n    return;\n  },\n  beforePopState: () => {},\n  events: {\n    on: () => {},\n    off: () => {},\n    emit: () => {},\n  },\n  route: \"/\",\n  asPath: \"/\",\n  basePath: \"/\",\n  pathname: \"/\",\n  query: {},\n  isFallback: false,\n  isLocaleDomain: false,\n  isReady: true,\n  isPreview: false,\n};\n\nexport async function wrapRouterContext(element: React.ReactElement) {\n  const RouterContext = (\n    await tryServerRequires<typeof RouterContextType>([\n      \"next/dist/shared/lib/router-context.shared-runtime\",\n      \"next/dist/shared/lib/router-context\",\n    ])\n  )?.RouterContext;\n  return !!RouterContext?.Provider ? (\n    <RouterContext.Provider value={fakeRouter}>\n      {element}\n    </RouterContext.Provider>\n  ) : (\n    element\n  );\n}\n"],
  "mappings": "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",
  "names": ["import_loader_react", "React", "err", "module", "require", "path", "err", "module", "opts", "NextHead", "NextLink", "internalExtractPlasmicQueryData", "PlasmicNextLink", "CommonPlasmicRootProvider", "Script"]
}
