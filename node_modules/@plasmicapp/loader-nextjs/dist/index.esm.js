"use client";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
import {
  PlasmicRootProvider as CommonPlasmicRootProvider,
  InternalPlasmicComponentLoader,
  PlasmicComponentLoader,
  extractPlasmicQueryData as internalExtractPlasmicQueryData
} from "@plasmicapp/loader-react";
import {
  DataCtxReader,
  DataProvider,
  GlobalActionsContext,
  GlobalActionsProvider,
  PageParamsProvider,
  PlasmicCanvasContext,
  PlasmicCanvasHost,
  PlasmicComponent,
  PlasmicTranslatorContext,
  plasmicPrepass,
  repeatedElement,
  useDataEnv,
  usePlasmicCanvasComponentInfo,
  usePlasmicCanvasContext,
  usePlasmicComponent,
  usePlasmicQueryData,
  useSelector,
  useSelectors
} from "@plasmicapp/loader-react";
import { ExtractPlasmicQueryData } from "@plasmicapp/nextjs-app-router";
import NextHead from "next/head.js";
import NextLink from "next/link.js";
import * as NextRouter from "next/router.js";
import Script from "next/script";
import * as React2 from "react";

// src/cache.ts
import { PHASE_PRODUCTION_BUILD } from "next/constants";
import path from "path";

// src/server-require.ts
var secretRequire;
try {
  secretRequire = eval("require");
} catch (err) {
  try {
    secretRequire = eval("(module) => import(module)");
  } catch (err2) {
    secretRequire = void 0;
  }
}
function serverRequire(module) {
  return __async(this, null, function* () {
    if (!secretRequire) {
      throw new Error(
        `Unexpected serverRequire() -- can only do this from a Node server!`
      );
    }
    return secretRequire(module);
  });
}
function tryServerRequire(module) {
  return __async(this, null, function* () {
    try {
      const require2 = yield serverRequire(module);
      return require2;
    } catch (e) {
      return void 0;
    }
  });
}
function tryServerRequires(modules) {
  return __async(this, null, function* () {
    for (const module of modules) {
      const require2 = yield tryServerRequire(module);
      if (require2 != null) {
        return require2;
      }
    }
    return void 0;
  });
}
function serverRequireFs() {
  return __async(this, null, function* () {
    return serverRequire("fs");
  });
}

// src/cache.ts
var FileCache = class {
  constructor(filePath) {
    this.filePath = filePath;
  }
  get() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.mkdir(path.dirname(this.filePath), { recursive: true });
        const data = (yield fs.promises.readFile(this.filePath)).toString();
        return JSON.parse(data);
      } catch (e) {
        return void 0;
      }
    });
  }
  set(data) {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.writeFile(this.filePath, JSON.stringify(data));
      } catch (err2) {
        console.warn(`Error writing to Plasmic cache: ${err2}`);
      }
    });
  }
  clear() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.unlink(this.filePath);
      } catch (err2) {
      }
    });
  }
};
function hashString(str) {
  let h = 0, i = 0;
  for (; i < str.length; h &= h)
    h = 31 * h + str.charCodeAt(i++);
  return Math.abs(h);
}
function makeCache(opts) {
  const cacheDir = path.resolve(process.cwd(), ".next", ".plasmic");
  const cachePath = path.join(
    cacheDir,
    `plasmic-${hashString(
      [...opts.projects.map((p) => {
        var _a;
        return `${p.id}@${(_a = p.version) != null ? _a : ""}`;
      })].sort().join("-")
    )}${opts.preview ? "-preview" : ""}-cache.json`
  );
  return new FileCache(cachePath);
}
function initPlasmicLoaderWithCache(initFn, _a) {
  var _b = _a, { nextNavigation } = _b, opts = __objRest(_b, ["nextNavigation"]);
  const isBrowser = typeof window !== "undefined";
  const isProd = process.env.NODE_ENV === "production";
  const isBuildPhase = process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD;
  const cache = isBrowser || isProd ? void 0 : makeCache(opts);
  const loader = initFn(__spreadProps(__spreadValues({
    onClientSideFetch: "warn"
  }, opts), {
    cache,
    platform: "nextjs",
    platformOptions: {
      nextjs: {
        appDir: !!nextNavigation
      }
    },
    // For Nextjs 12, revalidate may in fact re-use an existing instance
    // of PlasmicComponentLoader that's already in memory, so we need to
    // make sure we don't re-use the data cached in memory.
    // We also enforce this for dev mode, so that we don't have to restart
    // the dev server, in case getStaticProps() re-uses the same PlasmicComponentLoader
    // We also enforce that during build phase, we re-use the data cached in memory
    // to avoid re-fetching the data from Plasmic servers.
    alwaysFresh: !isBuildPhase && !isBrowser
  }));
  if (!isProd) {
    const stringOpts = JSON.stringify(opts);
    if (process.env.PLASMIC_OPTS && process.env.PLASMIC_OPTS !== stringOpts) {
      console.warn(
        `PLASMIC: We detected that you created a new PlasmicLoader with different configurations. You may need to restart your dev server.
`
      );
    }
    process.env.PLASMIC_OPTS = stringOpts;
  }
  if (cache) {
    if (!isProd) {
      if (process.env.PLASMIC_WATCHED !== "true") {
        (() => __async(this, null, function* () {
          process.env.PLASMIC_WATCHED = "true";
          console.log(`Subscribing to Plasmic changes...`);
          try {
            const PlasmicRemoteChangeWatcher = (yield serverRequire("@plasmicapp/watcher")).PlasmicRemoteChangeWatcher;
            const watcher = new PlasmicRemoteChangeWatcher({
              projects: opts.projects,
              host: opts.host
            });
            const clearCache = () => {
              cache.clear();
              loader.clearCache();
            };
            watcher.subscribe({
              onUpdate: () => {
                if (opts.preview) {
                  clearCache();
                }
              },
              onPublish: () => {
                if (!opts.preview) {
                  clearCache();
                }
              }
            });
          } catch (e) {
            console.warn("Couldn't subscribe to Plasmic changes", e);
          }
        }))();
      }
    } else {
      cache.clear();
      loader.clearCache();
    }
  }
  return loader;
}

// src/mocks.tsx
import * as React from "react";
var fakeRouter = {
  push: () => __async(void 0, null, function* () {
    return true;
  }),
  replace: () => __async(void 0, null, function* () {
    return true;
  }),
  reload: () => {
  },
  back: () => {
  },
  forward: () => {
  },
  prefetch: () => __async(void 0, null, function* () {
    return;
  }),
  beforePopState: () => {
  },
  events: {
    on: () => {
    },
    off: () => {
    },
    emit: () => {
    }
  },
  route: "/",
  asPath: "/",
  basePath: "/",
  pathname: "/",
  query: {},
  isFallback: false,
  isLocaleDomain: false,
  isReady: true,
  isPreview: false
};
function wrapRouterContext(element) {
  return __async(this, null, function* () {
    var _a;
    const RouterContext = (_a = yield tryServerRequires([
      "next/dist/shared/lib/router-context.shared-runtime",
      "next/dist/shared/lib/router-context"
    ])) == null ? void 0 : _a.RouterContext;
    return !!(RouterContext == null ? void 0 : RouterContext.Provider) ? /* @__PURE__ */ React.createElement(RouterContext.Provider, { value: fakeRouter }, element) : element;
  });
}

// src/index.tsx
var reactMajorVersion = +React2.version.split(".")[0];
function filterCodeFromRenderData(data) {
  if (reactMajorVersion >= 18 && !!data.bundle.bundleKey) {
    const entrypoints = /* @__PURE__ */ new Set([
      ...data.entryCompMetas.map((compMeta) => compMeta.entry),
      "root-provider.js",
      ...data.bundle.projects.map((x) => x.globalContextsProviderFileName).filter((x) => !!x),
      ...data.bundle.components.filter((c) => c.isGlobalContextProvider).map((c) => c.entry),
      ...data.bundle.globalGroups.map((g) => g.contextFile)
    ]);
    data.bundle.modules.browser = data.bundle.modules.browser.map((module) => {
      if (module.type !== "code" || entrypoints.has(module.fileName)) {
        return module;
      }
      return __spreadProps(__spreadValues({}, module), { code: "" });
    });
  }
}
var NextJsPlasmicComponentLoader = class extends PlasmicComponentLoader {
  constructor(internal) {
    super(internal);
  }
  getActiveVariation(opts) {
    return __async(this, null, function* () {
      const extractBuiltinTraits = () => {
        var _a, _b, _c, _d;
        const url = new URL(
          (_b = (_a = opts.req) == null ? void 0 : _a.url) != null ? _b : "/",
          `https://${(_d = (_c = opts.req) == null ? void 0 : _c.headers.host) != null ? _d : "server.side"}`
        );
        return {
          pageUrl: url.href
        };
      };
      return this._getActiveVariation({
        enableUnseededExperiments: true,
        traits: __spreadValues(__spreadValues({}, extractBuiltinTraits()), opts.traits),
        getKnownValue: (key) => {
          var _a, _b;
          if (opts.known) {
            return opts.known[key];
          } else {
            return (_b = (_a = opts.req) == null ? void 0 : _a.cookies[`plasmic:${key}`]) != null ? _b : void 0;
          }
        },
        updateKnownValue: (key, value) => {
          var _a, _b, _c;
          if (opts.res) {
            const cookie = `plasmic:${key}=${value}`;
            const resCookie = (_b = (_a = opts.res) == null ? void 0 : _a.getHeader("Set-Cookie")) != null ? _b : [];
            let newCookies = [];
            if (Array.isArray(resCookie)) {
              newCookies = [...resCookie, `plasmic:${key}=${value}`];
            } else {
              newCookies = [`${resCookie}`, cookie];
            }
            (_c = opts.res) == null ? void 0 : _c.setHeader("Set-Cookie", newCookies);
          }
        }
      });
    });
  }
  maybeFetchComponentData(...args) {
    return __async(this, null, function* () {
      const data = yield __superGet(NextJsPlasmicComponentLoader.prototype, this, "maybeFetchComponentData").call(this, ...args);
      const { opts } = parseFetchComponentDataArgs(...args);
      if (data && ((opts == null ? void 0 : opts.deferChunks) || (opts == null ? void 0 : opts.deferChunks) === void 0 && data.bundle.deferChunksByDefault)) {
        filterCodeFromRenderData(data);
      }
      return data;
    });
  }
  fetchComponentData(...args) {
    return __async(this, null, function* () {
      const data = yield __superGet(NextJsPlasmicComponentLoader.prototype, this, "fetchComponentData").call(this, ...args);
      const { opts } = parseFetchComponentDataArgs(...args);
      if ((opts == null ? void 0 : opts.deferChunks) || (opts == null ? void 0 : opts.deferChunks) === void 0 && data.bundle.deferChunksByDefault) {
        filterCodeFromRenderData(data);
      }
      return data;
    });
  }
};
function parseFetchComponentDataArgs(...args) {
  let specs;
  let opts;
  if (Array.isArray(args[0])) {
    specs = args[0];
    opts = args[1];
  } else {
    specs = args;
    opts = void 0;
  }
  return { specs, opts };
}
function initPlasmicLoader(opts) {
  const loader = initPlasmicLoaderWithCache(
    (opts2) => new NextJsPlasmicComponentLoader(
      new InternalPlasmicComponentLoader(opts2)
    ),
    opts
  );
  loader.registerModules({
    "next/head": NextHead,
    "next/link": NextLink,
    "next/router": NextRouter
  });
  if (opts.nextNavigation) {
    loader.registerModules({
      "next/navigation": opts.nextNavigation
    });
  }
  return loader;
}
function extractPlasmicQueryData(element) {
  return __async(this, null, function* () {
    return internalExtractPlasmicQueryData(yield wrapRouterContext(element));
  });
}
var PlasmicNextLink = React2.forwardRef(function PlasmicNextLink2(props, ref) {
  if (props.href) {
    const _a = props, {
      href,
      replace,
      scroll,
      shallow,
      passHref,
      prefetch,
      locale
    } = _a, rest = __objRest(_a, [
      "href",
      "replace",
      "scroll",
      "shallow",
      "passHref",
      "prefetch",
      "locale"
    ]);
    const isFragment = typeof href === "string" && href.startsWith("#");
    return /* @__PURE__ */ React2.createElement(
      NextLink,
      __spreadValues({
        href,
        replace,
        scroll: scroll != null ? scroll : isFragment ? false : void 0,
        shallow,
        passHref,
        prefetch,
        locale
      }, { legacyBehavior: true }),
      /* @__PURE__ */ React2.createElement("a", __spreadProps(__spreadValues({}, rest), { ref }))
    );
  } else {
    return /* @__PURE__ */ React2.createElement("a", __spreadProps(__spreadValues({}, props), { href: void 0, ref }));
  }
});
function PlasmicRootProvider(props) {
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, !props.skipChunks && renderDynamicPayloadScripts(props.loader, props.prefetchedData), /* @__PURE__ */ React2.createElement(
    CommonPlasmicRootProvider,
    __spreadValues({
      Head: NextHead,
      Link: PlasmicNextLink
    }, props)
  ));
}
function renderDynamicPayloadScripts(loader, prefetchedData) {
  const missingModulesData = prefetchedData && prefetchedData.bundle.modules.browser.filter(
    (module) => module.type === "code" && !module.code
  );
  if (!missingModulesData || missingModulesData.length === 0) {
    return null;
  }
  const isBrowser = typeof window !== "undefined";
  if (isBrowser) {
    if (!globalThis.__PlasmicBundlePromises) {
      globalThis.__PlasmicBundlePromises = {};
    }
    for (const { fileName } of missingModulesData) {
      if (!globalThis.__PlasmicBundlePromises[fileName]) {
        globalThis.__PlasmicBundlePromises[fileName] = new Promise(
          (resolve) => {
            globalThis.__PlasmicBundlePromises["__promise_resolve_" + fileName] = resolve;
          }
        );
      }
    }
  }
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(
    Script,
    {
      strategy: "beforeInteractive",
      key: "init:" + missingModulesData.map((m) => m.fileName).join(";"),
      id: "init:" + missingModulesData.map((m) => m.fileName).join(";"),
      dangerouslySetInnerHTML: {
        __html: `
            if (!globalThis.__PlasmicBundlePromises) {
              globalThis.__PlasmicBundlePromises = {};
            }
            ${missingModulesData.map(
          (module) => `if (!globalThis.__PlasmicBundlePromises[${JSON.stringify(
            module.fileName
          )}]) {
                  globalThis.__PlasmicBundlePromises[${JSON.stringify(
            module.fileName
          )}] = new Promise((resolve) => {
                    globalThis.__PlasmicBundlePromises[${JSON.stringify(
            "__promise_resolve_" + module.fileName
          )}] = resolve;
                  })
                }
              `
        ).join("\n")}`.trim()
      }
    }
  ), /* @__PURE__ */ React2.createElement(
    Script,
    {
      strategy: "beforeInteractive",
      key: "load:" + missingModulesData.map((m) => m.fileName).join(";"),
      id: "load:" + missingModulesData.map((m) => m.fileName).join(";"),
      defer: true,
      async: true,
      src: loader.getChunksUrl(prefetchedData.bundle, missingModulesData)
    }
  ));
}
export {
  DataCtxReader,
  DataProvider,
  GlobalActionsContext,
  GlobalActionsProvider,
  NextJsPlasmicComponentLoader,
  PageParamsProvider,
  PlasmicCanvasContext,
  PlasmicCanvasHost,
  PlasmicComponent,
  PlasmicRootProvider,
  PlasmicTranslatorContext,
  ExtractPlasmicQueryData as __EXPERMIENTAL__ExtractPlasmicQueryData,
  extractPlasmicQueryData,
  initPlasmicLoader,
  plasmicPrepass,
  repeatedElement,
  useDataEnv,
  usePlasmicCanvasComponentInfo,
  usePlasmicCanvasContext,
  usePlasmicComponent,
  usePlasmicQueryData,
  useSelector,
  useSelectors
};
//# sourceMappingURL=index.esm.js.map
