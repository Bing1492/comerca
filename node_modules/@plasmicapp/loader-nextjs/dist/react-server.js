"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/react-server.tsx
var react_server_exports = {};
__export(react_server_exports, {
  NextJsPlasmicComponentLoader: () => NextJsPlasmicComponentLoader,
  __EXPERMIENTAL__extractPlasmicQueryData: () => __EXPERMIENTAL__extractPlasmicQueryData,
  __EXPERMIENTAL__fetchExtractedHeadMetadata: () => import_react_server3.fetchExtractedHeadMetadata,
  __EXPERMIENTAL__fetchExtractedQueryData: () => import_react_server3.fetchExtractedQueryData,
  __EXPERMIENTAL__withExtractPlasmicQueryData: () => __EXPERMIENTAL__withExtractPlasmicQueryData,
  __EXPERMIENTAL__withPlasmicMetadata: () => import_react_server3.withPlasmicMetadata,
  initPlasmicLoader: () => initPlasmicLoader
});
module.exports = __toCommonJS(react_server_exports);
var import_server_only = require("server-only");
var import_react_server = require("@plasmicapp/loader-react/react-server");
var import_head = __toESM(require("next/head.js"));
var import_link = __toESM(require("next/link.js"));
var NextRouter = __toESM(require("next/router.js"));

// src/cache.ts
var import_constants = require("next/constants");
var import_path = __toESM(require("path"));

// src/server-require.ts
var secretRequire;
try {
  secretRequire = eval("require");
} catch (err) {
  try {
    secretRequire = eval("(module) => import(module)");
  } catch (err2) {
    secretRequire = void 0;
  }
}
function serverRequire(module2) {
  return __async(this, null, function* () {
    if (!secretRequire) {
      throw new Error(
        `Unexpected serverRequire() -- can only do this from a Node server!`
      );
    }
    return secretRequire(module2);
  });
}
function tryServerRequire(module2) {
  return __async(this, null, function* () {
    try {
      const require2 = yield serverRequire(module2);
      return require2;
    } catch (e) {
      return void 0;
    }
  });
}
function tryServerRequires(modules) {
  return __async(this, null, function* () {
    for (const module2 of modules) {
      const require2 = yield tryServerRequire(module2);
      if (require2 != null) {
        return require2;
      }
    }
    return void 0;
  });
}
function serverRequireFs() {
  return __async(this, null, function* () {
    return serverRequire("fs");
  });
}

// src/cache.ts
var FileCache = class {
  constructor(filePath) {
    this.filePath = filePath;
  }
  get() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.mkdir(import_path.default.dirname(this.filePath), { recursive: true });
        const data = (yield fs.promises.readFile(this.filePath)).toString();
        return JSON.parse(data);
      } catch (e) {
        return void 0;
      }
    });
  }
  set(data) {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.writeFile(this.filePath, JSON.stringify(data));
      } catch (err2) {
        console.warn(`Error writing to Plasmic cache: ${err2}`);
      }
    });
  }
  clear() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.unlink(this.filePath);
      } catch (err2) {
      }
    });
  }
};
function hashString(str) {
  let h = 0, i = 0;
  for (; i < str.length; h &= h)
    h = 31 * h + str.charCodeAt(i++);
  return Math.abs(h);
}
function makeCache(opts) {
  const cacheDir = import_path.default.resolve(process.cwd(), ".next", ".plasmic");
  const cachePath = import_path.default.join(
    cacheDir,
    `plasmic-${hashString(
      [...opts.projects.map((p) => {
        var _a;
        return `${p.id}@${(_a = p.version) != null ? _a : ""}`;
      })].sort().join("-")
    )}${opts.preview ? "-preview" : ""}-cache.json`
  );
  return new FileCache(cachePath);
}
function initPlasmicLoaderWithCache(initFn, _a) {
  var _b = _a, { nextNavigation } = _b, opts = __objRest(_b, ["nextNavigation"]);
  const isBrowser = typeof window !== "undefined";
  const isProd = process.env.NODE_ENV === "production";
  const isBuildPhase = process.env.NEXT_PHASE === import_constants.PHASE_PRODUCTION_BUILD;
  const cache = isBrowser || isProd ? void 0 : makeCache(opts);
  const loader = initFn(__spreadProps(__spreadValues({
    onClientSideFetch: "warn"
  }, opts), {
    cache,
    platform: "nextjs",
    platformOptions: {
      nextjs: {
        appDir: !!nextNavigation
      }
    },
    // For Nextjs 12, revalidate may in fact re-use an existing instance
    // of PlasmicComponentLoader that's already in memory, so we need to
    // make sure we don't re-use the data cached in memory.
    // We also enforce this for dev mode, so that we don't have to restart
    // the dev server, in case getStaticProps() re-uses the same PlasmicComponentLoader
    // We also enforce that during build phase, we re-use the data cached in memory
    // to avoid re-fetching the data from Plasmic servers.
    alwaysFresh: !isBuildPhase && !isBrowser
  }));
  if (!isProd) {
    const stringOpts = JSON.stringify(opts);
    if (process.env.PLASMIC_OPTS && process.env.PLASMIC_OPTS !== stringOpts) {
      console.warn(
        `PLASMIC: We detected that you created a new PlasmicLoader with different configurations. You may need to restart your dev server.
`
      );
    }
    process.env.PLASMIC_OPTS = stringOpts;
  }
  if (cache) {
    if (!isProd) {
      if (process.env.PLASMIC_WATCHED !== "true") {
        (() => __async(this, null, function* () {
          process.env.PLASMIC_WATCHED = "true";
          console.log(`Subscribing to Plasmic changes...`);
          try {
            const PlasmicRemoteChangeWatcher = (yield serverRequire("@plasmicapp/watcher")).PlasmicRemoteChangeWatcher;
            const watcher = new PlasmicRemoteChangeWatcher({
              projects: opts.projects,
              host: opts.host
            });
            const clearCache = () => {
              cache.clear();
              loader.clearCache();
            };
            watcher.subscribe({
              onUpdate: () => {
                if (opts.preview) {
                  clearCache();
                }
              },
              onPublish: () => {
                if (!opts.preview) {
                  clearCache();
                }
              }
            });
          } catch (e) {
            console.warn("Couldn't subscribe to Plasmic changes", e);
          }
        }))();
      }
    } else {
      cache.clear();
      loader.clearCache();
    }
  }
  return loader;
}

// src/react-server.tsx
var import_react_server2 = require("@plasmicapp/loader-react/react-server");
var import_nextjs_app_router = require("@plasmicapp/nextjs-app-router");
var import_react_server3 = require("@plasmicapp/nextjs-app-router/react-server");
var import_react = __toESM(require("react"));
var NextJsPlasmicComponentLoader = class extends import_react_server.PlasmicComponentLoader {
  constructor(internal) {
    super(internal);
  }
  getActiveVariation(opts) {
    return __async(this, null, function* () {
      const extractBuiltinTraits = () => {
        var _a, _b, _c, _d;
        const url = new URL(
          (_b = (_a = opts.req) == null ? void 0 : _a.url) != null ? _b : "/",
          `https://${(_d = (_c = opts.req) == null ? void 0 : _c.headers.host) != null ? _d : "server.side"}`
        );
        return {
          pageUrl: url.href
        };
      };
      return this._getActiveVariation({
        traits: __spreadValues(__spreadValues({}, extractBuiltinTraits()), opts.traits),
        getKnownValue: (key) => {
          var _a, _b;
          if (opts.known) {
            return opts.known[key];
          } else {
            return (_b = (_a = opts.req) == null ? void 0 : _a.cookies[`plasmic:${key}`]) != null ? _b : void 0;
          }
        },
        updateKnownValue: (key, value) => {
          var _a, _b, _c;
          if (opts.res) {
            const cookie = `plasmic:${key}=${value}`;
            const resCookie = (_b = (_a = opts.res) == null ? void 0 : _a.getHeader("Set-Cookie")) != null ? _b : [];
            let newCookies = [];
            if (Array.isArray(resCookie)) {
              newCookies = [...resCookie, `plasmic:${key}=${value}`];
            } else {
              newCookies = [`${resCookie}`, cookie];
            }
            (_c = opts.res) == null ? void 0 : _c.setHeader("Set-Cookie", newCookies);
          }
        }
      });
    });
  }
};
function initPlasmicLoader(opts) {
  const loader = initPlasmicLoaderWithCache(
    (opts2) => new import_react_server.PlasmicComponentLoader(new import_react_server.InternalPlasmicComponentLoader(opts2)),
    opts
  );
  loader.registerModules({
    "next/head": import_head.default,
    "next/link": import_link.default,
    "next/router": NextRouter
  });
  if (opts.nextNavigation) {
    loader.registerModules({
      "next/navigation": opts.nextNavigation
    });
  }
  return loader;
}
var __EXPERMIENTAL__extractPlasmicQueryData = import_react_server2.__EXPERMIENTAL__extractPlasmicQueryData;
function __EXPERMIENTAL__withExtractPlasmicQueryData(_0, _1) {
  return __async(this, arguments, function* (plasmicRootProvider, {
    pathname,
    searchParams
  }) {
    var _a, _b, _c;
    const isPlasmicSsr = !!(searchParams == null ? void 0 : searchParams["plasmicSsr"]) && (searchParams == null ? void 0 : searchParams["plasmicSsr"]) !== "false";
    if (isPlasmicSsr) {
      return /* @__PURE__ */ import_react.default.createElement(import_nextjs_app_router.ExtractPlasmicQueryData, null, plasmicRootProvider);
    }
    const prepassHost = (_c = (_a = process.env.PLASMIC_PREPASS_HOST) != null ? _a : process.env.VERCEL_URL && `https://${process.env.VERCEL_URL}`) != null ? _c : `http://localhost:${(_b = process.env.PORT) != null ? _b : 3e3}`;
    const newSearchParams = new URLSearchParams(
      Object.entries(searchParams != null ? searchParams : {}).flatMap(
        ([key, values]) => Array.isArray(values) ? values.map((v) => [key, v]) : [[key, values]]
      )
    );
    newSearchParams.set("plasmicSsr", "true");
    if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
      newSearchParams.set(
        "x-vercel-protection-bypass",
        process.env.VERCEL_AUTOMATION_BYPASS_SECRET
      );
    }
    const prefetchedQueryData = yield (0, import_react_server3.fetchExtractedQueryData)(
      `${prepassHost}${pathname}?${newSearchParams.toString()}`
    );
    return import_react.default.cloneElement(plasmicRootProvider, {
      prefetchedQueryData
    });
  });
}
//# sourceMappingURL=react-server.js.map
