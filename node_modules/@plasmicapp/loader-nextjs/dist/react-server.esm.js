var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/react-server.tsx
import "server-only";
import {
  InternalPlasmicComponentLoader,
  PlasmicComponentLoader
} from "@plasmicapp/loader-react/react-server";
import NextHead from "next/head.js";
import NextLink from "next/link.js";
import * as NextRouter from "next/router.js";

// src/cache.ts
import { PHASE_PRODUCTION_BUILD } from "next/constants";
import path from "path";

// src/server-require.ts
var secretRequire;
try {
  secretRequire = eval("require");
} catch (err) {
  try {
    secretRequire = eval("(module) => import(module)");
  } catch (err2) {
    secretRequire = void 0;
  }
}
function serverRequire(module) {
  return __async(this, null, function* () {
    if (!secretRequire) {
      throw new Error(
        `Unexpected serverRequire() -- can only do this from a Node server!`
      );
    }
    return secretRequire(module);
  });
}
function tryServerRequire(module) {
  return __async(this, null, function* () {
    try {
      const require2 = yield serverRequire(module);
      return require2;
    } catch (e) {
      return void 0;
    }
  });
}
function tryServerRequires(modules) {
  return __async(this, null, function* () {
    for (const module of modules) {
      const require2 = yield tryServerRequire(module);
      if (require2 != null) {
        return require2;
      }
    }
    return void 0;
  });
}
function serverRequireFs() {
  return __async(this, null, function* () {
    return serverRequire("fs");
  });
}

// src/cache.ts
var FileCache = class {
  constructor(filePath) {
    this.filePath = filePath;
  }
  get() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.mkdir(path.dirname(this.filePath), { recursive: true });
        const data = (yield fs.promises.readFile(this.filePath)).toString();
        return JSON.parse(data);
      } catch (e) {
        return void 0;
      }
    });
  }
  set(data) {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.writeFile(this.filePath, JSON.stringify(data));
      } catch (err2) {
        console.warn(`Error writing to Plasmic cache: ${err2}`);
      }
    });
  }
  clear() {
    return __async(this, null, function* () {
      const fs = yield serverRequireFs();
      try {
        yield fs.promises.unlink(this.filePath);
      } catch (err2) {
      }
    });
  }
};
function hashString(str) {
  let h = 0, i = 0;
  for (; i < str.length; h &= h)
    h = 31 * h + str.charCodeAt(i++);
  return Math.abs(h);
}
function makeCache(opts) {
  const cacheDir = path.resolve(process.cwd(), ".next", ".plasmic");
  const cachePath = path.join(
    cacheDir,
    `plasmic-${hashString(
      [...opts.projects.map((p) => {
        var _a;
        return `${p.id}@${(_a = p.version) != null ? _a : ""}`;
      })].sort().join("-")
    )}${opts.preview ? "-preview" : ""}-cache.json`
  );
  return new FileCache(cachePath);
}
function initPlasmicLoaderWithCache(initFn, _a) {
  var _b = _a, { nextNavigation } = _b, opts = __objRest(_b, ["nextNavigation"]);
  const isBrowser = typeof window !== "undefined";
  const isProd = process.env.NODE_ENV === "production";
  const isBuildPhase = process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD;
  const cache = isBrowser || isProd ? void 0 : makeCache(opts);
  const loader = initFn(__spreadProps(__spreadValues({
    onClientSideFetch: "warn"
  }, opts), {
    cache,
    platform: "nextjs",
    platformOptions: {
      nextjs: {
        appDir: !!nextNavigation
      }
    },
    // For Nextjs 12, revalidate may in fact re-use an existing instance
    // of PlasmicComponentLoader that's already in memory, so we need to
    // make sure we don't re-use the data cached in memory.
    // We also enforce this for dev mode, so that we don't have to restart
    // the dev server, in case getStaticProps() re-uses the same PlasmicComponentLoader
    // We also enforce that during build phase, we re-use the data cached in memory
    // to avoid re-fetching the data from Plasmic servers.
    alwaysFresh: !isBuildPhase && !isBrowser
  }));
  if (!isProd) {
    const stringOpts = JSON.stringify(opts);
    if (process.env.PLASMIC_OPTS && process.env.PLASMIC_OPTS !== stringOpts) {
      console.warn(
        `PLASMIC: We detected that you created a new PlasmicLoader with different configurations. You may need to restart your dev server.
`
      );
    }
    process.env.PLASMIC_OPTS = stringOpts;
  }
  if (cache) {
    if (!isProd) {
      if (process.env.PLASMIC_WATCHED !== "true") {
        (() => __async(this, null, function* () {
          process.env.PLASMIC_WATCHED = "true";
          console.log(`Subscribing to Plasmic changes...`);
          try {
            const PlasmicRemoteChangeWatcher = (yield serverRequire("@plasmicapp/watcher")).PlasmicRemoteChangeWatcher;
            const watcher = new PlasmicRemoteChangeWatcher({
              projects: opts.projects,
              host: opts.host
            });
            const clearCache = () => {
              cache.clear();
              loader.clearCache();
            };
            watcher.subscribe({
              onUpdate: () => {
                if (opts.preview) {
                  clearCache();
                }
              },
              onPublish: () => {
                if (!opts.preview) {
                  clearCache();
                }
              }
            });
          } catch (e) {
            console.warn("Couldn't subscribe to Plasmic changes", e);
          }
        }))();
      }
    } else {
      cache.clear();
      loader.clearCache();
    }
  }
  return loader;
}

// src/react-server.tsx
import { __EXPERMIENTAL__extractPlasmicQueryData as internalExtractPlasmicQueryData } from "@plasmicapp/loader-react/react-server";
import { ExtractPlasmicQueryData } from "@plasmicapp/nextjs-app-router";
import {
  fetchExtractedHeadMetadata,
  fetchExtractedQueryData,
  withPlasmicMetadata
} from "@plasmicapp/nextjs-app-router/react-server";
import React from "react";
var NextJsPlasmicComponentLoader = class extends PlasmicComponentLoader {
  constructor(internal) {
    super(internal);
  }
  getActiveVariation(opts) {
    return __async(this, null, function* () {
      const extractBuiltinTraits = () => {
        var _a, _b, _c, _d;
        const url = new URL(
          (_b = (_a = opts.req) == null ? void 0 : _a.url) != null ? _b : "/",
          `https://${(_d = (_c = opts.req) == null ? void 0 : _c.headers.host) != null ? _d : "server.side"}`
        );
        return {
          pageUrl: url.href
        };
      };
      return this._getActiveVariation({
        traits: __spreadValues(__spreadValues({}, extractBuiltinTraits()), opts.traits),
        getKnownValue: (key) => {
          var _a, _b;
          if (opts.known) {
            return opts.known[key];
          } else {
            return (_b = (_a = opts.req) == null ? void 0 : _a.cookies[`plasmic:${key}`]) != null ? _b : void 0;
          }
        },
        updateKnownValue: (key, value) => {
          var _a, _b, _c;
          if (opts.res) {
            const cookie = `plasmic:${key}=${value}`;
            const resCookie = (_b = (_a = opts.res) == null ? void 0 : _a.getHeader("Set-Cookie")) != null ? _b : [];
            let newCookies = [];
            if (Array.isArray(resCookie)) {
              newCookies = [...resCookie, `plasmic:${key}=${value}`];
            } else {
              newCookies = [`${resCookie}`, cookie];
            }
            (_c = opts.res) == null ? void 0 : _c.setHeader("Set-Cookie", newCookies);
          }
        }
      });
    });
  }
};
function initPlasmicLoader(opts) {
  const loader = initPlasmicLoaderWithCache(
    (opts2) => new PlasmicComponentLoader(new InternalPlasmicComponentLoader(opts2)),
    opts
  );
  loader.registerModules({
    "next/head": NextHead,
    "next/link": NextLink,
    "next/router": NextRouter
  });
  if (opts.nextNavigation) {
    loader.registerModules({
      "next/navigation": opts.nextNavigation
    });
  }
  return loader;
}
var __EXPERMIENTAL__extractPlasmicQueryData = internalExtractPlasmicQueryData;
function __EXPERMIENTAL__withExtractPlasmicQueryData(_0, _1) {
  return __async(this, arguments, function* (plasmicRootProvider, {
    pathname,
    searchParams
  }) {
    var _a, _b, _c;
    const isPlasmicSsr = !!(searchParams == null ? void 0 : searchParams["plasmicSsr"]) && (searchParams == null ? void 0 : searchParams["plasmicSsr"]) !== "false";
    if (isPlasmicSsr) {
      return /* @__PURE__ */ React.createElement(ExtractPlasmicQueryData, null, plasmicRootProvider);
    }
    const prepassHost = (_c = (_a = process.env.PLASMIC_PREPASS_HOST) != null ? _a : process.env.VERCEL_URL && `https://${process.env.VERCEL_URL}`) != null ? _c : `http://localhost:${(_b = process.env.PORT) != null ? _b : 3e3}`;
    const newSearchParams = new URLSearchParams(
      Object.entries(searchParams != null ? searchParams : {}).flatMap(
        ([key, values]) => Array.isArray(values) ? values.map((v) => [key, v]) : [[key, values]]
      )
    );
    newSearchParams.set("plasmicSsr", "true");
    if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
      newSearchParams.set(
        "x-vercel-protection-bypass",
        process.env.VERCEL_AUTOMATION_BYPASS_SECRET
      );
    }
    const prefetchedQueryData = yield fetchExtractedQueryData(
      `${prepassHost}${pathname}?${newSearchParams.toString()}`
    );
    return React.cloneElement(plasmicRootProvider, {
      prefetchedQueryData
    });
  });
}
export {
  NextJsPlasmicComponentLoader,
  __EXPERMIENTAL__extractPlasmicQueryData,
  fetchExtractedHeadMetadata as __EXPERMIENTAL__fetchExtractedHeadMetadata,
  fetchExtractedQueryData as __EXPERMIENTAL__fetchExtractedQueryData,
  __EXPERMIENTAL__withExtractPlasmicQueryData,
  withPlasmicMetadata as __EXPERMIENTAL__withPlasmicMetadata,
  initPlasmicLoader
};
//# sourceMappingURL=react-server.esm.js.map
