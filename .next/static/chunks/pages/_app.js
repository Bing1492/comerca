/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlasmicDataSourceContextProvider: () => (/* binding */ PlasmicDataSourceContextProvider),\n/* harmony export */   useCurrentUser: () => (/* binding */ useCurrentUser),\n/* harmony export */   usePlasmicDataSourceContext: () => (/* binding */ usePlasmicDataSourceContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\"use client\";\n\n// src/index.tsx\n\nvar PlasmicDataSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);\nfunction usePlasmicDataSourceContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PlasmicDataSourceContext);\n}\nfunction useCurrentUser() {\n  var _a;\n  const ctx = usePlasmicDataSourceContext();\n  return (_a = ctx == null ? void 0 : ctx.user) != null ? _a : {\n    isLoggedIn: false\n  };\n}\nvar PlasmicDataSourceContextProvider = PlasmicDataSourceContext.Provider;\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUVBO0FBQzBCO0FBQzFCLCtCQUErQiwwREFBbUI7QUFDbEQ7QUFDQSxTQUFTLHVEQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXEBwbGFzbWljYXBwXFxkYXRhLXNvdXJjZXMtY29udGV4dFxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG4vLyBzcmMvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gdXNlUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChQbGFzbWljRGF0YVNvdXJjZUNvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlQ3VycmVudFVzZXIoKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgY3R4ID0gdXNlUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0KCk7XG4gIHJldHVybiAoX2EgPSBjdHggPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC51c2VyKSAhPSBudWxsID8gX2EgOiB7XG4gICAgaXNMb2dnZWRJbjogZmFsc2VcbiAgfTtcbn1cbnZhciBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHRQcm92aWRlciA9IFBsYXNtaWNEYXRhU291cmNlQ29udGV4dC5Qcm92aWRlcjtcbmV4cG9ydCB7XG4gIFBsYXNtaWNEYXRhU291cmNlQ29udGV4dFByb3ZpZGVyLFxuICB1c2VDdXJyZW50VXNlcixcbiAgdXNlUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@plasmicapp/host/dist/host.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataContext: () => (/* binding */ DataContext),\n/* harmony export */   DataCtxReader: () => (/* binding */ DataCtxReader),\n/* harmony export */   DataProvider: () => (/* binding */ DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* binding */ GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* binding */ GlobalActionsProvider),\n/* harmony export */   PageParamsProvider: () => (/* binding */ PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* binding */ PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* binding */ PlasmicCanvasHost),\n/* harmony export */   PlasmicLinkProvider: () => (/* binding */ PlasmicLinkProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* binding */ PlasmicTranslatorContext),\n/* harmony export */   applySelector: () => (/* binding */ applySelector),\n/* harmony export */   mkMetaName: () => (/* binding */ mkMetaName),\n/* harmony export */   mkMetaValue: () => (/* binding */ mkMetaValue),\n/* harmony export */   registerComponent: () => (/* binding */ registerComponent),\n/* harmony export */   registerFunction: () => (/* binding */ registerFunction),\n/* harmony export */   registerGlobalContext: () => (/* binding */ registerGlobalContext),\n/* harmony export */   registerToken: () => (/* binding */ registerToken),\n/* harmony export */   registerTrait: () => (/* binding */ registerTrait),\n/* harmony export */   repeatedElement: () => (/* binding */ repeatedElement),\n/* harmony export */   stateHelpersKeys: () => (/* binding */ stateHelpersKeys),\n/* harmony export */   unstable_registerFetcher: () => (/* binding */ registerFetcher),\n/* harmony export */   useDataEnv: () => (/* binding */ useDataEnv),\n/* harmony export */   useGlobalActions: () => (/* binding */ useGlobalActions),\n/* harmony export */   usePlasmicCanvasComponentInfo: () => (/* binding */ usePlasmicCanvasComponentInfo),\n/* harmony export */   usePlasmicCanvasContext: () => (/* binding */ usePlasmicCanvasContext),\n/* harmony export */   usePlasmicLink: () => (/* binding */ usePlasmicLink),\n/* harmony export */   usePlasmicLinkMaybe: () => (/* binding */ usePlasmicLinkMaybe),\n/* harmony export */   usePlasmicTranslator: () => (/* binding */ usePlasmicTranslator),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useSelectors: () => (/* binding */ useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(pages-dir-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(pages-dir-browser)/./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n'use client';\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction ensure(x, msg) {\n    if (msg === void 0) { msg = \"\"; }\n    if (x === null || x === undefined) {\n        debugger;\n        msg = (isString(msg) ? msg : msg()) || \"\";\n        throw new Error(\"Value must not be undefined or null\".concat(msg ? \"- \".concat(msg) : \"\"));\n    }\n    else {\n        return x;\n    }\n}\n\nfunction useForceUpdate() {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), setTick = _a[1];\n    var update = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {\n        setTick(function (tick) { return tick + 1; });\n    }, []);\n    return update;\n}\n\nif (globalThis.__PlasmicHostVersion == null) {\n    globalThis.__PlasmicHostVersion = \"3\";\n}\nvar rootChangeListeners = [];\nvar PlasmicRootNodeWrapper = /** @class */ (function () {\n    function PlasmicRootNodeWrapper(value) {\n        var _this = this;\n        this.value = value;\n        this.set = function (val) {\n            _this.value = val;\n            rootChangeListeners.forEach(function (f) { return f(); });\n        };\n        this.get = function () { return _this.value; };\n    }\n    return PlasmicRootNodeWrapper;\n}());\nvar plasmicRootNode = new PlasmicRootNodeWrapper(null);\nfunction getHashParams() {\n    return new URLSearchParams(location.hash.replace(/^#/, \"?\"));\n}\nfunction getPlasmicOrigin() {\n    var params = getHashParams();\n    return ensure(params.get(\"origin\"), \"Missing information from Plasmic window.\");\n}\nfunction getStudioHash() {\n    var hashParams = getHashParams();\n    if (hashParams.has(\"studioHash\")) {\n        return hashParams.get(\"studioHash\");\n    }\n    var urlParams = new URL(location.href).searchParams;\n    return urlParams.get(\"studio-hash\");\n}\nfunction renderStudioIntoIframe() {\n    var script = document.createElement(\"script\");\n    var plasmicOrigin = getPlasmicOrigin();\n    var hash = getStudioHash();\n    script.src = \"\".concat(plasmicOrigin, \"/static/js/studio\").concat(hash ? \".\".concat(hash, \".js\") : \".js\");\n    document.body.appendChild(script);\n}\nvar renderCount = 0;\nfunction setPlasmicRootNode(node) {\n    // Keep track of renderCount, which we use as key to ErrorBoundary, so\n    // we can reset the error on each render\n    renderCount++;\n    plasmicRootNode.set(node);\n}\n/**\n * React context to detect whether the component is rendered on Plasmic editor.\n * If not, return false.\n * If so, return an object with more information about the component\n */\nvar PlasmicCanvasContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext(false);\nvar usePlasmicCanvasContext = function () {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(PlasmicCanvasContext);\n};\nfunction _PlasmicCanvasHost() {\n    var _a, _b;\n    // If window.parent is null, then this is a window whose containing iframe\n    // has been detached from the DOM (for the top window, window.parent === window).\n    // In that case, we shouldn't do anything.  If window.parent is null, by the way,\n    // location.hash will also be null.\n    var isFrameAttached = !!window.parent;\n    var isCanvas = !!((_a = location.hash) === null || _a === void 0 ? void 0 : _a.match(/\\bcanvas=true\\b/));\n    var isLive = !!((_b = location.hash) === null || _b === void 0 ? void 0 : _b.match(/\\blive=true\\b/)) || !isFrameAttached;\n    var shouldRenderStudio = isFrameAttached &&\n        !document.querySelector(\"#plasmic-studio-tag\") &&\n        !isCanvas &&\n        !isLive;\n    var forceUpdate = useForceUpdate();\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(function () {\n        rootChangeListeners.push(forceUpdate);\n        return function () {\n            var index = rootChangeListeners.indexOf(forceUpdate);\n            if (index >= 0) {\n                rootChangeListeners.splice(index, 1);\n            }\n        };\n    }, [forceUpdate]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        if (shouldRenderStudio && isFrameAttached && window.parent !== window) {\n            renderStudioIntoIframe();\n        }\n    }, [shouldRenderStudio, isFrameAttached]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        if (!shouldRenderStudio && !document.querySelector(\"#getlibs\") && isLive) {\n            var scriptElt = document.createElement(\"script\");\n            scriptElt.id = \"getlibs\";\n            scriptElt.src = getPlasmicOrigin() + \"/static/js/getlibs.js\";\n            scriptElt.async = false;\n            scriptElt.onload = function () {\n                var _a, _b;\n                (_b = (_a = window).__GetlibsReadyResolver) === null || _b === void 0 ? void 0 : _b.call(_a);\n            };\n            document.head.append(scriptElt);\n        }\n    }, [shouldRenderStudio]);\n    var _c = react__WEBPACK_IMPORTED_MODULE_1__.useState(function () {\n        return deriveCanvasContextValue();\n    }), canvasContextValue = _c[0], setCanvasContextValue = _c[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        if (isCanvas) {\n            var listener_1 = function () {\n                setCanvasContextValue(deriveCanvasContextValue());\n            };\n            window.addEventListener(\"hashchange\", listener_1);\n            return function () { return window.removeEventListener(\"hashchange\", listener_1); };\n        }\n        return undefined;\n    }, [isCanvas]);\n    if (!isFrameAttached) {\n        return null;\n    }\n    if (isCanvas || isLive) {\n        var appDiv = document.querySelector(\"#plasmic-app.__wab_user-body\");\n        if (!appDiv) {\n            appDiv = document.createElement(\"div\");\n            appDiv.id = \"plasmic-app\";\n            appDiv.classList.add(\"__wab_user-body\");\n            document.body.prepend(appDiv);\n        }\n        return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(react__WEBPACK_IMPORTED_MODULE_1__.createElement(ErrorBoundary, { key: \"\".concat(renderCount) },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(PlasmicCanvasContext.Provider, { value: canvasContextValue }, plasmicRootNode.get())), appDiv, \"plasmic-app\");\n    }\n    if (shouldRenderStudio && window.parent === window) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"iframe\", { src: \"https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=\".concat(encodeURIComponent(location.href)), style: {\n                width: \"100vw\",\n                height: \"100vh\",\n                border: \"none\",\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 99999999,\n            } }));\n    }\n    return null;\n}\nvar PlasmicCanvasHost = function (props) {\n    var enableWebpackHmr = props.enableWebpackHmr;\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useState(null), node = _a[0], setNode = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        setNode(react__WEBPACK_IMPORTED_MODULE_1__.createElement(_PlasmicCanvasHost, null));\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n        !enableWebpackHmr && react__WEBPACK_IMPORTED_MODULE_1__.createElement(DisableWebpackHmr, null),\n        node));\n};\nvar renderErrorListeners = [];\nfunction registerRenderErrorListener(listener) {\n    renderErrorListeners.push(listener);\n    return function () {\n        var index = renderErrorListeners.indexOf(listener);\n        if (index >= 0) {\n            renderErrorListeners.splice(index, 1);\n        }\n    };\n}\nvar ErrorBoundary = /** @class */ (function (_super) {\n    __extends(ErrorBoundary, _super);\n    function ErrorBoundary(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {};\n        return _this;\n    }\n    ErrorBoundary.getDerivedStateFromError = function (error) {\n        return { error: error };\n    };\n    ErrorBoundary.prototype.componentDidCatch = function (error) {\n        renderErrorListeners.forEach(function (listener) { return listener(error); });\n    };\n    ErrorBoundary.prototype.render = function () {\n        if (this.state.error) {\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null,\n                \"Error: \", \"\".concat(this.state.error.message));\n        }\n        else {\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.props.children);\n        }\n    };\n    return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\nfunction DisableWebpackHmr() {\n    if (false) {}\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"script\", { type: \"text/javascript\", dangerouslySetInnerHTML: {\n            __html: \"\\n      if (typeof window !== \\\"undefined\\\") {\\n        const RealEventSource = window.EventSource;\\n        window.EventSource = function(url, config) {\\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\\n            console.warn(\\\"Plasmic: disabled EventSource request for\\\", url);\\n            return {\\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\\n            };\\n          } else {\\n            return new RealEventSource(url, config);\\n          }\\n        }\\n      }\\n      \",\n        } }));\n}\nfunction deriveCanvasContextValue() {\n    var _a;\n    var hash = window.location.hash;\n    if (hash && hash.length > 0) {\n        // create URLsearchParams skipping the initial # character\n        var params = new URLSearchParams(hash.substring(1));\n        if (params.get(\"canvas\") === \"true\") {\n            var globalVariants = params.get(\"globalVariants\");\n            return {\n                componentName: (_a = params.get(\"componentName\")) !== null && _a !== void 0 ? _a : null,\n                globalVariants: globalVariants ? JSON.parse(globalVariants) : {},\n                interactive: params.get(\"interactive\") === \"true\",\n            };\n        }\n    }\n    return false;\n}\nvar INTERNAL_CC_CANVAS_SELECTION_PROP = \"__plasmic_selection_prop__\";\nfunction usePlasmicCanvasComponentInfo(props) {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () {\n        // Inside Plasmic Studio, code components will receive an additional prop\n        // that contains selection information for that specific code component.\n        // This hook will return that selection information which is useful for\n        // changing the behavior of the code component when it is selected, making\n        // it easier to interact with code components and slots that aren't always\n        // visible in the canvas. (e.g. automatically opening a modal when it's selected)\n        var selectionInfo = props === null || props === void 0 ? void 0 : props[INTERNAL_CC_CANVAS_SELECTION_PROP];\n        if (selectionInfo) {\n            return {\n                isSelected: selectionInfo.isSelected,\n                selectedSlotName: selectionInfo.selectedSlotName,\n            };\n        }\n        return null;\n    }, [props]);\n}\n\nvar tuple = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\n\nvar DataContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction mkMetaName(name) {\n    return \"__plasmic_meta_\".concat(name);\n}\nfunction mkMetaValue(meta) {\n    return meta;\n}\nfunction applySelector(rawData, selector) {\n    if (!selector) {\n        return undefined;\n    }\n    var curData = rawData;\n    for (var _i = 0, _a = selector.split(\".\"); _i < _a.length; _i++) {\n        var key = _a[_i];\n        curData = curData === null || curData === void 0 ? void 0 : curData[key];\n    }\n    return curData;\n}\nfunction useSelector(selector) {\n    var rawData = useDataEnv();\n    return applySelector(rawData, selector);\n}\nfunction useSelectors(selectors) {\n    if (selectors === void 0) { selectors = {}; }\n    var rawData = useDataEnv();\n    return Object.fromEntries(Object.entries(selectors)\n        .filter(function (_a) {\n        var key = _a[0], selector = _a[1];\n        return !!key && !!selector;\n    })\n        .map(function (_a) {\n        var key = _a[0], selector = _a[1];\n        return tuple(key, applySelector(rawData, selector));\n    }));\n}\nfunction useDataEnv() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DataContext);\n}\nfunction DataProvider(_a) {\n    var name = _a.name, data = _a.data, hidden = _a.hidden, advanced = _a.advanced, label = _a.label, children = _a.children;\n    var parentContext = useDataEnv();\n    var childContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        var _a;\n        if (!name) {\n            return null;\n        }\n        return __assign(__assign({}, parentContext), (_a = {}, _a[name] = data, _a[mkMetaName(name)] = mkMetaValue({ hidden: hidden, advanced: advanced, label: label }), _a));\n    }, [parentContext, name, data, hidden, advanced, label]);\n    if (childContext === null) {\n        return react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, children);\n    }\n    else {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataContext.Provider, { value: childContext }, children));\n    }\n}\n/**\n * This transforms `{ \"...slug\": \"a/b/c\" }` into `{ \"slug\": [\"a\", \"b\", \"c\"] }.\n */\nfunction fixCatchallParams(params) {\n    var newParams = {};\n    for (var _i = 0, _a = Object.entries(params); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (!value) {\n            continue;\n        }\n        if (key.startsWith(\"...\")) {\n            newParams[key.slice(3)] =\n                typeof value === \"string\"\n                    ? value.replace(/^\\/|\\/$/g, \"\").split(\"/\")\n                    : value;\n        }\n        else {\n            newParams[key] = value;\n        }\n    }\n    return newParams;\n}\nfunction mkPathFromRouteAndParams(route, params) {\n    if (!params) {\n        return route;\n    }\n    var path = route;\n    for (var _i = 0, _a = Object.entries(params); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (typeof value === \"string\") {\n            path = path.replace(\"[\".concat(key, \"]\"), value);\n        }\n        else if (Array.isArray(value)) {\n            if (path.includes(\"[[...\".concat(key, \"]]\"))) {\n                path = path.replace(\"[[...\".concat(key, \"]]\"), value.join(\"/\"));\n            }\n            else if (path.includes(\"[...\".concat(key, \"]\"))) {\n                path = path.replace(\"[...\".concat(key, \"]\"), value.join(\"/\"));\n            }\n        }\n    }\n    return path;\n}\nfunction PageParamsProvider(_a) {\n    var children = _a.children, route = _a.route, deprecatedRoute = _a.path, _b = _a.params, params = _b === void 0 ? {} : _b, _c = _a.query, query = _c === void 0 ? {} : _c;\n    route = route !== null && route !== void 0 ? route : deprecatedRoute;\n    params = fixCatchallParams(params);\n    var $ctx = useDataEnv() || {};\n    var path = route ? mkPathFromRouteAndParams(route, params) : undefined;\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, { name: \"pageRoute\", data: route, label: \"Page route\", advanced: true },\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, { name: \"pagePath\", data: path, label: \"Page path\" },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, { name: \"params\", data: __assign(__assign({}, $ctx.params), params), label: \"Page URL path params\" },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, { name: \"query\", data: __assign(__assign({}, $ctx.query), query), label: \"Page URL query params\" }, children)))));\n}\nfunction DataCtxReader(_a) {\n    var children = _a.children;\n    var $ctx = useDataEnv();\n    return children($ctx);\n}\n\nvar root$7 = globalThis;\nroot$7.__PlasmicFetcherRegistry = [];\nfunction registerFetcher(fetcher, meta) {\n    root$7.__PlasmicFetcherRegistry.push({ fetcher: fetcher, meta: meta });\n}\n\nvar GlobalActionsContext = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction GlobalActionsProvider(props) {\n    var contextName = props.contextName, children = props.children, actions = props.actions;\n    var existingActions = useGlobalActions();\n    var namespacedActions = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(function () {\n        return Object.fromEntries(Object.entries(actions).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return [\n                \"\".concat(contextName, \".\").concat(key),\n                val,\n            ];\n        }));\n    }, [contextName, actions]);\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(GlobalActionsContext.Provider, { value: __assign(__assign({}, existingActions), namespacedActions) }, children));\n}\nfunction useGlobalActions() {\n    var _a;\n    return (_a = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(GlobalActionsContext)) !== null && _a !== void 0 ? _a : {};\n}\n\nvar PlasmicLinkContext = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicLinkMaybe() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n}\nvar AnchorLink = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(function AnchorLink(props, ref) {\n    return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", __assign({}, props, { ref: ref }));\n});\nfunction usePlasmicLink() {\n    var Link = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n    if (Link) {\n        return Link;\n    }\n    else {\n        return AnchorLink;\n    }\n}\nfunction PlasmicLinkProvider(props) {\n    var Link = props.Link, children = props.children;\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(PlasmicLinkContext.Provider, { value: Link }, children));\n}\n\nvar root$6 = globalThis;\n// A compile-time error will occur if a new field is added to the StateHelper\n// interface but not included in the keys array of state helper.\nvar stateHelpersKeys = [\n    \"initFunc\",\n    \"onChangeArgsToValue\",\n    \"onMutate\",\n];\nif (root$6.__PlasmicComponentRegistry == null) {\n    root$6.__PlasmicComponentRegistry = [];\n}\nfunction registerComponent(component, meta) {\n    // Check for duplicates\n    if (root$6.__PlasmicComponentRegistry.some(function (r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$6.__PlasmicComponentRegistry.push({ component: component, meta: meta });\n}\n\nvar root$5 = globalThis;\nif (root$5.__PlasmicFunctionsRegistry == null) {\n    root$5.__PlasmicFunctionsRegistry = [];\n}\nfunction registerFunction(fn, meta) {\n    // Check for duplicates\n    if (root$5.__PlasmicFunctionsRegistry.some(function (r) {\n        return r.function === fn &&\n            r.meta.name === meta.name &&\n            r.meta.namespace == meta.namespace;\n    })) {\n        return;\n    }\n    root$5.__PlasmicFunctionsRegistry.push({ function: fn, meta: meta });\n}\n\nvar root$4 = globalThis;\nif (root$4.__PlasmicContextRegistry == null) {\n    root$4.__PlasmicContextRegistry = [];\n}\nfunction registerGlobalContext(component, meta) {\n    // Check for duplicates\n    if (root$4.__PlasmicContextRegistry.some(function (r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$4.__PlasmicContextRegistry.push({ component: component, meta: meta });\n}\n\nvar root$3 = globalThis;\nif (root$3.__PlasmicTokenRegistry == null) {\n    root$3.__PlasmicTokenRegistry = [];\n}\nfunction registerToken(token) {\n    root$3.__PlasmicTokenRegistry.push(token);\n}\n\nvar root$2 = globalThis;\nif (root$2.__PlasmicTraitRegistry == null) {\n    root$2.__PlasmicTraitRegistry = [];\n}\nfunction registerTrait(trait, meta) {\n    root$2.__PlasmicTraitRegistry.push({\n        trait: trait,\n        meta: meta,\n    });\n}\n\nvar _a$1, _b;\nfunction repeatedElement(index, elt) {\n    return repeatedElementFn(index, elt);\n}\nvar repeatedElementFn = function (index, elt) {\n    if (Array.isArray(elt)) {\n        return elt.map(function (v) { return repeatedElementFn(index, v); });\n    }\n    if (elt && (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elt) && typeof elt !== \"string\") {\n        return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elt);\n    }\n    return elt;\n};\nvar root$1 = globalThis;\nvar setRepeatedElementFn = (_b = (_a$1 = root$1 === null || root$1 === void 0 ? void 0 : root$1.__Sub) === null || _a$1 === void 0 ? void 0 : _a$1.setRepeatedElementFn) !== null && _b !== void 0 ? _b : function (fn) {\n    repeatedElementFn = fn;\n};\n\nvar PlasmicTranslatorContext = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicTranslator() {\n    var _t = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicTranslatorContext);\n    var translator = _t\n        ? typeof _t === \"function\"\n            ? _t\n            : _t.translator\n        : undefined;\n    return translator;\n}\n\nvar hostModule = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DataContext: DataContext,\n    DataCtxReader: DataCtxReader,\n    DataProvider: DataProvider,\n    GlobalActionsContext: GlobalActionsContext,\n    GlobalActionsProvider: GlobalActionsProvider,\n    PageParamsProvider: PageParamsProvider,\n    PlasmicCanvasContext: PlasmicCanvasContext,\n    PlasmicCanvasHost: PlasmicCanvasHost,\n    PlasmicLinkProvider: PlasmicLinkProvider,\n    PlasmicTranslatorContext: PlasmicTranslatorContext,\n    applySelector: applySelector,\n    mkMetaName: mkMetaName,\n    mkMetaValue: mkMetaValue,\n    registerComponent: registerComponent,\n    registerFunction: registerFunction,\n    registerGlobalContext: registerGlobalContext,\n    registerToken: registerToken,\n    registerTrait: registerTrait,\n    repeatedElement: repeatedElement,\n    stateHelpersKeys: stateHelpersKeys,\n    unstable_registerFetcher: registerFetcher,\n    useDataEnv: useDataEnv,\n    useGlobalActions: useGlobalActions,\n    usePlasmicCanvasComponentInfo: usePlasmicCanvasComponentInfo,\n    usePlasmicCanvasContext: usePlasmicCanvasContext,\n    usePlasmicLink: usePlasmicLink,\n    usePlasmicLinkMaybe: usePlasmicLinkMaybe,\n    usePlasmicTranslator: usePlasmicTranslator,\n    useSelector: useSelector,\n    useSelectors: useSelectors\n});\n\nvar hostVersion = \"1.0.222\";\n\nvar _a;\nvar root = globalThis;\nif (root.__Sub == null) {\n    // Creating a side effect here by logging, so that vite won't\n    // ignore this block for whatever reason. Hiding this for now\n    // as users are complaining; will have to check if this has\n    // been fixed with vite.\n    // console.log(\"Plasmic: Setting up app host dependencies\");\n    root.__Sub = __assign({ React: react__WEBPACK_IMPORTED_MODULE_1__, ReactDOM: react_dom__WEBPACK_IMPORTED_MODULE_2__, jsxRuntime: react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__, jsxDevRuntime: react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__, PlasmicQuery: _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__, hostModule: hostModule, hostVersion: hostVersion, hostUtils: {\n            setPlasmicRootNode: setPlasmicRootNode,\n            registerRenderErrorListener: registerRenderErrorListener,\n            setRepeatedElementFn: setRepeatedElementFn,\n        }, \n        // For backwards compatibility:\n        setPlasmicRootNode: setPlasmicRootNode, registerRenderErrorListener: registerRenderErrorListener, setRepeatedElementFn: setRepeatedElementFn }, hostModule);\n}\nelse {\n    console.warn(\"Encountered likely duplicate host version: \".concat(root.__Sub.hostVersion, \" vs \").concat(hostVersion));\n    root.__Sub.duplicateHostVersions = (_a = root.__Sub.duplicateHostVersions) !== null && _a !== void 0 ? _a : [];\n    root.__Sub.duplicateHostVersions.push(hostVersion);\n}\n\n\n//# sourceMappingURL=host.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9ob3N0L2Rpc3QvaG9zdC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0Q7QUFDbkI7QUFDaUc7QUFDMUY7QUFDaUI7QUFDUDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtDQUFRO0FBQ3JCLGlCQUFpQixrREFBVztBQUM1QixrQ0FBa0Msa0JBQWtCO0FBQ3BELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFtQjtBQUM5QztBQUNBLFdBQVcsNkNBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLDJDQUFjO0FBQzNCO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFxQixDQUFDLGdEQUFtQixrQkFBa0IsNkJBQTZCO0FBQ3ZHLFlBQVksZ0RBQW1CLGtDQUFrQywyQkFBMkI7QUFDNUY7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQ0FBYztBQUMzQixJQUFJLDRDQUFlO0FBQ25CLGdCQUFnQixnREFBbUI7QUFDbkMsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsMkNBQWM7QUFDOUMsNkJBQTZCLGdEQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyREFBMkQseUJBQXlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFtQixDQUFDLDJDQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw0Q0FBZTtBQUNqQjtBQUNBLFFBQVEsS0FBcUMsRUFBRSxFQUUxQztBQUNMLFlBQVksZ0RBQW1CLGFBQWE7QUFDNUMsbUVBQW1FLHFEQUFxRCxzREFBc0Qsd0RBQXdELCtFQUErRSxzQkFBc0IsNEJBQTRCLGdCQUFnQixhQUFhLFlBQVksZ0JBQWdCLGNBQWMsTUFBTSxzREFBc0QsYUFBYSxXQUFXLFNBQVM7QUFDM2dCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9EQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLGlEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQix3REFBd0Qsa0RBQWtEO0FBQ3ZLLEtBQUs7QUFDTDtBQUNBLGVBQWUsMERBQTRCLENBQUMsdURBQXVCO0FBQ25FO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQTRCLHlCQUF5QixxQkFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQixVQUFVLHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsZ0RBQWdEO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBNEIsaUJBQWlCLHFFQUFxRTtBQUM5SCxRQUFRLDBEQUE0QixpQkFBaUIsa0RBQWtEO0FBQ3ZHLFlBQVksMERBQTRCLGlCQUFpQiwwQ0FBMEMsd0RBQXdEO0FBQzNKLGdCQUFnQiwwREFBNEIsaUJBQWlCLHlDQUF5Qyx1REFBdUQ7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7O0FBRUEsMkJBQTJCLDBEQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsWUFBWSwwREFBNEIsa0NBQWtDLDJCQUEyQix3Q0FBd0M7QUFDN0k7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUF5QjtBQUMxQzs7QUFFQSx5QkFBeUIsMERBQTRCO0FBQ3JEO0FBQ0EsV0FBVyx1REFBeUI7QUFDcEM7QUFDQSxpQkFBaUIsdURBQXlCO0FBQzFDLFdBQVcsMERBQTRCLGlCQUFpQixXQUFXLFVBQVU7QUFDN0UsQ0FBQztBQUNEO0FBQ0EsZUFBZSx1REFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBNEIsZ0NBQWdDLGFBQWE7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkMsa0NBQWtDO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0M7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0EsZUFBZSxxREFBYztBQUM3QixlQUFlLG1EQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwREFBNEI7QUFDM0Q7QUFDQSxhQUFhLHVEQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxrQ0FBSyxZQUFZLHNDQUFRLGNBQWMsOENBQVUsaUJBQWlCLGtEQUFhLGdCQUFnQiw4Q0FBWTtBQUM5STtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzSkFBc0o7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUya0I7QUFDM2tCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXEBwbGFzbWljYXBwXFxob3N0XFxkaXN0XFxob3N0LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgKiBhcyBQbGFzbWljUXVlcnkgZnJvbSAnQHBsYXNtaWNhcHAvcXVlcnknO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgaXNWYWxpZEVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgKiBhcyBqc3hEZXZSdW50aW1lIGZyb20gJ3JlYWN0L2pzeC1kZXYtcnVudGltZSc7XG5pbXBvcnQgKiBhcyBqc3hSdW50aW1lIGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGVuc3VyZSh4LCBtc2cpIHtcbiAgICBpZiAobXNnID09PSB2b2lkIDApIHsgbXNnID0gXCJcIjsgfVxuICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgbXNnID0gKGlzU3RyaW5nKG1zZykgPyBtc2cgOiBtc2coKSkgfHwgXCJcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGxcIi5jb25jYXQobXNnID8gXCItIFwiLmNvbmNhdChtc2cpIDogXCJcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZSgwKSwgc2V0VGljayA9IF9hWzFdO1xuICAgIHZhciB1cGRhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpY2soZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuIHRpY2sgKyAxOyB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuaWYgKGdsb2JhbFRoaXMuX19QbGFzbWljSG9zdFZlcnNpb24gPT0gbnVsbCkge1xuICAgIGdsb2JhbFRoaXMuX19QbGFzbWljSG9zdFZlcnNpb24gPSBcIjNcIjtcbn1cbnZhciByb290Q2hhbmdlTGlzdGVuZXJzID0gW107XG52YXIgUGxhc21pY1Jvb3ROb2RlV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGFzbWljUm9vdE5vZGVXcmFwcGVyKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHJvb3RDaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWx1ZTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIFBsYXNtaWNSb290Tm9kZVdyYXBwZXI7XG59KCkpO1xudmFyIHBsYXNtaWNSb290Tm9kZSA9IG5ldyBQbGFzbWljUm9vdE5vZGVXcmFwcGVyKG51bGwpO1xuZnVuY3Rpb24gZ2V0SGFzaFBhcmFtcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5oYXNoLnJlcGxhY2UoL14jLywgXCI/XCIpKTtcbn1cbmZ1bmN0aW9uIGdldFBsYXNtaWNPcmlnaW4oKSB7XG4gICAgdmFyIHBhcmFtcyA9IGdldEhhc2hQYXJhbXMoKTtcbiAgICByZXR1cm4gZW5zdXJlKHBhcmFtcy5nZXQoXCJvcmlnaW5cIiksIFwiTWlzc2luZyBpbmZvcm1hdGlvbiBmcm9tIFBsYXNtaWMgd2luZG93LlwiKTtcbn1cbmZ1bmN0aW9uIGdldFN0dWRpb0hhc2goKSB7XG4gICAgdmFyIGhhc2hQYXJhbXMgPSBnZXRIYXNoUGFyYW1zKCk7XG4gICAgaWYgKGhhc2hQYXJhbXMuaGFzKFwic3R1ZGlvSGFzaFwiKSkge1xuICAgICAgICByZXR1cm4gaGFzaFBhcmFtcy5nZXQoXCJzdHVkaW9IYXNoXCIpO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXM7XG4gICAgcmV0dXJuIHVybFBhcmFtcy5nZXQoXCJzdHVkaW8taGFzaFwiKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclN0dWRpb0ludG9JZnJhbWUoKSB7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgdmFyIHBsYXNtaWNPcmlnaW4gPSBnZXRQbGFzbWljT3JpZ2luKCk7XG4gICAgdmFyIGhhc2ggPSBnZXRTdHVkaW9IYXNoKCk7XG4gICAgc2NyaXB0LnNyYyA9IFwiXCIuY29uY2F0KHBsYXNtaWNPcmlnaW4sIFwiL3N0YXRpYy9qcy9zdHVkaW9cIikuY29uY2F0KGhhc2ggPyBcIi5cIi5jb25jYXQoaGFzaCwgXCIuanNcIikgOiBcIi5qc1wiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG52YXIgcmVuZGVyQ291bnQgPSAwO1xuZnVuY3Rpb24gc2V0UGxhc21pY1Jvb3ROb2RlKG5vZGUpIHtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHJlbmRlckNvdW50LCB3aGljaCB3ZSB1c2UgYXMga2V5IHRvIEVycm9yQm91bmRhcnksIHNvXG4gICAgLy8gd2UgY2FuIHJlc2V0IHRoZSBlcnJvciBvbiBlYWNoIHJlbmRlclxuICAgIHJlbmRlckNvdW50Kys7XG4gICAgcGxhc21pY1Jvb3ROb2RlLnNldChub2RlKTtcbn1cbi8qKlxuICogUmVhY3QgY29udGV4dCB0byBkZXRlY3Qgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIG9uIFBsYXNtaWMgZWRpdG9yLlxuICogSWYgbm90LCByZXR1cm4gZmFsc2UuXG4gKiBJZiBzbywgcmV0dXJuIGFuIG9iamVjdCB3aXRoIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbXBvbmVudFxuICovXG52YXIgUGxhc21pY0NhbnZhc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGZhbHNlKTtcbnZhciB1c2VQbGFzbWljQ2FudmFzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChQbGFzbWljQ2FudmFzQ29udGV4dCk7XG59O1xuZnVuY3Rpb24gX1BsYXNtaWNDYW52YXNIb3N0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gSWYgd2luZG93LnBhcmVudCBpcyBudWxsLCB0aGVuIHRoaXMgaXMgYSB3aW5kb3cgd2hvc2UgY29udGFpbmluZyBpZnJhbWVcbiAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIHRoZSBET00gKGZvciB0aGUgdG9wIHdpbmRvdywgd2luZG93LnBhcmVudCA9PT0gd2luZG93KS5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZy4gIElmIHdpbmRvdy5wYXJlbnQgaXMgbnVsbCwgYnkgdGhlIHdheSxcbiAgICAvLyBsb2NhdGlvbi5oYXNoIHdpbGwgYWxzbyBiZSBudWxsLlxuICAgIHZhciBpc0ZyYW1lQXR0YWNoZWQgPSAhIXdpbmRvdy5wYXJlbnQ7XG4gICAgdmFyIGlzQ2FudmFzID0gISEoKF9hID0gbG9jYXRpb24uaGFzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9cXGJjYW52YXM9dHJ1ZVxcYi8pKTtcbiAgICB2YXIgaXNMaXZlID0gISEoKF9iID0gbG9jYXRpb24uaGFzaCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hdGNoKC9cXGJsaXZlPXRydWVcXGIvKSkgfHwgIWlzRnJhbWVBdHRhY2hlZDtcbiAgICB2YXIgc2hvdWxkUmVuZGVyU3R1ZGlvID0gaXNGcmFtZUF0dGFjaGVkICYmXG4gICAgICAgICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3BsYXNtaWMtc3R1ZGlvLXRhZ1wiKSAmJlxuICAgICAgICAhaXNDYW52YXMgJiZcbiAgICAgICAgIWlzTGl2ZTtcbiAgICB2YXIgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3RDaGFuZ2VMaXN0ZW5lcnMucHVzaChmb3JjZVVwZGF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByb290Q2hhbmdlTGlzdGVuZXJzLmluZGV4T2YoZm9yY2VVcGRhdGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICByb290Q2hhbmdlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW2ZvcmNlVXBkYXRlXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbmRlclN0dWRpbyAmJiBpc0ZyYW1lQXR0YWNoZWQgJiYgd2luZG93LnBhcmVudCAhPT0gd2luZG93KSB7XG4gICAgICAgICAgICByZW5kZXJTdHVkaW9JbnRvSWZyYW1lKCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2hvdWxkUmVuZGVyU3R1ZGlvLCBpc0ZyYW1lQXR0YWNoZWRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNob3VsZFJlbmRlclN0dWRpbyAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNnZXRsaWJzXCIpICYmIGlzTGl2ZSkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHRFbHQuaWQgPSBcImdldGxpYnNcIjtcbiAgICAgICAgICAgIHNjcmlwdEVsdC5zcmMgPSBnZXRQbGFzbWljT3JpZ2luKCkgKyBcIi9zdGF0aWMvanMvZ2V0bGlicy5qc1wiO1xuICAgICAgICAgICAgc2NyaXB0RWx0LmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICBzY3JpcHRFbHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gd2luZG93KS5fX0dldGxpYnNSZWFkeVJlc29sdmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWx0KTtcbiAgICAgICAgfVxuICAgIH0sIFtzaG91bGRSZW5kZXJTdHVkaW9dKTtcbiAgICB2YXIgX2MgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmVDYW52YXNDb250ZXh0VmFsdWUoKTtcbiAgICB9KSwgY2FudmFzQ29udGV4dFZhbHVlID0gX2NbMF0sIHNldENhbnZhc0NvbnRleHRWYWx1ZSA9IF9jWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0NhbnZhcykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FudmFzQ29udGV4dFZhbHVlKGRlcml2ZUNhbnZhc0NvbnRleHRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgbGlzdGVuZXJfMSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIGxpc3RlbmVyXzEpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgW2lzQ2FudmFzXSk7XG4gICAgaWYgKCFpc0ZyYW1lQXR0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0NhbnZhcyB8fCBpc0xpdmUpIHtcbiAgICAgICAgdmFyIGFwcERpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGxhc21pYy1hcHAuX193YWJfdXNlci1ib2R5XCIpO1xuICAgICAgICBpZiAoIWFwcERpdikge1xuICAgICAgICAgICAgYXBwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFwcERpdi5pZCA9IFwicGxhc21pYy1hcHBcIjtcbiAgICAgICAgICAgIGFwcERpdi5jbGFzc0xpc3QuYWRkKFwiX193YWJfdXNlci1ib2R5XCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5wcmVwZW5kKGFwcERpdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHsga2V5OiBcIlwiLmNvbmNhdChyZW5kZXJDb3VudCkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhc21pY0NhbnZhc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNhbnZhc0NvbnRleHRWYWx1ZSB9LCBwbGFzbWljUm9vdE5vZGUuZ2V0KCkpKSwgYXBwRGl2LCBcInBsYXNtaWMtYXBwXCIpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVuZGVyU3R1ZGlvICYmIHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIiwgeyBzcmM6IFwiaHR0cHM6Ly9kb2NzLnBsYXNtaWMuYXBwL2FwcC1jb250ZW50L2FwcC1ob3N0LXJlYWR5I2FwcEhvc3RVcmw9XCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5ocmVmKSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwdndcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgekluZGV4OiA5OTk5OTk5OSxcbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBQbGFzbWljQ2FudmFzSG9zdCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBlbmFibGVXZWJwYWNrSG1yID0gcHJvcHMuZW5hYmxlV2VicGFja0htcjtcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZShudWxsKSwgbm9kZSA9IF9hWzBdLCBzZXROb2RlID0gX2FbMV07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0Tm9kZShSZWFjdC5jcmVhdGVFbGVtZW50KF9QbGFzbWljQ2FudmFzSG9zdCwgbnVsbCkpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICFlbmFibGVXZWJwYWNrSG1yICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlzYWJsZVdlYnBhY2tIbXIsIG51bGwpLFxuICAgICAgICBub2RlKSk7XG59O1xudmFyIHJlbmRlckVycm9yTGlzdGVuZXJzID0gW107XG5mdW5jdGlvbiByZWdpc3RlclJlbmRlckVycm9yTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICByZW5kZXJFcnJvckxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZW5kZXJFcnJvckxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJlbmRlckVycm9yTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yQm91bmRhcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyb3IgfTtcbiAgICB9O1xuICAgIEVycm9yQm91bmRhcnkucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJlbmRlckVycm9yTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihlcnJvcik7IH0pO1xuICAgIH07XG4gICAgRXJyb3JCb3VuZGFyeS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBcIkVycm9yOiBcIiwgXCJcIi5jb25jYXQodGhpcy5zdGF0ZS5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFcnJvckJvdW5kYXJ5O1xufShSZWFjdC5Db21wb25lbnQpKTtcbmZ1bmN0aW9uIERpc2FibGVXZWJwYWNrSG1yKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCIsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IFwiXFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICBjb25zdCBSZWFsRXZlbnRTb3VyY2UgPSB3aW5kb3cuRXZlbnRTb3VyY2U7XFxuICAgICAgICB3aW5kb3cuRXZlbnRTb3VyY2UgPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xcbiAgICAgICAgICBpZiAoL1teYS16QS1aXWhtcigkfFteYS16QS1aXSkvLnRlc3QodXJsKSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcXFwiUGxhc21pYzogZGlzYWJsZWQgRXZlbnRTb3VyY2UgcmVxdWVzdCBmb3JcXFwiLCB1cmwpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICBvbmVycm9yKCkge30sIG9ubWVzc2FnZSgpIHt9LCBvbm9wZW4oKSB7fSwgY2xvc2UoKSB7fVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFsRXZlbnRTb3VyY2UodXJsLCBjb25maWcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIFwiLFxuICAgICAgICB9IH0pKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZUNhbnZhc0NvbnRleHRWYWx1ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY3JlYXRlIFVSTHNlYXJjaFBhcmFtcyBza2lwcGluZyB0aGUgaW5pdGlhbCAjIGNoYXJhY3RlclxuICAgICAgICB2YXIgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhoYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIGlmIChwYXJhbXMuZ2V0KFwiY2FudmFzXCIpID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFZhcmlhbnRzID0gcGFyYW1zLmdldChcImdsb2JhbFZhcmlhbnRzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lOiAoX2EgPSBwYXJhbXMuZ2V0KFwiY29tcG9uZW50TmFtZVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBnbG9iYWxWYXJpYW50czogZ2xvYmFsVmFyaWFudHMgPyBKU09OLnBhcnNlKGdsb2JhbFZhcmlhbnRzKSA6IHt9LFxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiBwYXJhbXMuZ2V0KFwiaW50ZXJhY3RpdmVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgSU5URVJOQUxfQ0NfQ0FOVkFTX1NFTEVDVElPTl9QUk9QID0gXCJfX3BsYXNtaWNfc2VsZWN0aW9uX3Byb3BfX1wiO1xuZnVuY3Rpb24gdXNlUGxhc21pY0NhbnZhc0NvbXBvbmVudEluZm8ocHJvcHMpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluc2lkZSBQbGFzbWljIFN0dWRpbywgY29kZSBjb21wb25lbnRzIHdpbGwgcmVjZWl2ZSBhbiBhZGRpdGlvbmFsIHByb3BcbiAgICAgICAgLy8gdGhhdCBjb250YWlucyBzZWxlY3Rpb24gaW5mb3JtYXRpb24gZm9yIHRoYXQgc3BlY2lmaWMgY29kZSBjb21wb25lbnQuXG4gICAgICAgIC8vIFRoaXMgaG9vayB3aWxsIHJldHVybiB0aGF0IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3aGljaCBpcyB1c2VmdWwgZm9yXG4gICAgICAgIC8vIGNoYW5naW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgY29kZSBjb21wb25lbnQgd2hlbiBpdCBpcyBzZWxlY3RlZCwgbWFraW5nXG4gICAgICAgIC8vIGl0IGVhc2llciB0byBpbnRlcmFjdCB3aXRoIGNvZGUgY29tcG9uZW50cyBhbmQgc2xvdHMgdGhhdCBhcmVuJ3QgYWx3YXlzXG4gICAgICAgIC8vIHZpc2libGUgaW4gdGhlIGNhbnZhcy4gKGUuZy4gYXV0b21hdGljYWxseSBvcGVuaW5nIGEgbW9kYWwgd2hlbiBpdCdzIHNlbGVjdGVkKVxuICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tJTlRFUk5BTF9DQ19DQU5WQVNfU0VMRUNUSU9OX1BST1BdO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBzZWxlY3Rpb25JbmZvLmlzU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRTbG90TmFtZTogc2VsZWN0aW9uSW5mby5zZWxlY3RlZFNsb3ROYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBbcHJvcHNdKTtcbn1cblxudmFyIHR1cGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn07XG5cbnZhciBEYXRhQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmZ1bmN0aW9uIG1rTWV0YU5hbWUobmFtZSkge1xuICAgIHJldHVybiBcIl9fcGxhc21pY19tZXRhX1wiLmNvbmNhdChuYW1lKTtcbn1cbmZ1bmN0aW9uIG1rTWV0YVZhbHVlKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YTtcbn1cbmZ1bmN0aW9uIGFwcGx5U2VsZWN0b3IocmF3RGF0YSwgc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBjdXJEYXRhID0gcmF3RGF0YTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2VsZWN0b3Iuc3BsaXQoXCIuXCIpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICBjdXJEYXRhID0gY3VyRGF0YSA9PT0gbnVsbCB8fCBjdXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJEYXRhW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjdXJEYXRhO1xufVxuZnVuY3Rpb24gdXNlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB2YXIgcmF3RGF0YSA9IHVzZURhdGFFbnYoKTtcbiAgICByZXR1cm4gYXBwbHlTZWxlY3RvcihyYXdEYXRhLCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiB1c2VTZWxlY3RvcnMoc2VsZWN0b3JzKSB7XG4gICAgaWYgKHNlbGVjdG9ycyA9PT0gdm9pZCAwKSB7IHNlbGVjdG9ycyA9IHt9OyB9XG4gICAgdmFyIHJhd0RhdGEgPSB1c2VEYXRhRW52KCk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzZWxlY3RvcnMpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVswXSwgc2VsZWN0b3IgPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuICEha2V5ICYmICEhc2VsZWN0b3I7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hWzBdLCBzZWxlY3RvciA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gdHVwbGUoa2V5LCBhcHBseVNlbGVjdG9yKHJhd0RhdGEsIHNlbGVjdG9yKSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gdXNlRGF0YUVudigpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChEYXRhQ29udGV4dCk7XG59XG5mdW5jdGlvbiBEYXRhUHJvdmlkZXIoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIGRhdGEgPSBfYS5kYXRhLCBoaWRkZW4gPSBfYS5oaWRkZW4sIGFkdmFuY2VkID0gX2EuYWR2YW5jZWQsIGxhYmVsID0gX2EubGFiZWwsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSB1c2VEYXRhRW52KCk7XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0KSwgKF9hID0ge30sIF9hW25hbWVdID0gZGF0YSwgX2FbbWtNZXRhTmFtZShuYW1lKV0gPSBta01ldGFWYWx1ZSh7IGhpZGRlbjogaGlkZGVuLCBhZHZhbmNlZDogYWR2YW5jZWQsIGxhYmVsOiBsYWJlbCB9KSwgX2EpKTtcbiAgICB9LCBbcGFyZW50Q29udGV4dCwgbmFtZSwgZGF0YSwgaGlkZGVuLCBhZHZhbmNlZCwgbGFiZWxdKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGF0YUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNoaWxkQ29udGV4dCB9LCBjaGlsZHJlbikpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyB0cmFuc2Zvcm1zIGB7IFwiLi4uc2x1Z1wiOiBcImEvYi9jXCIgfWAgaW50byBgeyBcInNsdWdcIjogW1wiYVwiLCBcImJcIiwgXCJjXCJdIH0uXG4gKi9cbmZ1bmN0aW9uIGZpeENhdGNoYWxsUGFyYW1zKHBhcmFtcykge1xuICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiLi4uXCIpKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXNba2V5LnNsaWNlKDMpXSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWUucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3UGFyYW1zO1xufVxuZnVuY3Rpb24gbWtQYXRoRnJvbVJvdXRlQW5kUGFyYW1zKHJvdXRlLCBwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxuICAgIHZhciBwYXRoID0gcm91dGU7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHBhcmFtcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoXCJbXCIuY29uY2F0KGtleSwgXCJdXCIpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKFwiW1suLi5cIi5jb25jYXQoa2V5LCBcIl1dXCIpKSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoXCJbWy4uLlwiLmNvbmNhdChrZXksIFwiXV1cIiksIHZhbHVlLmpvaW4oXCIvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGguaW5jbHVkZXMoXCJbLi4uXCIuY29uY2F0KGtleSwgXCJdXCIpKSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoXCJbLi4uXCIuY29uY2F0KGtleSwgXCJdXCIpLCB2YWx1ZS5qb2luKFwiL1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBQYWdlUGFyYW1zUHJvdmlkZXIoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgcm91dGUgPSBfYS5yb3V0ZSwgZGVwcmVjYXRlZFJvdXRlID0gX2EucGF0aCwgX2IgPSBfYS5wYXJhbXMsIHBhcmFtcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IF9hLnF1ZXJ5LCBxdWVyeSA9IF9jID09PSB2b2lkIDAgPyB7fSA6IF9jO1xuICAgIHJvdXRlID0gcm91dGUgIT09IG51bGwgJiYgcm91dGUgIT09IHZvaWQgMCA/IHJvdXRlIDogZGVwcmVjYXRlZFJvdXRlO1xuICAgIHBhcmFtcyA9IGZpeENhdGNoYWxsUGFyYW1zKHBhcmFtcyk7XG4gICAgdmFyICRjdHggPSB1c2VEYXRhRW52KCkgfHwge307XG4gICAgdmFyIHBhdGggPSByb3V0ZSA/IG1rUGF0aEZyb21Sb3V0ZUFuZFBhcmFtcyhyb3V0ZSwgcGFyYW1zKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGF0YVByb3ZpZGVyLCB7IG5hbWU6IFwicGFnZVJvdXRlXCIsIGRhdGE6IHJvdXRlLCBsYWJlbDogXCJQYWdlIHJvdXRlXCIsIGFkdmFuY2VkOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGF0YVByb3ZpZGVyLCB7IG5hbWU6IFwicGFnZVBhdGhcIiwgZGF0YTogcGF0aCwgbGFiZWw6IFwiUGFnZSBwYXRoXCIgfSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGF0YVByb3ZpZGVyLCB7IG5hbWU6IFwicGFyYW1zXCIsIGRhdGE6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAkY3R4LnBhcmFtcyksIHBhcmFtcyksIGxhYmVsOiBcIlBhZ2UgVVJMIHBhdGggcGFyYW1zXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERhdGFQcm92aWRlciwgeyBuYW1lOiBcInF1ZXJ5XCIsIGRhdGE6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAkY3R4LnF1ZXJ5KSwgcXVlcnkpLCBsYWJlbDogXCJQYWdlIFVSTCBxdWVyeSBwYXJhbXNcIiB9LCBjaGlsZHJlbikpKSkpO1xufVxuZnVuY3Rpb24gRGF0YUN0eFJlYWRlcihfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciAkY3R4ID0gdXNlRGF0YUVudigpO1xuICAgIHJldHVybiBjaGlsZHJlbigkY3R4KTtcbn1cblxudmFyIHJvb3QkNyA9IGdsb2JhbFRoaXM7XG5yb290JDcuX19QbGFzbWljRmV0Y2hlclJlZ2lzdHJ5ID0gW107XG5mdW5jdGlvbiByZWdpc3RlckZldGNoZXIoZmV0Y2hlciwgbWV0YSkge1xuICAgIHJvb3QkNy5fX1BsYXNtaWNGZXRjaGVyUmVnaXN0cnkucHVzaCh7IGZldGNoZXI6IGZldGNoZXIsIG1ldGE6IG1ldGEgfSk7XG59XG5cbnZhciBHbG9iYWxBY3Rpb25zQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmZ1bmN0aW9uIEdsb2JhbEFjdGlvbnNQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBjb250ZXh0TmFtZSA9IHByb3BzLmNvbnRleHROYW1lLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBhY3Rpb25zID0gcHJvcHMuYWN0aW9ucztcbiAgICB2YXIgZXhpc3RpbmdBY3Rpb25zID0gdXNlR2xvYmFsQWN0aW9ucygpO1xuICAgIHZhciBuYW1lc3BhY2VkQWN0aW9ucyA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGFjdGlvbnMpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KGNvbnRleHROYW1lLCBcIi5cIikuY29uY2F0KGtleSksXG4gICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtjb250ZXh0TmFtZSwgYWN0aW9uc10pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChHbG9iYWxBY3Rpb25zQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogX19hc3NpZ24oX19hc3NpZ24oe30sIGV4aXN0aW5nQWN0aW9ucyksIG5hbWVzcGFjZWRBY3Rpb25zKSB9LCBjaGlsZHJlbikpO1xufVxuZnVuY3Rpb24gdXNlR2xvYmFsQWN0aW9ucygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoR2xvYmFsQWN0aW9uc0NvbnRleHQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbn1cblxudmFyIFBsYXNtaWNMaW5rQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmZ1bmN0aW9uIHVzZVBsYXNtaWNMaW5rTWF5YmUoKSB7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoUGxhc21pY0xpbmtDb250ZXh0KTtcbn1cbnZhciBBbmNob3JMaW5rID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiBBbmNob3JMaW5rKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oe30sIHByb3BzLCB7IHJlZjogcmVmIH0pKTtcbn0pO1xuZnVuY3Rpb24gdXNlUGxhc21pY0xpbmsoKSB7XG4gICAgdmFyIExpbmsgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KFBsYXNtaWNMaW5rQ29udGV4dCk7XG4gICAgaWYgKExpbmspIHtcbiAgICAgICAgcmV0dXJuIExpbms7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQW5jaG9yTGluaztcbiAgICB9XG59XG5mdW5jdGlvbiBQbGFzbWljTGlua1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIExpbmsgPSBwcm9wcy5MaW5rLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChQbGFzbWljTGlua0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IExpbmsgfSwgY2hpbGRyZW4pKTtcbn1cblxudmFyIHJvb3QkNiA9IGdsb2JhbFRoaXM7XG4vLyBBIGNvbXBpbGUtdGltZSBlcnJvciB3aWxsIG9jY3VyIGlmIGEgbmV3IGZpZWxkIGlzIGFkZGVkIHRvIHRoZSBTdGF0ZUhlbHBlclxuLy8gaW50ZXJmYWNlIGJ1dCBub3QgaW5jbHVkZWQgaW4gdGhlIGtleXMgYXJyYXkgb2Ygc3RhdGUgaGVscGVyLlxudmFyIHN0YXRlSGVscGVyc0tleXMgPSBbXG4gICAgXCJpbml0RnVuY1wiLFxuICAgIFwib25DaGFuZ2VBcmdzVG9WYWx1ZVwiLFxuICAgIFwib25NdXRhdGVcIixcbl07XG5pZiAocm9vdCQ2Ll9fUGxhc21pY0NvbXBvbmVudFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgICByb290JDYuX19QbGFzbWljQ29tcG9uZW50UmVnaXN0cnkgPSBbXTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCwgbWV0YSkge1xuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgaWYgKHJvb3QkNi5fX1BsYXNtaWNDb21wb25lbnRSZWdpc3RyeS5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmNvbXBvbmVudCA9PT0gY29tcG9uZW50ICYmIHIubWV0YS5uYW1lID09PSBtZXRhLm5hbWU7XG4gICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByb290JDYuX19QbGFzbWljQ29tcG9uZW50UmVnaXN0cnkucHVzaCh7IGNvbXBvbmVudDogY29tcG9uZW50LCBtZXRhOiBtZXRhIH0pO1xufVxuXG52YXIgcm9vdCQ1ID0gZ2xvYmFsVGhpcztcbmlmIChyb290JDUuX19QbGFzbWljRnVuY3Rpb25zUmVnaXN0cnkgPT0gbnVsbCkge1xuICAgIHJvb3QkNS5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeSA9IFtdO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJGdW5jdGlvbihmbiwgbWV0YSkge1xuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgaWYgKHJvb3QkNS5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeS5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmZ1bmN0aW9uID09PSBmbiAmJlxuICAgICAgICAgICAgci5tZXRhLm5hbWUgPT09IG1ldGEubmFtZSAmJlxuICAgICAgICAgICAgci5tZXRhLm5hbWVzcGFjZSA9PSBtZXRhLm5hbWVzcGFjZTtcbiAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QkNS5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeS5wdXNoKHsgZnVuY3Rpb246IGZuLCBtZXRhOiBtZXRhIH0pO1xufVxuXG52YXIgcm9vdCQ0ID0gZ2xvYmFsVGhpcztcbmlmIChyb290JDQuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgICByb290JDQuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5ID0gW107XG59XG5mdW5jdGlvbiByZWdpc3Rlckdsb2JhbENvbnRleHQoY29tcG9uZW50LCBtZXRhKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICBpZiAocm9vdCQ0Ll9fUGxhc21pY0NvbnRleHRSZWdpc3RyeS5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmNvbXBvbmVudCA9PT0gY29tcG9uZW50ICYmIHIubWV0YS5uYW1lID09PSBtZXRhLm5hbWU7XG4gICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByb290JDQuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5LnB1c2goeyBjb21wb25lbnQ6IGNvbXBvbmVudCwgbWV0YTogbWV0YSB9KTtcbn1cblxudmFyIHJvb3QkMyA9IGdsb2JhbFRoaXM7XG5pZiAocm9vdCQzLl9fUGxhc21pY1Rva2VuUmVnaXN0cnkgPT0gbnVsbCkge1xuICAgIHJvb3QkMy5fX1BsYXNtaWNUb2tlblJlZ2lzdHJ5ID0gW107XG59XG5mdW5jdGlvbiByZWdpc3RlclRva2VuKHRva2VuKSB7XG4gICAgcm9vdCQzLl9fUGxhc21pY1Rva2VuUmVnaXN0cnkucHVzaCh0b2tlbik7XG59XG5cbnZhciByb290JDIgPSBnbG9iYWxUaGlzO1xuaWYgKHJvb3QkMi5fX1BsYXNtaWNUcmFpdFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgICByb290JDIuX19QbGFzbWljVHJhaXRSZWdpc3RyeSA9IFtdO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFpdCh0cmFpdCwgbWV0YSkge1xuICAgIHJvb3QkMi5fX1BsYXNtaWNUcmFpdFJlZ2lzdHJ5LnB1c2goe1xuICAgICAgICB0cmFpdDogdHJhaXQsXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgfSk7XG59XG5cbnZhciBfYSQxLCBfYjtcbmZ1bmN0aW9uIHJlcGVhdGVkRWxlbWVudChpbmRleCwgZWx0KSB7XG4gICAgcmV0dXJuIHJlcGVhdGVkRWxlbWVudEZuKGluZGV4LCBlbHQpO1xufVxudmFyIHJlcGVhdGVkRWxlbWVudEZuID0gZnVuY3Rpb24gKGluZGV4LCBlbHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbHQpKSB7XG4gICAgICAgIHJldHVybiBlbHQubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiByZXBlYXRlZEVsZW1lbnRGbihpbmRleCwgdik7IH0pO1xuICAgIH1cbiAgICBpZiAoZWx0ICYmIGlzVmFsaWRFbGVtZW50KGVsdCkgJiYgdHlwZW9mIGVsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG59O1xudmFyIHJvb3QkMSA9IGdsb2JhbFRoaXM7XG52YXIgc2V0UmVwZWF0ZWRFbGVtZW50Rm4gPSAoX2IgPSAoX2EkMSA9IHJvb3QkMSA9PT0gbnVsbCB8fCByb290JDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QkMS5fX1N1YikgPT09IG51bGwgfHwgX2EkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EkMS5zZXRSZXBlYXRlZEVsZW1lbnRGbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmVwZWF0ZWRFbGVtZW50Rm4gPSBmbjtcbn07XG5cbnZhciBQbGFzbWljVHJhbnNsYXRvckNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5mdW5jdGlvbiB1c2VQbGFzbWljVHJhbnNsYXRvcigpIHtcbiAgICB2YXIgX3QgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCk7XG4gICAgdmFyIHRyYW5zbGF0b3IgPSBfdFxuICAgICAgICA/IHR5cGVvZiBfdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IF90XG4gICAgICAgICAgICA6IF90LnRyYW5zbGF0b3JcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG59XG5cbnZhciBob3N0TW9kdWxlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBEYXRhQ29udGV4dDogRGF0YUNvbnRleHQsXG4gICAgRGF0YUN0eFJlYWRlcjogRGF0YUN0eFJlYWRlcixcbiAgICBEYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcixcbiAgICBHbG9iYWxBY3Rpb25zQ29udGV4dDogR2xvYmFsQWN0aW9uc0NvbnRleHQsXG4gICAgR2xvYmFsQWN0aW9uc1Byb3ZpZGVyOiBHbG9iYWxBY3Rpb25zUHJvdmlkZXIsXG4gICAgUGFnZVBhcmFtc1Byb3ZpZGVyOiBQYWdlUGFyYW1zUHJvdmlkZXIsXG4gICAgUGxhc21pY0NhbnZhc0NvbnRleHQ6IFBsYXNtaWNDYW52YXNDb250ZXh0LFxuICAgIFBsYXNtaWNDYW52YXNIb3N0OiBQbGFzbWljQ2FudmFzSG9zdCxcbiAgICBQbGFzbWljTGlua1Byb3ZpZGVyOiBQbGFzbWljTGlua1Byb3ZpZGVyLFxuICAgIFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dDogUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0LFxuICAgIGFwcGx5U2VsZWN0b3I6IGFwcGx5U2VsZWN0b3IsXG4gICAgbWtNZXRhTmFtZTogbWtNZXRhTmFtZSxcbiAgICBta01ldGFWYWx1ZTogbWtNZXRhVmFsdWUsXG4gICAgcmVnaXN0ZXJDb21wb25lbnQ6IHJlZ2lzdGVyQ29tcG9uZW50LFxuICAgIHJlZ2lzdGVyRnVuY3Rpb246IHJlZ2lzdGVyRnVuY3Rpb24sXG4gICAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0OiByZWdpc3Rlckdsb2JhbENvbnRleHQsXG4gICAgcmVnaXN0ZXJUb2tlbjogcmVnaXN0ZXJUb2tlbixcbiAgICByZWdpc3RlclRyYWl0OiByZWdpc3RlclRyYWl0LFxuICAgIHJlcGVhdGVkRWxlbWVudDogcmVwZWF0ZWRFbGVtZW50LFxuICAgIHN0YXRlSGVscGVyc0tleXM6IHN0YXRlSGVscGVyc0tleXMsXG4gICAgdW5zdGFibGVfcmVnaXN0ZXJGZXRjaGVyOiByZWdpc3RlckZldGNoZXIsXG4gICAgdXNlRGF0YUVudjogdXNlRGF0YUVudixcbiAgICB1c2VHbG9iYWxBY3Rpb25zOiB1c2VHbG9iYWxBY3Rpb25zLFxuICAgIHVzZVBsYXNtaWNDYW52YXNDb21wb25lbnRJbmZvOiB1c2VQbGFzbWljQ2FudmFzQ29tcG9uZW50SW5mbyxcbiAgICB1c2VQbGFzbWljQ2FudmFzQ29udGV4dDogdXNlUGxhc21pY0NhbnZhc0NvbnRleHQsXG4gICAgdXNlUGxhc21pY0xpbms6IHVzZVBsYXNtaWNMaW5rLFxuICAgIHVzZVBsYXNtaWNMaW5rTWF5YmU6IHVzZVBsYXNtaWNMaW5rTWF5YmUsXG4gICAgdXNlUGxhc21pY1RyYW5zbGF0b3I6IHVzZVBsYXNtaWNUcmFuc2xhdG9yLFxuICAgIHVzZVNlbGVjdG9yOiB1c2VTZWxlY3RvcixcbiAgICB1c2VTZWxlY3RvcnM6IHVzZVNlbGVjdG9yc1xufSk7XG5cbnZhciBob3N0VmVyc2lvbiA9IFwiMS4wLjIyMlwiO1xuXG52YXIgX2E7XG52YXIgcm9vdCA9IGdsb2JhbFRoaXM7XG5pZiAocm9vdC5fX1N1YiA9PSBudWxsKSB7XG4gICAgLy8gQ3JlYXRpbmcgYSBzaWRlIGVmZmVjdCBoZXJlIGJ5IGxvZ2dpbmcsIHNvIHRoYXQgdml0ZSB3b24ndFxuICAgIC8vIGlnbm9yZSB0aGlzIGJsb2NrIGZvciB3aGF0ZXZlciByZWFzb24uIEhpZGluZyB0aGlzIGZvciBub3dcbiAgICAvLyBhcyB1c2VycyBhcmUgY29tcGxhaW5pbmc7IHdpbGwgaGF2ZSB0byBjaGVjayBpZiB0aGlzIGhhc1xuICAgIC8vIGJlZW4gZml4ZWQgd2l0aCB2aXRlLlxuICAgIC8vIGNvbnNvbGUubG9nKFwiUGxhc21pYzogU2V0dGluZyB1cCBhcHAgaG9zdCBkZXBlbmRlbmNpZXNcIik7XG4gICAgcm9vdC5fX1N1YiA9IF9fYXNzaWduKHsgUmVhY3Q6IFJlYWN0LCBSZWFjdERPTTogUmVhY3RET00sIGpzeFJ1bnRpbWU6IGpzeFJ1bnRpbWUsIGpzeERldlJ1bnRpbWU6IGpzeERldlJ1bnRpbWUsIFBsYXNtaWNRdWVyeTogUGxhc21pY1F1ZXJ5LCBob3N0TW9kdWxlOiBob3N0TW9kdWxlLCBob3N0VmVyc2lvbjogaG9zdFZlcnNpb24sIGhvc3RVdGlsczoge1xuICAgICAgICAgICAgc2V0UGxhc21pY1Jvb3ROb2RlOiBzZXRQbGFzbWljUm9vdE5vZGUsXG4gICAgICAgICAgICByZWdpc3RlclJlbmRlckVycm9yTGlzdGVuZXI6IHJlZ2lzdGVyUmVuZGVyRXJyb3JMaXN0ZW5lcixcbiAgICAgICAgICAgIHNldFJlcGVhdGVkRWxlbWVudEZuOiBzZXRSZXBlYXRlZEVsZW1lbnRGbixcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbiAgICAgICAgc2V0UGxhc21pY1Jvb3ROb2RlOiBzZXRQbGFzbWljUm9vdE5vZGUsIHJlZ2lzdGVyUmVuZGVyRXJyb3JMaXN0ZW5lcjogcmVnaXN0ZXJSZW5kZXJFcnJvckxpc3RlbmVyLCBzZXRSZXBlYXRlZEVsZW1lbnRGbjogc2V0UmVwZWF0ZWRFbGVtZW50Rm4gfSwgaG9zdE1vZHVsZSk7XG59XG5lbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJFbmNvdW50ZXJlZCBsaWtlbHkgZHVwbGljYXRlIGhvc3QgdmVyc2lvbjogXCIuY29uY2F0KHJvb3QuX19TdWIuaG9zdFZlcnNpb24sIFwiIHZzIFwiKS5jb25jYXQoaG9zdFZlcnNpb24pKTtcbiAgICByb290Ll9fU3ViLmR1cGxpY2F0ZUhvc3RWZXJzaW9ucyA9IChfYSA9IHJvb3QuX19TdWIuZHVwbGljYXRlSG9zdFZlcnNpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICByb290Ll9fU3ViLmR1cGxpY2F0ZUhvc3RWZXJzaW9ucy5wdXNoKGhvc3RWZXJzaW9uKTtcbn1cblxuZXhwb3J0IHsgRGF0YUNvbnRleHQsIERhdGFDdHhSZWFkZXIsIERhdGFQcm92aWRlciwgR2xvYmFsQWN0aW9uc0NvbnRleHQsIEdsb2JhbEFjdGlvbnNQcm92aWRlciwgUGFnZVBhcmFtc1Byb3ZpZGVyLCBQbGFzbWljQ2FudmFzQ29udGV4dCwgUGxhc21pY0NhbnZhc0hvc3QsIFBsYXNtaWNMaW5rUHJvdmlkZXIsIFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCwgYXBwbHlTZWxlY3RvciwgbWtNZXRhTmFtZSwgbWtNZXRhVmFsdWUsIHJlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlckZ1bmN0aW9uLCByZWdpc3Rlckdsb2JhbENvbnRleHQsIHJlZ2lzdGVyVG9rZW4sIHJlZ2lzdGVyVHJhaXQsIHJlcGVhdGVkRWxlbWVudCwgc3RhdGVIZWxwZXJzS2V5cywgcmVnaXN0ZXJGZXRjaGVyIGFzIHVuc3RhYmxlX3JlZ2lzdGVyRmV0Y2hlciwgdXNlRGF0YUVudiwgdXNlR2xvYmFsQWN0aW9ucywgdXNlUGxhc21pY0NhbnZhc0NvbXBvbmVudEluZm8sIHVzZVBsYXNtaWNDYW52YXNDb250ZXh0LCB1c2VQbGFzbWljTGluaywgdXNlUGxhc21pY0xpbmtNYXliZSwgdXNlUGxhc21pY1RyYW5zbGF0b3IsIHVzZVNlbGVjdG9yLCB1c2VTZWxlY3RvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvc3QuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@plasmicapp/isomorphic-unfetch/browser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = self.fetch || (self.fetch = (__webpack_require__(/*! unfetch */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\")[\"default\"]) || __webpack_require__(/*! unfetch */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9pc29tb3JwaGljLXVuZmV0Y2gvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2Q0FBNkMsOEhBQTBCLElBQUksbUJBQU8sQ0FBQyw0RkFBUyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxcaXNvbW9ycGhpYy11bmZldGNoXFxicm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaCB8fCAoc2VsZi5mZXRjaCA9IHJlcXVpcmUoJ3VuZmV0Y2gnKS5kZWZhdWx0IHx8IHJlcXVpcmUoJ3VuZmV0Y2gnKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-core/dist/index.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.PlasmicModulesFetcher),\n/* harmony export */   PlasmicTracker: () => (/* binding */ PlasmicTracker),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   getBundleSubset: () => (/* binding */ getBundleSubset)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(pages-dir-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\n\n\n// src/deps-graph.ts\nvar DepsGraph = class {\n  constructor(bundle, browserBuild) {\n    this.bundle = bundle;\n    this.browserBuild = browserBuild;\n    this.dependsOn = {};\n    this.dependedBy = {};\n    this.rebuildGraph();\n  }\n  getTransitiveDependers(name2) {\n    return this.transitiveCrawl(name2, this.dependedBy);\n  }\n  getTransitiveDeps(name2) {\n    if (!(name2 in this.dependsOn)) {\n      return [];\n    }\n    return this.transitiveCrawl(name2, this.dependsOn);\n  }\n  transitiveCrawl(name2, edges) {\n    const deps = /* @__PURE__ */ new Set();\n    const crawl = (dep2) => {\n      var _a;\n      if (deps.has(dep2)) {\n        return;\n      }\n      deps.add(dep2);\n      for (const subdep of (_a = edges[dep2]) != null ? _a : []) {\n        crawl(subdep);\n      }\n    };\n    for (const dep2 of edges[name2]) {\n      crawl(dep2);\n    }\n    return Array.from(deps);\n  }\n  rebuildGraph() {\n    this.dependedBy = {};\n    this.dependsOn = {};\n    for (const mod of this.browserBuild ? this.bundle.modules.browser : this.bundle.modules.server) {\n      if (mod.type === \"code\") {\n        for (const imported of mod.imports) {\n          if (!(mod.fileName in this.dependsOn)) {\n            this.dependsOn[mod.fileName] = [imported];\n          } else {\n            this.dependsOn[mod.fileName].push(imported);\n          }\n          if (!(imported in this.dependedBy)) {\n            this.dependedBy[imported] = [mod.fileName];\n          } else {\n            this.dependedBy[imported].push(mod.fileName);\n          }\n        }\n      }\n    }\n  }\n};\n\n// src/bundles.ts\nfunction getBundleSubset(bundle, names, opts2) {\n  var _a, _b;\n  const namesSet = new Set(names);\n  const target = (_a = opts2 == null ? void 0 : opts2.target) != null ? _a : \"browser\";\n  const forBrowser = target === \"browser\";\n  const graph = new DepsGraph(bundle, forBrowser);\n  const deps = new Set(names.flatMap((name2) => graph.getTransitiveDeps(name2)));\n  const isSubModule = (fileName) => deps.has(fileName) || namesSet.has(fileName);\n  const modules = bundle.modules[target];\n  const filteredModules = modules.filter((mod) => isSubModule(mod.fileName));\n  const filteredComponents = bundle.components.filter(\n    (c) => isSubModule(c.entry)\n  );\n  const filteredComponentsIds = new Set(filteredComponents.map((c) => c.id));\n  const filteredIds = Object.fromEntries(\n    Object.entries(bundle.filteredIds).map(([k, v]) => [k, [...v]])\n  );\n  bundle.components.filter((c) => !filteredComponentsIds.has(c.id)).forEach((component) => {\n    var _a2;\n    filteredIds[component.projectId] = (_a2 = filteredIds[component.projectId]) != null ? _a2 : [];\n    if (!filteredIds[component.projectId].includes(component.id)) {\n      filteredIds[component.projectId].push(component.id);\n    }\n  });\n  return {\n    modules: {\n      browser: forBrowser ? filteredModules : [],\n      server: forBrowser ? [] : filteredModules\n    },\n    components: filteredComponents,\n    globalGroups: bundle.globalGroups,\n    projects: bundle.projects,\n    activeSplits: bundle.activeSplits,\n    bundleKey: (_b = bundle.bundleKey) != null ? _b : null,\n    deferChunksByDefault: bundle.deferChunksByDefault,\n    disableRootLoadingBoundaryByDefault: bundle.disableRootLoadingBoundaryByDefault,\n    filteredIds\n  };\n}\n\n// src/registry.ts\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction isModuleBundlePromiseSet(name2) {\n  return globalThis.__PlasmicBundlePromises && !!globalThis.__PlasmicBundlePromises[name2] && !!globalThis.__PlasmicBundlePromises[name2].then;\n}\nvar Registry = class {\n  constructor() {\n    this.loadedModules = {};\n    this.registeredModules = {};\n    this.modules = {};\n  }\n  register(name2, module) {\n    this.registeredModules[name2] = module;\n  }\n  isEmpty() {\n    return Object.keys(this.loadedModules).length === 0;\n  }\n  clear() {\n    this.loadedModules = {};\n  }\n  getRegisteredModule(name2) {\n    return this.registeredModules[name2];\n  }\n  hasModule(name2, opts2 = {}) {\n    if (name2 in this.registeredModules && !opts2.forceOriginal) {\n      return true;\n    }\n    if (name2 in this.modules) {\n      return true;\n    }\n    if (globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name2]) {\n      return true;\n    }\n    if (isModuleBundlePromiseSet(name2)) {\n      return true;\n    }\n    return false;\n  }\n  load(name, opts = {}) {\n    if (name in this.registeredModules && !opts.forceOriginal) {\n      return this.registeredModules[name];\n    }\n    if (name in this.loadedModules) {\n      return this.loadedModules[name];\n    }\n    if (!this.modules[name] && globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name]) {\n      this.modules[name] = globalThis.__PLASMIC_CHUNKS[name];\n    }\n    if (!this.modules[name] && isModuleBundlePromiseSet(name)) {\n      throw globalThis.__PlasmicBundlePromises[name];\n    }\n    if (!(name in this.modules)) {\n      throw new Error(`Unknown module ${name}`);\n    }\n    const code = this.modules[name];\n    const requireFn = isBrowser ? (dep2) => {\n      const normalizedDep = resolvePath(dep2, name);\n      return this.load(normalizedDep);\n    } : (dep) => {\n      try {\n        const normalizedDep = resolvePath(dep, name);\n        return this.load(normalizedDep);\n      } catch (err) {\n        try {\n          return eval(\"require\")(dep);\n        } catch (e) {\n          throw err;\n        }\n      }\n    };\n    let func;\n    try {\n      func = new Function(\"require\", \"exports\", code);\n    } catch (err2) {\n      throw new Error(`PLASMIC: Failed to create function for ${name}: ${err2}`);\n    }\n    const exports = {};\n    this.loadedModules[name] = exports;\n    try {\n      func(requireFn, exports);\n    } catch (err2) {\n      delete this.loadedModules[name];\n      if (!(err2 instanceof Error) && !!err2 && !!err2.then) {\n        throw err2;\n      }\n      throw new Error(`PLASMIC: Failed to load ${name}: ${err2}`);\n    }\n    return exports;\n  }\n  updateModules(bundle) {\n    let updated = false;\n    for (const mod of isBrowser ? bundle.modules.browser : bundle.modules.server) {\n      if (mod.type === \"code\" && !!mod.code && mod.code !== this.modules[mod.fileName]) {\n        this.modules[mod.fileName] = mod.code;\n        if (!globalThis.__PLASMIC_CHUNKS) {\n          globalThis.__PLASMIC_CHUNKS = {};\n        }\n        globalThis.__PLASMIC_CHUNKS[mod.fileName] = mod.code;\n        updated = true;\n      }\n    }\n    if (updated) {\n      this.clear();\n    }\n  }\n};\nfunction resolvePath(path, from) {\n  const fromParts = from.split(\"/\");\n  const pathParts = path.split(\"/\");\n  if (pathParts.length === 0) {\n    return path;\n  }\n  if (pathParts[0] === \".\") {\n    return [\n      ...fromParts.slice(0, fromParts.length - 1),\n      ...pathParts.slice(1)\n    ].join(\"/\");\n  } else if (pathParts[0] === \"..\") {\n    let count = 0;\n    for (const part of pathParts) {\n      if (part === \"..\") {\n        count += 1;\n      } else {\n        break;\n      }\n    }\n    return [\n      ...fromParts.slice(0, fromParts.length - count - 1),\n      ...pathParts.slice(count)\n    ].join(\"/\");\n  } else {\n    return path;\n  }\n}\n\n// src/tracker/index.ts\n\n\n// src/tracker/utils.ts\nvar isBrowser2 = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction getPlasmicCookieValues() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return Object.fromEntries(\n    document.cookie.split(\"; \").filter((cookie) => cookie.includes(\"plasmic:\")).map((cookie) => cookie.split(\"=\")).map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\nfunction getVariationCookieValues() {\n  const cookies = getPlasmicCookieValues();\n  return Object.fromEntries(\n    Object.keys(cookies).map((key) => [key.split(\".\")[1], cookies[key]]).filter((val) => !!val[0])\n  );\n}\nfunction getDistinctId() {\n  if (!isBrowser2) {\n    return \"LOADER-SERVER\";\n  }\n  return \"LOADER-CLIENT\";\n}\nfunction getCampaignParams() {\n  const { location } = window;\n  const params = {};\n  try {\n    const url = new URL(location.href);\n    const CAMPAIGN_KEYWORDS = [\n      \"utm_source\",\n      \"utm_medium\",\n      \"utm_campaign\",\n      \"utm_content\",\n      \"utm_term\",\n      \"gclid\"\n    ];\n    CAMPAIGN_KEYWORDS.forEach((keyword) => {\n      const value = url.searchParams.get(keyword);\n      if (value) {\n        params[keyword] = value;\n      }\n    });\n  } catch (err2) {\n  }\n  return params;\n}\nfunction getLocationMeta() {\n  const { location } = window;\n  const { referrer } = document;\n  return __spreadValues({\n    url: location.href,\n    host: location.host,\n    pathname: location.pathname,\n    referrer\n  }, getCampaignParams());\n}\nfunction getScreenMeta() {\n  const { screen } = window;\n  return {\n    screen_height: screen.height,\n    screen_width: screen.width,\n    viewport_height: window.innerHeight,\n    viewport_width: window.innerWidth\n  };\n}\nfunction getOS(userAgent) {\n  if (/Windows/i.test(userAgent)) {\n    if (/Phone/.test(userAgent) || /WPDesktop/.test(userAgent)) {\n      return \"Windows Phone\";\n    }\n    return \"Windows\";\n  } else if (/(iPhone|iPad|iPod)/.test(userAgent)) {\n    return \"iOS\";\n  } else if (/Android/.test(userAgent)) {\n    return \"Android\";\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {\n    return \"BlackBerry\";\n  } else if (/Mac/i.test(userAgent)) {\n    return \"Mac OS X\";\n  } else if (/Linux/.test(userAgent)) {\n    return \"Linux\";\n  } else if (/CrOS/.test(userAgent)) {\n    return \"Chrome OS\";\n  } else {\n    return \"\";\n  }\n}\nfunction getDeviceInfo(userAgent) {\n  const PATTERNS = [\n    {\n      device: \"iPhone\",\n      patterns: [/iPhone/]\n    },\n    {\n      device: \"iPad\",\n      patterns: [/iPad/]\n    },\n    {\n      device: \"iPod Touch\",\n      patterns: [/iPod/]\n    },\n    {\n      device: \"Windows Phone\",\n      patterns: [/Windows Phone/i, /WPDesktop/]\n    },\n    {\n      device: \"Android\",\n      patterns: [/Android/]\n    }\n  ];\n  const match = PATTERNS.find(\n    (pattern) => pattern.patterns.some((expr) => expr.test(userAgent))\n  );\n  const device = match == null ? void 0 : match.device;\n  return {\n    device: device != null ? device : \"\",\n    deviceType: device ? \"Mobile\" : \"Desktop\",\n    os: getOS(userAgent)\n  };\n}\nfunction getUserAgentMeta() {\n  const { navigator } = window;\n  const { userAgent } = navigator;\n  return __spreadValues({}, getDeviceInfo(userAgent));\n}\nfunction getWindowMeta() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return __spreadValues(__spreadValues(__spreadValues({}, getLocationMeta()), getScreenMeta()), getUserAgentMeta());\n}\nvar isProduction = \"development\" === \"production\";\nfunction getEnvMeta() {\n  return {\n    isBrowser: isBrowser2,\n    isProduction\n  };\n}\nfunction rawSplitVariation(variation) {\n  const rawVariations = {};\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    if (splitId) {\n      rawVariations[splitId] = variation[variationKey];\n    }\n  });\n  return rawVariations;\n}\nvar POLL_TIME = 5e3;\nfunction throttled(func2) {\n  let timerId = void 0;\n  return (param) => {\n    if (timerId) {\n      return;\n    }\n    if (isBrowser2) {\n      timerId = window.requestAnimationFrame(() => {\n        timerId = void 0;\n        func2(param);\n      });\n    } else {\n      timerId = setTimeout(() => {\n        timerId = void 0;\n        func2(param);\n      }, POLL_TIME);\n    }\n  };\n}\n\n// src/tracker/index.ts\nvar API_ENDPOINT = \"https://analytics.plasmic.app/capture\";\nvar API_PUBLIC_KEY = \"phc_BRvYTAoMoam9fDHfrIneF67KdtMJagLVVCM6ELNYd4n\";\nvar TRACKER_VERSION = 4;\nvar PlasmicTracker = class {\n  constructor(opts2) {\n    this.opts = opts2;\n    this.eventQueue = [];\n    this.sendEvents = throttled((transport) => __async(this, null, function* () {\n      if (this.eventQueue.length === 0) {\n        return;\n      }\n      const events = [...this.eventQueue];\n      this.eventQueue.length = 0;\n      const body = {\n        api_key: API_PUBLIC_KEY,\n        batch: events\n      };\n      try {\n        const stringBody = JSON.stringify(body);\n        if (transport === \"beacon\") {\n          window.navigator.sendBeacon(API_ENDPOINT, stringBody);\n        } else {\n          this.fetch(API_ENDPOINT, {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\"\n            },\n            body: stringBody\n          }).then(() => {\n          }).catch(() => {\n          });\n        }\n      } catch (err2) {\n      }\n    }));\n    this.fetch = (opts2.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default())).bind(globalThis);\n  }\n  trackRender(opts2) {\n    var _a, _b;\n    this.enqueue({\n      event: \"$render\",\n      properties: __spreadValues(__spreadValues(__spreadValues({}, this.getProperties()), (_a = opts2 == null ? void 0 : opts2.renderCtx) != null ? _a : {}), rawSplitVariation((_b = opts2 == null ? void 0 : opts2.variation) != null ? _b : {}))\n    });\n  }\n  trackFetch() {\n    this.enqueue({\n      event: \"$fetch\",\n      properties: this.getProperties()\n    });\n  }\n  trackConversion(value = 0) {\n    this.enqueue({\n      event: \"$conversion\",\n      properties: __spreadProps(__spreadValues({}, this.getProperties()), {\n        value\n      })\n    });\n  }\n  getProperties() {\n    var _a;\n    return __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({\n      distinct_id: getDistinctId()\n    }, getWindowMeta()), getEnvMeta()), this.getContextMeta()), getVariationCookieValues()), {\n      timestamp: (_a = Date.now()) != null ? _a : +/* @__PURE__ */ new Date(),\n      trackerVersion: TRACKER_VERSION\n    });\n  }\n  enqueue(event) {\n    if (this.opts.__plasmicTrackerDisabled) {\n      return;\n    }\n    this.eventQueue.push(event);\n    this.sendEvents(\"fetch\");\n  }\n  getContextMeta() {\n    return {\n      platform: this.opts.platform,\n      preview: this.opts.preview,\n      projectIds: this.opts.projectIds\n    };\n  }\n};\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItY29yZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ3dFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnRUFBZ0UsS0FBSyxJQUFJLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLElBQUksS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsWUFBWTtBQUN0QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLG1CQUFtQixhQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMLDZFQUE2RSx1RUFBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBGQUEwRixzRkFBc0Y7QUFDalAsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcQHBsYXNtaWNhcHBcXGxvYWRlci1jb3JlXFxkaXN0XFxpbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IEFwaSwgUGxhc21pY01vZHVsZXNGZXRjaGVyIH0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1mZXRjaGVyXCI7XG5cbi8vIHNyYy9kZXBzLWdyYXBoLnRzXG52YXIgRGVwc0dyYXBoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihidW5kbGUsIGJyb3dzZXJCdWlsZCkge1xuICAgIHRoaXMuYnVuZGxlID0gYnVuZGxlO1xuICAgIHRoaXMuYnJvd3NlckJ1aWxkID0gYnJvd3NlckJ1aWxkO1xuICAgIHRoaXMuZGVwZW5kc09uID0ge307XG4gICAgdGhpcy5kZXBlbmRlZEJ5ID0ge307XG4gICAgdGhpcy5yZWJ1aWxkR3JhcGgoKTtcbiAgfVxuICBnZXRUcmFuc2l0aXZlRGVwZW5kZXJzKG5hbWUyKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGl2ZUNyYXdsKG5hbWUyLCB0aGlzLmRlcGVuZGVkQnkpO1xuICB9XG4gIGdldFRyYW5zaXRpdmVEZXBzKG5hbWUyKSB7XG4gICAgaWYgKCEobmFtZTIgaW4gdGhpcy5kZXBlbmRzT24pKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpdmVDcmF3bChuYW1lMiwgdGhpcy5kZXBlbmRzT24pO1xuICB9XG4gIHRyYW5zaXRpdmVDcmF3bChuYW1lMiwgZWRnZXMpIHtcbiAgICBjb25zdCBkZXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBjcmF3bCA9IChkZXAyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZGVwcy5oYXMoZGVwMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVwcy5hZGQoZGVwMik7XG4gICAgICBmb3IgKGNvbnN0IHN1YmRlcCBvZiAoX2EgPSBlZGdlc1tkZXAyXSkgIT0gbnVsbCA/IF9hIDogW10pIHtcbiAgICAgICAgY3Jhd2woc3ViZGVwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGVwMiBvZiBlZGdlc1tuYW1lMl0pIHtcbiAgICAgIGNyYXdsKGRlcDIpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShkZXBzKTtcbiAgfVxuICByZWJ1aWxkR3JhcGgoKSB7XG4gICAgdGhpcy5kZXBlbmRlZEJ5ID0ge307XG4gICAgdGhpcy5kZXBlbmRzT24gPSB7fTtcbiAgICBmb3IgKGNvbnN0IG1vZCBvZiB0aGlzLmJyb3dzZXJCdWlsZCA/IHRoaXMuYnVuZGxlLm1vZHVsZXMuYnJvd3NlciA6IHRoaXMuYnVuZGxlLm1vZHVsZXMuc2VydmVyKSB7XG4gICAgICBpZiAobW9kLnR5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW1wb3J0ZWQgb2YgbW9kLmltcG9ydHMpIHtcbiAgICAgICAgICBpZiAoIShtb2QuZmlsZU5hbWUgaW4gdGhpcy5kZXBlbmRzT24pKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZHNPblttb2QuZmlsZU5hbWVdID0gW2ltcG9ydGVkXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRzT25bbW9kLmZpbGVOYW1lXS5wdXNoKGltcG9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoaW1wb3J0ZWQgaW4gdGhpcy5kZXBlbmRlZEJ5KSkge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlZEJ5W2ltcG9ydGVkXSA9IFttb2QuZmlsZU5hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVkQnlbaW1wb3J0ZWRdLnB1c2gobW9kLmZpbGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9idW5kbGVzLnRzXG5mdW5jdGlvbiBnZXRCdW5kbGVTdWJzZXQoYnVuZGxlLCBuYW1lcywgb3B0czIpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgbmFtZXNTZXQgPSBuZXcgU2V0KG5hbWVzKTtcbiAgY29uc3QgdGFyZ2V0ID0gKF9hID0gb3B0czIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMyLnRhcmdldCkgIT0gbnVsbCA/IF9hIDogXCJicm93c2VyXCI7XG4gIGNvbnN0IGZvckJyb3dzZXIgPSB0YXJnZXQgPT09IFwiYnJvd3NlclwiO1xuICBjb25zdCBncmFwaCA9IG5ldyBEZXBzR3JhcGgoYnVuZGxlLCBmb3JCcm93c2VyKTtcbiAgY29uc3QgZGVwcyA9IG5ldyBTZXQobmFtZXMuZmxhdE1hcCgobmFtZTIpID0+IGdyYXBoLmdldFRyYW5zaXRpdmVEZXBzKG5hbWUyKSkpO1xuICBjb25zdCBpc1N1Yk1vZHVsZSA9IChmaWxlTmFtZSkgPT4gZGVwcy5oYXMoZmlsZU5hbWUpIHx8IG5hbWVzU2V0LmhhcyhmaWxlTmFtZSk7XG4gIGNvbnN0IG1vZHVsZXMgPSBidW5kbGUubW9kdWxlc1t0YXJnZXRdO1xuICBjb25zdCBmaWx0ZXJlZE1vZHVsZXMgPSBtb2R1bGVzLmZpbHRlcigobW9kKSA9PiBpc1N1Yk1vZHVsZShtb2QuZmlsZU5hbWUpKTtcbiAgY29uc3QgZmlsdGVyZWRDb21wb25lbnRzID0gYnVuZGxlLmNvbXBvbmVudHMuZmlsdGVyKFxuICAgIChjKSA9PiBpc1N1Yk1vZHVsZShjLmVudHJ5KVxuICApO1xuICBjb25zdCBmaWx0ZXJlZENvbXBvbmVudHNJZHMgPSBuZXcgU2V0KGZpbHRlcmVkQ29tcG9uZW50cy5tYXAoKGMpID0+IGMuaWQpKTtcbiAgY29uc3QgZmlsdGVyZWRJZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoYnVuZGxlLmZpbHRlcmVkSWRzKS5tYXAoKFtrLCB2XSkgPT4gW2ssIFsuLi52XV0pXG4gICk7XG4gIGJ1bmRsZS5jb21wb25lbnRzLmZpbHRlcigoYykgPT4gIWZpbHRlcmVkQ29tcG9uZW50c0lkcy5oYXMoYy5pZCkpLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgZmlsdGVyZWRJZHNbY29tcG9uZW50LnByb2plY3RJZF0gPSAoX2EyID0gZmlsdGVyZWRJZHNbY29tcG9uZW50LnByb2plY3RJZF0pICE9IG51bGwgPyBfYTIgOiBbXTtcbiAgICBpZiAoIWZpbHRlcmVkSWRzW2NvbXBvbmVudC5wcm9qZWN0SWRdLmluY2x1ZGVzKGNvbXBvbmVudC5pZCkpIHtcbiAgICAgIGZpbHRlcmVkSWRzW2NvbXBvbmVudC5wcm9qZWN0SWRdLnB1c2goY29tcG9uZW50LmlkKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1vZHVsZXM6IHtcbiAgICAgIGJyb3dzZXI6IGZvckJyb3dzZXIgPyBmaWx0ZXJlZE1vZHVsZXMgOiBbXSxcbiAgICAgIHNlcnZlcjogZm9yQnJvd3NlciA/IFtdIDogZmlsdGVyZWRNb2R1bGVzXG4gICAgfSxcbiAgICBjb21wb25lbnRzOiBmaWx0ZXJlZENvbXBvbmVudHMsXG4gICAgZ2xvYmFsR3JvdXBzOiBidW5kbGUuZ2xvYmFsR3JvdXBzLFxuICAgIHByb2plY3RzOiBidW5kbGUucHJvamVjdHMsXG4gICAgYWN0aXZlU3BsaXRzOiBidW5kbGUuYWN0aXZlU3BsaXRzLFxuICAgIGJ1bmRsZUtleTogKF9iID0gYnVuZGxlLmJ1bmRsZUtleSkgIT0gbnVsbCA/IF9iIDogbnVsbCxcbiAgICBkZWZlckNodW5rc0J5RGVmYXVsdDogYnVuZGxlLmRlZmVyQ2h1bmtzQnlEZWZhdWx0LFxuICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0OiBidW5kbGUuZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQsXG4gICAgZmlsdGVyZWRJZHNcbiAgfTtcbn1cblxuLy8gc3JjL3JlZ2lzdHJ5LnRzXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZnVuY3Rpb24gaXNNb2R1bGVCdW5kbGVQcm9taXNlU2V0KG5hbWUyKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzICYmICEhZ2xvYmFsVGhpcy5fX1BsYXNtaWNCdW5kbGVQcm9taXNlc1tuYW1lMl0gJiYgISFnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzW25hbWUyXS50aGVuO1xufVxudmFyIFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxvYWRlZE1vZHVsZXMgPSB7fTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzID0ge307XG4gICAgdGhpcy5tb2R1bGVzID0ge307XG4gIH1cbiAgcmVnaXN0ZXIobmFtZTIsIG1vZHVsZSkge1xuICAgIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXNbbmFtZTJdID0gbW9kdWxlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubG9hZGVkTW9kdWxlcykubGVuZ3RoID09PSAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMubG9hZGVkTW9kdWxlcyA9IHt9O1xuICB9XG4gIGdldFJlZ2lzdGVyZWRNb2R1bGUobmFtZTIpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkTW9kdWxlc1tuYW1lMl07XG4gIH1cbiAgaGFzTW9kdWxlKG5hbWUyLCBvcHRzMiA9IHt9KSB7XG4gICAgaWYgKG5hbWUyIGluIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMgJiYgIW9wdHMyLmZvcmNlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobmFtZTIgaW4gdGhpcy5tb2R1bGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LUyAmJiAhIWdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LU1tuYW1lMl0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNNb2R1bGVCdW5kbGVQcm9taXNlU2V0KG5hbWUyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkKG5hbWUsIG9wdHMgPSB7fSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMgJiYgIW9wdHMuZm9yY2VPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXNbbmFtZV07XG4gICAgfVxuICAgIGlmIChuYW1lIGluIHRoaXMubG9hZGVkTW9kdWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZGVkTW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1vZHVsZXNbbmFtZV0gJiYgZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTICYmICEhZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTW25hbWVdKSB7XG4gICAgICB0aGlzLm1vZHVsZXNbbmFtZV0gPSBnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1NbbmFtZV07XG4gICAgfVxuICAgIGlmICghdGhpcy5tb2R1bGVzW25hbWVdICYmIGlzTW9kdWxlQnVuZGxlUHJvbWlzZVNldChuYW1lKSkge1xuICAgICAgdGhyb3cgZ2xvYmFsVGhpcy5fX1BsYXNtaWNCdW5kbGVQcm9taXNlc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLm1vZHVsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbW9kdWxlICR7bmFtZX1gKTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHRoaXMubW9kdWxlc1tuYW1lXTtcbiAgICBjb25zdCByZXF1aXJlRm4gPSBpc0Jyb3dzZXIgPyAoZGVwMikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZERlcCA9IHJlc29sdmVQYXRoKGRlcDIsIG5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZChub3JtYWxpemVkRGVwKTtcbiAgICB9IDogKGRlcCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlcCA9IHJlc29sdmVQYXRoKGRlcCwgbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWQobm9ybWFsaXplZERlcCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZXZhbChcInJlcXVpcmVcIikoZGVwKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGZ1bmM7XG4gICAgdHJ5IHtcbiAgICAgIGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBjb2RlKTtcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBMQVNNSUM6IEZhaWxlZCB0byBjcmVhdGUgZnVuY3Rpb24gZm9yICR7bmFtZX06ICR7ZXJyMn1gKTtcbiAgICB9XG4gICAgY29uc3QgZXhwb3J0cyA9IHt9O1xuICAgIHRoaXMubG9hZGVkTW9kdWxlc1tuYW1lXSA9IGV4cG9ydHM7XG4gICAgdHJ5IHtcbiAgICAgIGZ1bmMocmVxdWlyZUZuLCBleHBvcnRzKTtcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkZWRNb2R1bGVzW25hbWVdO1xuICAgICAgaWYgKCEoZXJyMiBpbnN0YW5jZW9mIEVycm9yKSAmJiAhIWVycjIgJiYgISFlcnIyLnRoZW4pIHtcbiAgICAgICAgdGhyb3cgZXJyMjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgUExBU01JQzogRmFpbGVkIHRvIGxvYWQgJHtuYW1lfTogJHtlcnIyfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuICB1cGRhdGVNb2R1bGVzKGJ1bmRsZSkge1xuICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtb2Qgb2YgaXNCcm93c2VyID8gYnVuZGxlLm1vZHVsZXMuYnJvd3NlciA6IGJ1bmRsZS5tb2R1bGVzLnNlcnZlcikge1xuICAgICAgaWYgKG1vZC50eXBlID09PSBcImNvZGVcIiAmJiAhIW1vZC5jb2RlICYmIG1vZC5jb2RlICE9PSB0aGlzLm1vZHVsZXNbbW9kLmZpbGVOYW1lXSkge1xuICAgICAgICB0aGlzLm1vZHVsZXNbbW9kLmZpbGVOYW1lXSA9IG1vZC5jb2RlO1xuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LUykge1xuICAgICAgICAgIGdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LUyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LU1ttb2QuZmlsZU5hbWVdID0gbW9kLmNvZGU7XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHBhdGgsIGZyb20pIHtcbiAgY29uc3QgZnJvbVBhcnRzID0gZnJvbS5zcGxpdChcIi9cIik7XG4gIGNvbnN0IHBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAocGF0aFBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGlmIChwYXRoUGFydHNbMF0gPT09IFwiLlwiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmZyb21QYXJ0cy5zbGljZSgwLCBmcm9tUGFydHMubGVuZ3RoIC0gMSksXG4gICAgICAuLi5wYXRoUGFydHMuc2xpY2UoMSlcbiAgICBdLmpvaW4oXCIvXCIpO1xuICB9IGVsc2UgaWYgKHBhdGhQYXJ0c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aFBhcnRzKSB7XG4gICAgICBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmZyb21QYXJ0cy5zbGljZSgwLCBmcm9tUGFydHMubGVuZ3RoIC0gY291bnQgLSAxKSxcbiAgICAgIC4uLnBhdGhQYXJ0cy5zbGljZShjb3VudClcbiAgICBdLmpvaW4oXCIvXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG5cbi8vIHNyYy90cmFja2VyL2luZGV4LnRzXG5pbXBvcnQgdW5mZXRjaCBmcm9tIFwiQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoXCI7XG5cbi8vIHNyYy90cmFja2VyL3V0aWxzLnRzXG52YXIgaXNCcm93c2VyMiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmZ1bmN0aW9uIGdldFBsYXNtaWNDb29raWVWYWx1ZXMoKSB7XG4gIGlmICghaXNCcm93c2VyMikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjsgXCIpLmZpbHRlcigoY29va2llKSA9PiBjb29raWUuaW5jbHVkZXMoXCJwbGFzbWljOlwiKSkubWFwKChjb29raWUpID0+IGNvb2tpZS5zcGxpdChcIj1cIikpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LnNwbGl0KFwiOlwiKVsxXSwgdmFsdWVdKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uQ29va2llVmFsdWVzKCkge1xuICBjb25zdCBjb29raWVzID0gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5rZXlzKGNvb2tpZXMpLm1hcCgoa2V5KSA9PiBba2V5LnNwbGl0KFwiLlwiKVsxXSwgY29va2llc1trZXldXSkuZmlsdGVyKCh2YWwpID0+ICEhdmFsWzBdKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0RGlzdGluY3RJZCgpIHtcbiAgaWYgKCFpc0Jyb3dzZXIyKSB7XG4gICAgcmV0dXJuIFwiTE9BREVSLVNFUlZFUlwiO1xuICB9XG4gIHJldHVybiBcIkxPQURFUi1DTElFTlRcIjtcbn1cbmZ1bmN0aW9uIGdldENhbXBhaWduUGFyYW1zKCkge1xuICBjb25zdCB7IGxvY2F0aW9uIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobG9jYXRpb24uaHJlZik7XG4gICAgY29uc3QgQ0FNUEFJR05fS0VZV09SRFMgPSBbXG4gICAgICBcInV0bV9zb3VyY2VcIixcbiAgICAgIFwidXRtX21lZGl1bVwiLFxuICAgICAgXCJ1dG1fY2FtcGFpZ25cIixcbiAgICAgIFwidXRtX2NvbnRlbnRcIixcbiAgICAgIFwidXRtX3Rlcm1cIixcbiAgICAgIFwiZ2NsaWRcIlxuICAgIF07XG4gICAgQ0FNUEFJR05fS0VZV09SRFMuZm9yRWFjaCgoa2V5d29yZCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXl3b3JkKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJhbXNba2V5d29yZF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyMikge1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk1ldGEoKSB7XG4gIGNvbnN0IHsgbG9jYXRpb24gfSA9IHdpbmRvdztcbiAgY29uc3QgeyByZWZlcnJlciB9ID0gZG9jdW1lbnQ7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgIGhvc3Q6IGxvY2F0aW9uLmhvc3QsXG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgIHJlZmVycmVyXG4gIH0sIGdldENhbXBhaWduUGFyYW1zKCkpO1xufVxuZnVuY3Rpb24gZ2V0U2NyZWVuTWV0YSgpIHtcbiAgY29uc3QgeyBzY3JlZW4gfSA9IHdpbmRvdztcbiAgcmV0dXJuIHtcbiAgICBzY3JlZW5faGVpZ2h0OiBzY3JlZW4uaGVpZ2h0LFxuICAgIHNjcmVlbl93aWR0aDogc2NyZWVuLndpZHRoLFxuICAgIHZpZXdwb3J0X2hlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgIHZpZXdwb3J0X3dpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T1ModXNlckFnZW50KSB7XG4gIGlmICgvV2luZG93cy9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmICgvUGhvbmUvLnRlc3QodXNlckFnZW50KSB8fCAvV1BEZXNrdG9wLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgIHJldHVybiBcIldpbmRvd3MgUGhvbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiV2luZG93c1wiO1xuICB9IGVsc2UgaWYgKC8oaVBob25lfGlQYWR8aVBvZCkvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcImlPU1wiO1xuICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJBbmRyb2lkXCI7XG4gIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiQmxhY2tCZXJyeVwiO1xuICB9IGVsc2UgaWYgKC9NYWMvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJNYWMgT1MgWFwiO1xuICB9IGVsc2UgaWYgKC9MaW51eC8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiTGludXhcIjtcbiAgfSBlbHNlIGlmICgvQ3JPUy8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiQ2hyb21lIE9TXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERldmljZUluZm8odXNlckFnZW50KSB7XG4gIGNvbnN0IFBBVFRFUk5TID0gW1xuICAgIHtcbiAgICAgIGRldmljZTogXCJpUGhvbmVcIixcbiAgICAgIHBhdHRlcm5zOiBbL2lQaG9uZS9dXG4gICAgfSxcbiAgICB7XG4gICAgICBkZXZpY2U6IFwiaVBhZFwiLFxuICAgICAgcGF0dGVybnM6IFsvaVBhZC9dXG4gICAgfSxcbiAgICB7XG4gICAgICBkZXZpY2U6IFwiaVBvZCBUb3VjaFwiLFxuICAgICAgcGF0dGVybnM6IFsvaVBvZC9dXG4gICAgfSxcbiAgICB7XG4gICAgICBkZXZpY2U6IFwiV2luZG93cyBQaG9uZVwiLFxuICAgICAgcGF0dGVybnM6IFsvV2luZG93cyBQaG9uZS9pLCAvV1BEZXNrdG9wL11cbiAgICB9LFxuICAgIHtcbiAgICAgIGRldmljZTogXCJBbmRyb2lkXCIsXG4gICAgICBwYXR0ZXJuczogWy9BbmRyb2lkL11cbiAgICB9XG4gIF07XG4gIGNvbnN0IG1hdGNoID0gUEFUVEVSTlMuZmluZChcbiAgICAocGF0dGVybikgPT4gcGF0dGVybi5wYXR0ZXJucy5zb21lKChleHByKSA9PiBleHByLnRlc3QodXNlckFnZW50KSlcbiAgKTtcbiAgY29uc3QgZGV2aWNlID0gbWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoLmRldmljZTtcbiAgcmV0dXJuIHtcbiAgICBkZXZpY2U6IGRldmljZSAhPSBudWxsID8gZGV2aWNlIDogXCJcIixcbiAgICBkZXZpY2VUeXBlOiBkZXZpY2UgPyBcIk1vYmlsZVwiIDogXCJEZXNrdG9wXCIsXG4gICAgb3M6IGdldE9TKHVzZXJBZ2VudClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudE1ldGEoKSB7XG4gIGNvbnN0IHsgbmF2aWdhdG9yIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHsgdXNlckFnZW50IH0gPSBuYXZpZ2F0b3I7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0RGV2aWNlSW5mbyh1c2VyQWdlbnQpKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd01ldGEoKSB7XG4gIGlmICghaXNCcm93c2VyMikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldExvY2F0aW9uTWV0YSgpKSwgZ2V0U2NyZWVuTWV0YSgpKSwgZ2V0VXNlckFnZW50TWV0YSgpKTtcbn1cbnZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG5mdW5jdGlvbiBnZXRFbnZNZXRhKCkge1xuICByZXR1cm4ge1xuICAgIGlzQnJvd3NlcjogaXNCcm93c2VyMixcbiAgICBpc1Byb2R1Y3Rpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIHJhd1NwbGl0VmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBjb25zdCByYXdWYXJpYXRpb25zID0ge307XG4gIE9iamVjdC5rZXlzKHZhcmlhdGlvbikuZm9yRWFjaCgodmFyaWF0aW9uS2V5KSA9PiB7XG4gICAgY29uc3QgWywgc3BsaXRJZF0gPSB2YXJpYXRpb25LZXkuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChzcGxpdElkKSB7XG4gICAgICByYXdWYXJpYXRpb25zW3NwbGl0SWRdID0gdmFyaWF0aW9uW3ZhcmlhdGlvbktleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJhd1ZhcmlhdGlvbnM7XG59XG52YXIgUE9MTF9USU1FID0gNWUzO1xuZnVuY3Rpb24gdGhyb3R0bGVkKGZ1bmMyKSB7XG4gIGxldCB0aW1lcklkID0gdm9pZCAwO1xuICByZXR1cm4gKHBhcmFtKSA9PiB7XG4gICAgaWYgKHRpbWVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGltZXJJZCA9IHZvaWQgMDtcbiAgICAgICAgZnVuYzIocGFyYW0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZXJJZCA9IHZvaWQgMDtcbiAgICAgICAgZnVuYzIocGFyYW0pO1xuICAgICAgfSwgUE9MTF9USU1FKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFja2VyL2luZGV4LnRzXG52YXIgQVBJX0VORFBPSU5UID0gXCJodHRwczovL2FuYWx5dGljcy5wbGFzbWljLmFwcC9jYXB0dXJlXCI7XG52YXIgQVBJX1BVQkxJQ19LRVkgPSBcInBoY19CUnZZVEFvTW9hbTlmREhmckluZUY2N0tkdE1KYWdMVlZDTTZFTE5ZZDRuXCI7XG52YXIgVFJBQ0tFUl9WRVJTSU9OID0gNDtcbnZhciBQbGFzbWljVHJhY2tlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0czIpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzMjtcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLnNlbmRFdmVudHMgPSB0aHJvdHRsZWQoKHRyYW5zcG9ydCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnRzID0gWy4uLnRoaXMuZXZlbnRRdWV1ZV07XG4gICAgICB0aGlzLmV2ZW50UXVldWUubGVuZ3RoID0gMDtcbiAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgIGFwaV9rZXk6IEFQSV9QVUJMSUNfS0VZLFxuICAgICAgICBiYXRjaDogZXZlbnRzXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaW5nQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBcImJlYWNvblwiKSB7XG4gICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5zZW5kQmVhY29uKEFQSV9FTkRQT0lOVCwgc3RyaW5nQm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mZXRjaChBUElfRU5EUE9JTlQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBzdHJpbmdCb2R5XG4gICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHRoaXMuZmV0Y2ggPSAob3B0czIubmF0aXZlRmV0Y2ggJiYgZ2xvYmFsVGhpcy5mZXRjaCA/IGdsb2JhbFRoaXMuZmV0Y2ggOiB1bmZldGNoKS5iaW5kKGdsb2JhbFRoaXMpO1xuICB9XG4gIHRyYWNrUmVuZGVyKG9wdHMyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0aGlzLmVucXVldWUoe1xuICAgICAgZXZlbnQ6IFwiJHJlbmRlclwiLFxuICAgICAgcHJvcGVydGllczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0UHJvcGVydGllcygpKSwgKF9hID0gb3B0czIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMyLnJlbmRlckN0eCkgIT0gbnVsbCA/IF9hIDoge30pLCByYXdTcGxpdFZhcmlhdGlvbigoX2IgPSBvcHRzMiA9PSBudWxsID8gdm9pZCAwIDogb3B0czIudmFyaWF0aW9uKSAhPSBudWxsID8gX2IgOiB7fSkpXG4gICAgfSk7XG4gIH1cbiAgdHJhY2tGZXRjaCgpIHtcbiAgICB0aGlzLmVucXVldWUoe1xuICAgICAgZXZlbnQ6IFwiJGZldGNoXCIsXG4gICAgICBwcm9wZXJ0aWVzOiB0aGlzLmdldFByb3BlcnRpZXMoKVxuICAgIH0pO1xuICB9XG4gIHRyYWNrQ29udmVyc2lvbih2YWx1ZSA9IDApIHtcbiAgICB0aGlzLmVucXVldWUoe1xuICAgICAgZXZlbnQ6IFwiJGNvbnZlcnNpb25cIixcbiAgICAgIHByb3BlcnRpZXM6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0UHJvcGVydGllcygpKSwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBnZXRQcm9wZXJ0aWVzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBkaXN0aW5jdF9pZDogZ2V0RGlzdGluY3RJZCgpXG4gICAgfSwgZ2V0V2luZG93TWV0YSgpKSwgZ2V0RW52TWV0YSgpKSwgdGhpcy5nZXRDb250ZXh0TWV0YSgpKSwgZ2V0VmFyaWF0aW9uQ29va2llVmFsdWVzKCkpLCB7XG4gICAgICB0aW1lc3RhbXA6IChfYSA9IERhdGUubm93KCkpICE9IG51bGwgPyBfYSA6ICsvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIHRyYWNrZXJWZXJzaW9uOiBUUkFDS0VSX1ZFUlNJT05cbiAgICB9KTtcbiAgfVxuICBlbnF1ZXVlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub3B0cy5fX3BsYXNtaWNUcmFja2VyRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xuICAgIHRoaXMuc2VuZEV2ZW50cyhcImZldGNoXCIpO1xuICB9XG4gIGdldENvbnRleHRNZXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwbGF0Zm9ybTogdGhpcy5vcHRzLnBsYXRmb3JtLFxuICAgICAgcHJldmlldzogdGhpcy5vcHRzLnByZXZpZXcsXG4gICAgICBwcm9qZWN0SWRzOiB0aGlzLm9wdHMucHJvamVjdElkc1xuICAgIH07XG4gIH1cbn07XG5leHBvcnQge1xuICBBcGksXG4gIFBsYXNtaWNNb2R1bGVzRmV0Y2hlcixcbiAgUGxhc21pY1RyYWNrZXIsXG4gIFJlZ2lzdHJ5LFxuICBnZXRCdW5kbGVTdWJzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* binding */ Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* binding */ PlasmicModulesFetcher),\n/* harmony export */   internal_getCachedBundleInNodeServer: () => (/* binding */ internal_getCachedBundleInNodeServer)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(pages-dir-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/api.ts\n\nvar VERSION = \"10\";\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction transformApiLoaderBundleOutput(bundle) {\n  return __spreadProps(__spreadValues({}, bundle), {\n    filteredIds: Object.fromEntries(bundle.projects.map((p) => [p.id, []]))\n  });\n}\nvar Api = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.lastResponse = void 0;\n    var _a;\n    this.host = (_a = opts.host) != null ? _a : \"https://codegen.plasmic.app\";\n    this.fetch = (opts.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default())).bind(globalThis);\n  }\n  fetchLoaderData(projectIds, opts) {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n      const { platform, preview } = opts;\n      const query = new URLSearchParams([\n        [\"platform\", platform != null ? platform : \"react\"],\n        ...((_b = (_a = opts.platformOptions) == null ? void 0 : _a.nextjs) == null ? void 0 : _b.appDir) ? [[\"nextjsAppDir\", \"true\"]] : [],\n        ...projectIds.map((projectId) => [\"projectId\", projectId]),\n        ...opts.browserOnly ? [[\"browserOnly\", \"true\"]] : [],\n        ...opts.i18nKeyScheme ? [[\"i18nKeyScheme\", opts.i18nKeyScheme]] : [],\n        ...opts.i18nTagPrefix ? [[\"i18nTagPrefix\", opts.i18nTagPrefix]] : [],\n        ...opts.skipHead ? [[\"skipHead\", \"true\"]] : []\n      ]).toString();\n      const url = `${this.host}/api/v1/loader/code/${preview ? \"preview\" : \"published\"}?${query}`;\n      const useLastReponse = (\n        // We consider that manualRedirect is true by default, only by setting it to false\n        // we disable it.\n        !(this.opts.manualRedirect === false) && !preview && !isBrowser\n      );\n      if (useLastReponse) {\n        const redirectResp = yield this.fetch(url, {\n          method: \"GET\",\n          headers: this.makeGetHeaders(),\n          redirect: \"manual\"\n        });\n        if (redirectResp.status !== 301 && redirectResp.status !== 302) {\n          const error = yield this.parseJsonResponse(redirectResp);\n          throw new Error(\n            `Error fetching loader data, a redirect was expected: ${(_d = (_c = error == null ? void 0 : error.error) == null ? void 0 : _c.message) != null ? _d : redirectResp.statusText}`\n          );\n        }\n        const nextLocation = redirectResp.headers.get(\"location\");\n        if (!nextLocation) {\n          throw new Error(\n            `Error fetching loader data, a redirect was expected but no location header was found`\n          );\n        }\n        if (((_e = this.lastResponse) == null ? void 0 : _e.key) === nextLocation) {\n          return this.lastResponse.bundle;\n        }\n        const resp2 = yield this.fetch(`${this.host}${nextLocation}`, {\n          method: \"GET\",\n          headers: this.makeGetHeaders()\n        });\n        if (resp2.status >= 400) {\n          const error = yield this.parseJsonResponse(resp2);\n          throw new Error(\n            `Error fetching loader data: ${(_g = (_f = error == null ? void 0 : error.error) == null ? void 0 : _f.message) != null ? _g : resp2.statusText}`\n          );\n        }\n        const json2 = transformApiLoaderBundleOutput(\n          yield this.parseJsonResponse(resp2)\n        );\n        this.lastResponse = {\n          bundle: json2,\n          key: nextLocation\n        };\n        return json2;\n      }\n      const resp = yield this.fetch(url, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      if (resp.status >= 400) {\n        const error = yield this.parseJsonResponse(resp);\n        throw new Error(\n          `Error fetching loader data: ${(_i = (_h = error == null ? void 0 : error.error) == null ? void 0 : _h.message) != null ? _i : resp.statusText}`\n        );\n      }\n      const json = yield this.parseJsonResponse(resp);\n      return transformApiLoaderBundleOutput(json);\n    });\n  }\n  parseJsonResponse(resp) {\n    return __async(this, null, function* () {\n      const text = yield resp.text();\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        throw new Error(\n          `Error parsing JSON response: ${err}; status: ${resp.status}; response: ${text}`\n        );\n      }\n    });\n  }\n  fetchHtmlData(opts) {\n    return __async(this, null, function* () {\n      const { projectId, component, embedHydrate, hydrate } = opts;\n      const query = new URLSearchParams([\n        [\"projectId\", projectId],\n        [\"component\", component],\n        [\"embedHydrate\", embedHydrate ? \"1\" : \"0\"],\n        [\"hydrate\", hydrate ? \"1\" : \"0\"]\n      ]).toString();\n      const resp = yield this.fetch(`${this.host}/api/v1/loader/html?${query}`, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      const json = yield resp.json();\n      return json;\n    });\n  }\n  makeGetHeaders() {\n    return __spreadValues({\n      \"x-plasmic-loader-version\": VERSION\n    }, this.makeAuthHeaders());\n  }\n  makeAuthHeaders() {\n    const tokens = this.opts.projects.map((p) => `${p.id}:${p.token}`).join(\",\");\n    return {\n      \"x-plasmic-api-project-tokens\": tokens\n    };\n  }\n  getChunksUrl(bundle, modules) {\n    var _a;\n    return `${this.host}/api/v1/loader/chunks?bundleKey=${encodeURIComponent(\n      (_a = bundle.bundleKey) != null ? _a : \"null\"\n    )}&fileName=${encodeURIComponent(\n      modules.map((m) => m.fileName).sort().join(\",\")\n    )}`;\n  }\n};\n\n// src/fetcher.ts\nvar PlasmicModulesFetcher = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.curFetch = void 0;\n    this.api = new Api({\n      projects: opts.projects,\n      host: opts.host,\n      nativeFetch: opts.nativeFetch,\n      manualRedirect: opts.manualRedirect\n    });\n  }\n  getChunksUrl(bundle, modules) {\n    return this.api.getChunksUrl(bundle, modules);\n  }\n  fetchAllData() {\n    return __async(this, null, function* () {\n      const bundle = yield this.getCachedOrFetch();\n      this.cacheBundleInNodeServer(bundle);\n      return bundle;\n    });\n  }\n  getCachedOrFetch() {\n    return __async(this, null, function* () {\n      var _a;\n      if (this.opts.cache) {\n        const cachedData = yield this.opts.cache.get();\n        if (cachedData) {\n          return cachedData;\n        }\n      }\n      if (this.curFetch) {\n        return yield this.curFetch;\n      }\n      if (typeof process === \"undefined\" || !((_a = process.env) == null ? void 0 : _a.PLASMIC_QUIET)) {\n        console.debug(\"Plasmic: doing a fresh fetch...\");\n      }\n      const fetchPromise = this.doFetch();\n      this.curFetch = fetchPromise;\n      try {\n        const data = yield fetchPromise;\n        return data;\n      } finally {\n        if (this.curFetch === fetchPromise) {\n          this.curFetch = void 0;\n        }\n      }\n    });\n  }\n  doFetch() {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d;\n      const data = yield this.api.fetchLoaderData(\n        this.opts.projects.map(\n          (p) => p.version ? `${p.id}@${p.version}` : p.id\n        ),\n        {\n          platform: this.opts.platform,\n          platformOptions: this.opts.platformOptions,\n          preview: this.opts.preview,\n          i18nKeyScheme: (_b = (_a = this.opts.i18n) == null ? void 0 : _a.keyScheme) != null ? _b : this.opts.i18nKeyScheme,\n          i18nTagPrefix: (_c = this.opts.i18n) == null ? void 0 : _c.tagPrefix,\n          browserOnly: isBrowser,\n          skipHead: this.opts.skipHead\n        }\n      );\n      if (this.opts.cache) {\n        yield this.opts.cache.set(data);\n      }\n      if (typeof process === \"undefined\" || !((_d = process.env) == null ? void 0 : _d.PLASMIC_QUIET)) {\n        console.debug(\n          `Plasmic: fetched designs for ${data.projects.map((p) => `\"${p.name}\" (${p.id}@${p.version})`).join(\", \")}`\n        );\n      }\n      return data;\n    });\n  }\n  cacheBundleInNodeServer(bundle) {\n    if (isBrowser) {\n      return;\n    }\n    const global = globalThis;\n    if (global.__PLASMIC_BUNDLES === void 0) {\n      global.__PLASMIC_BUNDLES = {};\n    }\n    global.__PLASMIC_BUNDLES[getBundleKey(this.opts)] = bundle;\n  }\n};\nfunction internal_getCachedBundleInNodeServer(opts) {\n  var _a;\n  if (isBrowser) {\n    throw new Error(`Should not be consulting Node server cache in browser`);\n  }\n  const global = globalThis;\n  return (_a = global.__PLASMIC_BUNDLES) == null ? void 0 : _a[getBundleKey(opts)];\n}\nfunction getBundleKey({\n  host,\n  platform,\n  i18nKeyScheme,\n  preview,\n  projects,\n  skipHead\n}) {\n  return JSON.stringify({\n    host,\n    platform,\n    i18nKeyScheme,\n    preview,\n    projects,\n    skipHead\n  });\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlci9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsdUVBQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxzQkFBc0Isa0NBQWtDLEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usd0hBQXdIO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLGFBQWE7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUhBQWlIO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdIQUFnSDtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsTUFBTSxVQUFVLGNBQWMsWUFBWSxLQUFLO0FBQ3pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsc0JBQXNCLE1BQU07QUFDN0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxHQUFHLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLGtDQUFrQztBQUMxRDtBQUNBLE1BQU0sWUFBWTtBQUNsQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLEdBQUcsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSwwQ0FBMEMsNkJBQTZCLE9BQU8sS0FBSyxLQUFLLEdBQUcsVUFBVSxlQUFlO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFLRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXEBwbGFzbWljYXBwXFxsb2FkZXItZmV0Y2hlclxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2FwaS50c1xuaW1wb3J0IHVuZmV0Y2ggZnJvbSBcIkBwbGFzbWljYXBwL2lzb21vcnBoaWMtdW5mZXRjaFwiO1xudmFyIFZFUlNJT04gPSBcIjEwXCI7XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtQXBpTG9hZGVyQnVuZGxlT3V0cHV0KGJ1bmRsZSkge1xuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYnVuZGxlKSwge1xuICAgIGZpbHRlcmVkSWRzOiBPYmplY3QuZnJvbUVudHJpZXMoYnVuZGxlLnByb2plY3RzLm1hcCgocCkgPT4gW3AuaWQsIFtdXSkpXG4gIH0pO1xufVxudmFyIEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5sYXN0UmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuaG9zdCA9IChfYSA9IG9wdHMuaG9zdCkgIT0gbnVsbCA/IF9hIDogXCJodHRwczovL2NvZGVnZW4ucGxhc21pYy5hcHBcIjtcbiAgICB0aGlzLmZldGNoID0gKG9wdHMubmF0aXZlRmV0Y2ggJiYgZ2xvYmFsVGhpcy5mZXRjaCA/IGdsb2JhbFRoaXMuZmV0Y2ggOiB1bmZldGNoKS5iaW5kKGdsb2JhbFRoaXMpO1xuICB9XG4gIGZldGNoTG9hZGVyRGF0YShwcm9qZWN0SWRzLCBvcHRzKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xuICAgICAgY29uc3QgeyBwbGF0Zm9ybSwgcHJldmlldyB9ID0gb3B0cztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgICAgIFtcInBsYXRmb3JtXCIsIHBsYXRmb3JtICE9IG51bGwgPyBwbGF0Zm9ybSA6IFwicmVhY3RcIl0sXG4gICAgICAgIC4uLigoX2IgPSAoX2EgPSBvcHRzLnBsYXRmb3JtT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5leHRqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFwcERpcikgPyBbW1wibmV4dGpzQXBwRGlyXCIsIFwidHJ1ZVwiXV0gOiBbXSxcbiAgICAgICAgLi4ucHJvamVjdElkcy5tYXAoKHByb2plY3RJZCkgPT4gW1wicHJvamVjdElkXCIsIHByb2plY3RJZF0pLFxuICAgICAgICAuLi5vcHRzLmJyb3dzZXJPbmx5ID8gW1tcImJyb3dzZXJPbmx5XCIsIFwidHJ1ZVwiXV0gOiBbXSxcbiAgICAgICAgLi4ub3B0cy5pMThuS2V5U2NoZW1lID8gW1tcImkxOG5LZXlTY2hlbWVcIiwgb3B0cy5pMThuS2V5U2NoZW1lXV0gOiBbXSxcbiAgICAgICAgLi4ub3B0cy5pMThuVGFnUHJlZml4ID8gW1tcImkxOG5UYWdQcmVmaXhcIiwgb3B0cy5pMThuVGFnUHJlZml4XV0gOiBbXSxcbiAgICAgICAgLi4ub3B0cy5za2lwSGVhZCA/IFtbXCJza2lwSGVhZFwiLCBcInRydWVcIl1dIDogW11cbiAgICAgIF0pLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmhvc3R9L2FwaS92MS9sb2FkZXIvY29kZS8ke3ByZXZpZXcgPyBcInByZXZpZXdcIiA6IFwicHVibGlzaGVkXCJ9PyR7cXVlcnl9YDtcbiAgICAgIGNvbnN0IHVzZUxhc3RSZXBvbnNlID0gKFxuICAgICAgICAvLyBXZSBjb25zaWRlciB0aGF0IG1hbnVhbFJlZGlyZWN0IGlzIHRydWUgYnkgZGVmYXVsdCwgb25seSBieSBzZXR0aW5nIGl0IHRvIGZhbHNlXG4gICAgICAgIC8vIHdlIGRpc2FibGUgaXQuXG4gICAgICAgICEodGhpcy5vcHRzLm1hbnVhbFJlZGlyZWN0ID09PSBmYWxzZSkgJiYgIXByZXZpZXcgJiYgIWlzQnJvd3NlclxuICAgICAgKTtcbiAgICAgIGlmICh1c2VMYXN0UmVwb25zZSkge1xuICAgICAgICBjb25zdCByZWRpcmVjdFJlc3AgPSB5aWVsZCB0aGlzLmZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLm1ha2VHZXRIZWFkZXJzKCksXG4gICAgICAgICAgcmVkaXJlY3Q6IFwibWFudWFsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWRpcmVjdFJlc3Auc3RhdHVzICE9PSAzMDEgJiYgcmVkaXJlY3RSZXNwLnN0YXR1cyAhPT0gMzAyKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB5aWVsZCB0aGlzLnBhcnNlSnNvblJlc3BvbnNlKHJlZGlyZWN0UmVzcCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEVycm9yIGZldGNoaW5nIGxvYWRlciBkYXRhLCBhIHJlZGlyZWN0IHdhcyBleHBlY3RlZDogJHsoX2QgPSAoX2MgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlKSAhPSBudWxsID8gX2QgOiByZWRpcmVjdFJlc3Auc3RhdHVzVGV4dH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TG9jYXRpb24gPSByZWRpcmVjdFJlc3AuaGVhZGVycy5nZXQoXCJsb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKCFuZXh0TG9jYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRXJyb3IgZmV0Y2hpbmcgbG9hZGVyIGRhdGEsIGEgcmVkaXJlY3Qgd2FzIGV4cGVjdGVkIGJ1dCBubyBsb2NhdGlvbiBoZWFkZXIgd2FzIGZvdW5kYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2UgPSB0aGlzLmxhc3RSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmtleSkgPT09IG5leHRMb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXNwb25zZS5idW5kbGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcDIgPSB5aWVsZCB0aGlzLmZldGNoKGAke3RoaXMuaG9zdH0ke25leHRMb2NhdGlvbn1gLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHRoaXMubWFrZUdldEhlYWRlcnMoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3AyLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHlpZWxkIHRoaXMucGFyc2VKc29uUmVzcG9uc2UocmVzcDIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciBmZXRjaGluZyBsb2FkZXIgZGF0YTogJHsoX2cgPSAoX2YgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfZi5tZXNzYWdlKSAhPSBudWxsID8gX2cgOiByZXNwMi5zdGF0dXNUZXh0fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb24yID0gdHJhbnNmb3JtQXBpTG9hZGVyQnVuZGxlT3V0cHV0KFxuICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VKc29uUmVzcG9uc2UocmVzcDIpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubGFzdFJlc3BvbnNlID0ge1xuICAgICAgICAgIGJ1bmRsZToganNvbjIsXG4gICAgICAgICAga2V5OiBuZXh0TG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb24yO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogdGhpcy5tYWtlR2V0SGVhZGVycygpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB5aWVsZCB0aGlzLnBhcnNlSnNvblJlc3BvbnNlKHJlc3ApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEVycm9yIGZldGNoaW5nIGxvYWRlciBkYXRhOiAkeyhfaSA9IChfaCA9IGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLm1lc3NhZ2UpICE9IG51bGwgPyBfaSA6IHJlc3Auc3RhdHVzVGV4dH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBqc29uID0geWllbGQgdGhpcy5wYXJzZUpzb25SZXNwb25zZShyZXNwKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1BcGlMb2FkZXJCdW5kbGVPdXRwdXQoanNvbik7XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VKc29uUmVzcG9uc2UocmVzcCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0ZXh0ID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEVycm9yIHBhcnNpbmcgSlNPTiByZXNwb25zZTogJHtlcnJ9OyBzdGF0dXM6ICR7cmVzcC5zdGF0dXN9OyByZXNwb25zZTogJHt0ZXh0fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaEh0bWxEYXRhKG9wdHMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIGNvbXBvbmVudCwgZW1iZWRIeWRyYXRlLCBoeWRyYXRlIH0gPSBvcHRzO1xuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAgICAgICAgW1wicHJvamVjdElkXCIsIHByb2plY3RJZF0sXG4gICAgICAgIFtcImNvbXBvbmVudFwiLCBjb21wb25lbnRdLFxuICAgICAgICBbXCJlbWJlZEh5ZHJhdGVcIiwgZW1iZWRIeWRyYXRlID8gXCIxXCIgOiBcIjBcIl0sXG4gICAgICAgIFtcImh5ZHJhdGVcIiwgaHlkcmF0ZSA/IFwiMVwiIDogXCIwXCJdXG4gICAgICBdKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIHRoaXMuZmV0Y2goYCR7dGhpcy5ob3N0fS9hcGkvdjEvbG9hZGVyL2h0bWw/JHtxdWVyeX1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogdGhpcy5tYWtlR2V0SGVhZGVycygpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXNwLmpzb24oKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG4gIG1ha2VHZXRIZWFkZXJzKCkge1xuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBcIngtcGxhc21pYy1sb2FkZXItdmVyc2lvblwiOiBWRVJTSU9OXG4gICAgfSwgdGhpcy5tYWtlQXV0aEhlYWRlcnMoKSk7XG4gIH1cbiAgbWFrZUF1dGhIZWFkZXJzKCkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMub3B0cy5wcm9qZWN0cy5tYXAoKHApID0+IGAke3AuaWR9OiR7cC50b2tlbn1gKS5qb2luKFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgXCJ4LXBsYXNtaWMtYXBpLXByb2plY3QtdG9rZW5zXCI6IHRva2Vuc1xuICAgIH07XG4gIH1cbiAgZ2V0Q2h1bmtzVXJsKGJ1bmRsZSwgbW9kdWxlcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0fS9hcGkvdjEvbG9hZGVyL2NodW5rcz9idW5kbGVLZXk9JHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAoX2EgPSBidW5kbGUuYnVuZGxlS2V5KSAhPSBudWxsID8gX2EgOiBcIm51bGxcIlxuICAgICl9JmZpbGVOYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgbW9kdWxlcy5tYXAoKG0pID0+IG0uZmlsZU5hbWUpLnNvcnQoKS5qb2luKFwiLFwiKVxuICAgICl9YDtcbiAgfVxufTtcblxuLy8gc3JjL2ZldGNoZXIudHNcbnZhciBQbGFzbWljTW9kdWxlc0ZldGNoZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY3VyRmV0Y2ggPSB2b2lkIDA7XG4gICAgdGhpcy5hcGkgPSBuZXcgQXBpKHtcbiAgICAgIHByb2plY3RzOiBvcHRzLnByb2plY3RzLFxuICAgICAgaG9zdDogb3B0cy5ob3N0LFxuICAgICAgbmF0aXZlRmV0Y2g6IG9wdHMubmF0aXZlRmV0Y2gsXG4gICAgICBtYW51YWxSZWRpcmVjdDogb3B0cy5tYW51YWxSZWRpcmVjdFxuICAgIH0pO1xuICB9XG4gIGdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpIHtcbiAgICByZXR1cm4gdGhpcy5hcGkuZ2V0Q2h1bmtzVXJsKGJ1bmRsZSwgbW9kdWxlcyk7XG4gIH1cbiAgZmV0Y2hBbGxEYXRhKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBidW5kbGUgPSB5aWVsZCB0aGlzLmdldENhY2hlZE9yRmV0Y2goKTtcbiAgICAgIHRoaXMuY2FjaGVCdW5kbGVJbk5vZGVTZXJ2ZXIoYnVuZGxlKTtcbiAgICAgIHJldHVybiBidW5kbGU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FjaGVkT3JGZXRjaCgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMub3B0cy5jYWNoZSkge1xuICAgICAgICBjb25zdCBjYWNoZWREYXRhID0geWllbGQgdGhpcy5vcHRzLmNhY2hlLmdldCgpO1xuICAgICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWREYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJGZXRjaCkge1xuICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jdXJGZXRjaDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKChfYSA9IHByb2Nlc3MuZW52KSA9PSBudWxsID8gdm9pZCAwIDogX2EuUExBU01JQ19RVUlFVCkpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlBsYXNtaWM6IGRvaW5nIGEgZnJlc2ggZmV0Y2guLi5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBmZXRjaFByb21pc2UgPSB0aGlzLmRvRmV0Y2goKTtcbiAgICAgIHRoaXMuY3VyRmV0Y2ggPSBmZXRjaFByb21pc2U7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZmV0Y2hQcm9taXNlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckZldGNoID09PSBmZXRjaFByb21pc2UpIHtcbiAgICAgICAgICB0aGlzLmN1ckZldGNoID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZG9GZXRjaCgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMuYXBpLmZldGNoTG9hZGVyRGF0YShcbiAgICAgICAgdGhpcy5vcHRzLnByb2plY3RzLm1hcChcbiAgICAgICAgICAocCkgPT4gcC52ZXJzaW9uID8gYCR7cC5pZH1AJHtwLnZlcnNpb259YCA6IHAuaWRcbiAgICAgICAgKSxcbiAgICAgICAge1xuICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLm9wdHMucGxhdGZvcm0sXG4gICAgICAgICAgcGxhdGZvcm1PcHRpb25zOiB0aGlzLm9wdHMucGxhdGZvcm1PcHRpb25zLFxuICAgICAgICAgIHByZXZpZXc6IHRoaXMub3B0cy5wcmV2aWV3LFxuICAgICAgICAgIGkxOG5LZXlTY2hlbWU6IChfYiA9IChfYSA9IHRoaXMub3B0cy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogX2Eua2V5U2NoZW1lKSAhPSBudWxsID8gX2IgOiB0aGlzLm9wdHMuaTE4bktleVNjaGVtZSxcbiAgICAgICAgICBpMThuVGFnUHJlZml4OiAoX2MgPSB0aGlzLm9wdHMuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRhZ1ByZWZpeCxcbiAgICAgICAgICBicm93c2VyT25seTogaXNCcm93c2VyLFxuICAgICAgICAgIHNraXBIZWFkOiB0aGlzLm9wdHMuc2tpcEhlYWRcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLm9wdHMuY2FjaGUpIHtcbiAgICAgICAgeWllbGQgdGhpcy5vcHRzLmNhY2hlLnNldChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKChfZCA9IHByb2Nlc3MuZW52KSA9PSBudWxsID8gdm9pZCAwIDogX2QuUExBU01JQ19RVUlFVCkpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBgUGxhc21pYzogZmV0Y2hlZCBkZXNpZ25zIGZvciAke2RhdGEucHJvamVjdHMubWFwKChwKSA9PiBgXCIke3AubmFtZX1cIiAoJHtwLmlkfUAke3AudmVyc2lvbn0pYCkuam9pbihcIiwgXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xuICB9XG4gIGNhY2hlQnVuZGxlSW5Ob2RlU2VydmVyKGJ1bmRsZSkge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoZ2xvYmFsLl9fUExBU01JQ19CVU5ETEVTID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbC5fX1BMQVNNSUNfQlVORExFUyA9IHt9O1xuICAgIH1cbiAgICBnbG9iYWwuX19QTEFTTUlDX0JVTkRMRVNbZ2V0QnVuZGxlS2V5KHRoaXMub3B0cyldID0gYnVuZGxlO1xuICB9XG59O1xuZnVuY3Rpb24gaW50ZXJuYWxfZ2V0Q2FjaGVkQnVuZGxlSW5Ob2RlU2VydmVyKG9wdHMpIHtcbiAgdmFyIF9hO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaG91bGQgbm90IGJlIGNvbnN1bHRpbmcgTm9kZSBzZXJ2ZXIgY2FjaGUgaW4gYnJvd3NlcmApO1xuICB9XG4gIGNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG4gIHJldHVybiAoX2EgPSBnbG9iYWwuX19QTEFTTUlDX0JVTkRMRVMpID09IG51bGwgPyB2b2lkIDAgOiBfYVtnZXRCdW5kbGVLZXkob3B0cyldO1xufVxuZnVuY3Rpb24gZ2V0QnVuZGxlS2V5KHtcbiAgaG9zdCxcbiAgcGxhdGZvcm0sXG4gIGkxOG5LZXlTY2hlbWUsXG4gIHByZXZpZXcsXG4gIHByb2plY3RzLFxuICBza2lwSGVhZFxufSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGhvc3QsXG4gICAgcGxhdGZvcm0sXG4gICAgaTE4bktleVNjaGVtZSxcbiAgICBwcmV2aWV3LFxuICAgIHByb2plY3RzLFxuICAgIHNraXBIZWFkXG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgQXBpLFxuICBQbGFzbWljTW9kdWxlc0ZldGNoZXIsXG4gIGludGVybmFsX2dldENhY2hlZEJ1bmRsZUluTm9kZVNlcnZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/loader-nextjs/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-nextjs/dist/index.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataCtxReader: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.DataCtxReader),\n/* harmony export */   DataProvider: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.GlobalActionsProvider),\n/* harmony export */   NextJsPlasmicComponentLoader: () => (/* binding */ NextJsPlasmicComponentLoader),\n/* harmony export */   PageParamsProvider: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicCanvasHost),\n/* harmony export */   PlasmicComponent: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicComponent),\n/* harmony export */   PlasmicRootProvider: () => (/* binding */ PlasmicRootProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicTranslatorContext),\n/* harmony export */   __EXPERMIENTAL__ExtractPlasmicQueryData: () => (/* reexport safe */ _plasmicapp_nextjs_app_router__WEBPACK_IMPORTED_MODULE_1__.ExtractPlasmicQueryData),\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   initPlasmicLoader: () => (/* binding */ initPlasmicLoader),\n/* harmony export */   plasmicPrepass: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.plasmicPrepass),\n/* harmony export */   repeatedElement: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.repeatedElement),\n/* harmony export */   useDataEnv: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.useDataEnv),\n/* harmony export */   usePlasmicCanvasComponentInfo: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.usePlasmicCanvasComponentInfo),\n/* harmony export */   usePlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.usePlasmicCanvasContext),\n/* harmony export */   usePlasmicComponent: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.usePlasmicComponent),\n/* harmony export */   usePlasmicQueryData: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.usePlasmicQueryData),\n/* harmony export */   useSelector: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.useSelector),\n/* harmony export */   useSelectors: () => (/* reexport safe */ _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-react */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_nextjs_app_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/nextjs-app-router */ \"(pages-dir-browser)/./node_modules/@plasmicapp/nextjs-app-router/dist/index.esm.js\");\n/* harmony import */ var next_head_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head.js */ \"(pages-dir-browser)/./node_modules/next/head.js\");\n/* harmony import */ var next_head_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_link_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link.js */ \"(pages-dir-browser)/./node_modules/next/link.js\");\n/* harmony import */ var next_link_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_router_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/router.js */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_router_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/script */ \"(pages-dir-browser)/./node_modules/next/script.js\");\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_script__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/constants */ \"(pages-dir-browser)/./node_modules/next/constants.js\");\n/* harmony import */ var next_constants__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_constants__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! path */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_8__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\"use client\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __reflectGet = Reflect.get;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.tsx\n\n\n\n\n\n\n\n\n\n// src/cache.ts\n\n\n\n// src/server-require.ts\nvar secretRequire;\ntry {\n  secretRequire = eval(\"require\");\n} catch (err) {\n  try {\n    secretRequire = eval(\"(module) => import(module)\");\n  } catch (err2) {\n    secretRequire = void 0;\n  }\n}\nfunction serverRequire(module) {\n  return __async(this, null, function* () {\n    if (!secretRequire) {\n      throw new Error(\n        `Unexpected serverRequire() -- can only do this from a Node server!`\n      );\n    }\n    return secretRequire(module);\n  });\n}\nfunction tryServerRequire(module) {\n  return __async(this, null, function* () {\n    try {\n      const require2 = yield serverRequire(module);\n      return require2;\n    } catch (e) {\n      return void 0;\n    }\n  });\n}\nfunction tryServerRequires(modules) {\n  return __async(this, null, function* () {\n    for (const module of modules) {\n      const require2 = yield tryServerRequire(module);\n      if (require2 != null) {\n        return require2;\n      }\n    }\n    return void 0;\n  });\n}\nfunction serverRequireFs() {\n  return __async(this, null, function* () {\n    return serverRequire(\"fs\");\n  });\n}\n\n// src/cache.ts\nvar FileCache = class {\n  constructor(filePath) {\n    this.filePath = filePath;\n  }\n  get() {\n    return __async(this, null, function* () {\n      const fs = yield serverRequireFs();\n      try {\n        yield fs.promises.mkdir(path__WEBPACK_IMPORTED_MODULE_8___default().dirname(this.filePath), { recursive: true });\n        const data = (yield fs.promises.readFile(this.filePath)).toString();\n        return JSON.parse(data);\n      } catch (e) {\n        return void 0;\n      }\n    });\n  }\n  set(data) {\n    return __async(this, null, function* () {\n      const fs = yield serverRequireFs();\n      try {\n        yield fs.promises.writeFile(this.filePath, JSON.stringify(data));\n      } catch (err2) {\n        console.warn(`Error writing to Plasmic cache: ${err2}`);\n      }\n    });\n  }\n  clear() {\n    return __async(this, null, function* () {\n      const fs = yield serverRequireFs();\n      try {\n        yield fs.promises.unlink(this.filePath);\n      } catch (err2) {\n      }\n    });\n  }\n};\nfunction hashString(str) {\n  let h = 0, i = 0;\n  for (; i < str.length; h &= h)\n    h = 31 * h + str.charCodeAt(i++);\n  return Math.abs(h);\n}\nfunction makeCache(opts) {\n  const cacheDir = path__WEBPACK_IMPORTED_MODULE_8___default().resolve(process.cwd(), \".next\", \".plasmic\");\n  const cachePath = path__WEBPACK_IMPORTED_MODULE_8___default().join(\n    cacheDir,\n    `plasmic-${hashString(\n      [...opts.projects.map((p) => {\n        var _a;\n        return `${p.id}@${(_a = p.version) != null ? _a : \"\"}`;\n      })].sort().join(\"-\")\n    )}${opts.preview ? \"-preview\" : \"\"}-cache.json`\n  );\n  return new FileCache(cachePath);\n}\nfunction initPlasmicLoaderWithCache(initFn, _a) {\n  var _b = _a, { nextNavigation } = _b, opts = __objRest(_b, [\"nextNavigation\"]);\n  const isBrowser = typeof window !== \"undefined\";\n  const isProd = \"development\" === \"production\";\n  const isBuildPhase = process.env.NEXT_PHASE === next_constants__WEBPACK_IMPORTED_MODULE_7__.PHASE_PRODUCTION_BUILD;\n  const cache = isBrowser || isProd ? void 0 : makeCache(opts);\n  const loader = initFn(__spreadProps(__spreadValues({\n    onClientSideFetch: \"warn\"\n  }, opts), {\n    cache,\n    platform: \"nextjs\",\n    platformOptions: {\n      nextjs: {\n        appDir: !!nextNavigation\n      }\n    },\n    // For Nextjs 12, revalidate may in fact re-use an existing instance\n    // of PlasmicComponentLoader that's already in memory, so we need to\n    // make sure we don't re-use the data cached in memory.\n    // We also enforce this for dev mode, so that we don't have to restart\n    // the dev server, in case getStaticProps() re-uses the same PlasmicComponentLoader\n    // We also enforce that during build phase, we re-use the data cached in memory\n    // to avoid re-fetching the data from Plasmic servers.\n    alwaysFresh: !isBuildPhase && !isBrowser\n  }));\n  if (!isProd) {\n    const stringOpts = JSON.stringify(opts);\n    if (process.env.PLASMIC_OPTS && process.env.PLASMIC_OPTS !== stringOpts) {\n      console.warn(\n        `PLASMIC: We detected that you created a new PlasmicLoader with different configurations. You may need to restart your dev server.\n`\n      );\n    }\n    process.env.PLASMIC_OPTS = stringOpts;\n  }\n  if (cache) {\n    if (!isProd) {\n      if (process.env.PLASMIC_WATCHED !== \"true\") {\n        (() => __async(this, null, function* () {\n          process.env.PLASMIC_WATCHED = \"true\";\n          console.log(`Subscribing to Plasmic changes...`);\n          try {\n            const PlasmicRemoteChangeWatcher = (yield serverRequire(\"@plasmicapp/watcher\")).PlasmicRemoteChangeWatcher;\n            const watcher = new PlasmicRemoteChangeWatcher({\n              projects: opts.projects,\n              host: opts.host\n            });\n            const clearCache = () => {\n              cache.clear();\n              loader.clearCache();\n            };\n            watcher.subscribe({\n              onUpdate: () => {\n                if (opts.preview) {\n                  clearCache();\n                }\n              },\n              onPublish: () => {\n                if (!opts.preview) {\n                  clearCache();\n                }\n              }\n            });\n          } catch (e) {\n            console.warn(\"Couldn't subscribe to Plasmic changes\", e);\n          }\n        }))();\n      }\n    } else {\n      cache.clear();\n      loader.clearCache();\n    }\n  }\n  return loader;\n}\n\n// src/mocks.tsx\n\nvar fakeRouter = {\n  push: () => __async(void 0, null, function* () {\n    return true;\n  }),\n  replace: () => __async(void 0, null, function* () {\n    return true;\n  }),\n  reload: () => {\n  },\n  back: () => {\n  },\n  forward: () => {\n  },\n  prefetch: () => __async(void 0, null, function* () {\n    return;\n  }),\n  beforePopState: () => {\n  },\n  events: {\n    on: () => {\n    },\n    off: () => {\n    },\n    emit: () => {\n    }\n  },\n  route: \"/\",\n  asPath: \"/\",\n  basePath: \"/\",\n  pathname: \"/\",\n  query: {},\n  isFallback: false,\n  isLocaleDomain: false,\n  isReady: true,\n  isPreview: false\n};\nfunction wrapRouterContext(element) {\n  return __async(this, null, function* () {\n    var _a;\n    const RouterContext = (_a = yield tryServerRequires([\n      \"next/dist/shared/lib/router-context.shared-runtime\",\n      \"next/dist/shared/lib/router-context\"\n    ])) == null ? void 0 : _a.RouterContext;\n    return !!(RouterContext == null ? void 0 : RouterContext.Provider) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(RouterContext.Provider, { value: fakeRouter }, element) : element;\n  });\n}\n\n// src/index.tsx\nvar reactMajorVersion = +react__WEBPACK_IMPORTED_MODULE_6__.version.split(\".\")[0];\nfunction filterCodeFromRenderData(data) {\n  if (reactMajorVersion >= 18 && !!data.bundle.bundleKey) {\n    const entrypoints = /* @__PURE__ */ new Set([\n      ...data.entryCompMetas.map((compMeta) => compMeta.entry),\n      \"root-provider.js\",\n      ...data.bundle.projects.map((x) => x.globalContextsProviderFileName).filter((x) => !!x),\n      ...data.bundle.components.filter((c) => c.isGlobalContextProvider).map((c) => c.entry),\n      ...data.bundle.globalGroups.map((g) => g.contextFile)\n    ]);\n    data.bundle.modules.browser = data.bundle.modules.browser.map((module) => {\n      if (module.type !== \"code\" || entrypoints.has(module.fileName)) {\n        return module;\n      }\n      return __spreadProps(__spreadValues({}, module), { code: \"\" });\n    });\n  }\n}\nvar NextJsPlasmicComponentLoader = class extends _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicComponentLoader {\n  constructor(internal) {\n    super(internal);\n  }\n  getActiveVariation(opts) {\n    return __async(this, null, function* () {\n      const extractBuiltinTraits = () => {\n        var _a, _b, _c, _d;\n        const url = new URL(\n          (_b = (_a = opts.req) == null ? void 0 : _a.url) != null ? _b : \"/\",\n          `https://${(_d = (_c = opts.req) == null ? void 0 : _c.headers.host) != null ? _d : \"server.side\"}`\n        );\n        return {\n          pageUrl: url.href\n        };\n      };\n      return this._getActiveVariation({\n        enableUnseededExperiments: true,\n        traits: __spreadValues(__spreadValues({}, extractBuiltinTraits()), opts.traits),\n        getKnownValue: (key) => {\n          var _a, _b;\n          if (opts.known) {\n            return opts.known[key];\n          } else {\n            return (_b = (_a = opts.req) == null ? void 0 : _a.cookies[`plasmic:${key}`]) != null ? _b : void 0;\n          }\n        },\n        updateKnownValue: (key, value) => {\n          var _a, _b, _c;\n          if (opts.res) {\n            const cookie = `plasmic:${key}=${value}`;\n            const resCookie = (_b = (_a = opts.res) == null ? void 0 : _a.getHeader(\"Set-Cookie\")) != null ? _b : [];\n            let newCookies = [];\n            if (Array.isArray(resCookie)) {\n              newCookies = [...resCookie, `plasmic:${key}=${value}`];\n            } else {\n              newCookies = [`${resCookie}`, cookie];\n            }\n            (_c = opts.res) == null ? void 0 : _c.setHeader(\"Set-Cookie\", newCookies);\n          }\n        }\n      });\n    });\n  }\n  maybeFetchComponentData(...args) {\n    return __async(this, null, function* () {\n      const data = yield __superGet(NextJsPlasmicComponentLoader.prototype, this, \"maybeFetchComponentData\").call(this, ...args);\n      const { opts } = parseFetchComponentDataArgs(...args);\n      if (data && ((opts == null ? void 0 : opts.deferChunks) || (opts == null ? void 0 : opts.deferChunks) === void 0 && data.bundle.deferChunksByDefault)) {\n        filterCodeFromRenderData(data);\n      }\n      return data;\n    });\n  }\n  fetchComponentData(...args) {\n    return __async(this, null, function* () {\n      const data = yield __superGet(NextJsPlasmicComponentLoader.prototype, this, \"fetchComponentData\").call(this, ...args);\n      const { opts } = parseFetchComponentDataArgs(...args);\n      if ((opts == null ? void 0 : opts.deferChunks) || (opts == null ? void 0 : opts.deferChunks) === void 0 && data.bundle.deferChunksByDefault) {\n        filterCodeFromRenderData(data);\n      }\n      return data;\n    });\n  }\n};\nfunction parseFetchComponentDataArgs(...args) {\n  let specs;\n  let opts;\n  if (Array.isArray(args[0])) {\n    specs = args[0];\n    opts = args[1];\n  } else {\n    specs = args;\n    opts = void 0;\n  }\n  return { specs, opts };\n}\nfunction initPlasmicLoader(opts) {\n  const loader = initPlasmicLoaderWithCache(\n    (opts2) => new NextJsPlasmicComponentLoader(\n      new _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.InternalPlasmicComponentLoader(opts2)\n    ),\n    opts\n  );\n  loader.registerModules({\n    \"next/head\": (next_head_js__WEBPACK_IMPORTED_MODULE_2___default()),\n    \"next/link\": (next_link_js__WEBPACK_IMPORTED_MODULE_3___default()),\n    \"next/router\": next_router_js__WEBPACK_IMPORTED_MODULE_4__\n  });\n  if (opts.nextNavigation) {\n    loader.registerModules({\n      \"next/navigation\": opts.nextNavigation\n    });\n  }\n  return loader;\n}\nfunction extractPlasmicQueryData(element) {\n  return __async(this, null, function* () {\n    return (0,_plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.extractPlasmicQueryData)(yield wrapRouterContext(element));\n  });\n}\nvar PlasmicNextLink = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(function PlasmicNextLink2(props, ref) {\n  if (props.href) {\n    const _a = props, {\n      href,\n      replace,\n      scroll,\n      shallow,\n      passHref,\n      prefetch,\n      locale\n    } = _a, rest = __objRest(_a, [\n      \"href\",\n      \"replace\",\n      \"scroll\",\n      \"shallow\",\n      \"passHref\",\n      \"prefetch\",\n      \"locale\"\n    ]);\n    const isFragment = typeof href === \"string\" && href.startsWith(\"#\");\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\n      (next_link_js__WEBPACK_IMPORTED_MODULE_3___default()),\n      __spreadValues({\n        href,\n        replace,\n        scroll: scroll != null ? scroll : isFragment ? false : void 0,\n        shallow,\n        passHref,\n        prefetch,\n        locale\n      }, { legacyBehavior: true }),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"a\", __spreadProps(__spreadValues({}, rest), { ref }))\n    );\n  } else {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"a\", __spreadProps(__spreadValues({}, props), { href: void 0, ref }));\n  }\n});\nfunction PlasmicRootProvider(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(react__WEBPACK_IMPORTED_MODULE_6__.Fragment, null, !props.skipChunks && renderDynamicPayloadScripts(props.loader, props.prefetchedData), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\n    _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.PlasmicRootProvider,\n    __spreadValues({\n      Head: (next_head_js__WEBPACK_IMPORTED_MODULE_2___default()),\n      Link: PlasmicNextLink\n    }, props)\n  ));\n}\nfunction renderDynamicPayloadScripts(loader, prefetchedData) {\n  const missingModulesData = prefetchedData && prefetchedData.bundle.modules.browser.filter(\n    (module) => module.type === \"code\" && !module.code\n  );\n  if (!missingModulesData || missingModulesData.length === 0) {\n    return null;\n  }\n  const isBrowser = typeof window !== \"undefined\";\n  if (isBrowser) {\n    if (!globalThis.__PlasmicBundlePromises) {\n      globalThis.__PlasmicBundlePromises = {};\n    }\n    for (const { fileName } of missingModulesData) {\n      if (!globalThis.__PlasmicBundlePromises[fileName]) {\n        globalThis.__PlasmicBundlePromises[fileName] = new Promise(\n          (resolve) => {\n            globalThis.__PlasmicBundlePromises[\"__promise_resolve_\" + fileName] = resolve;\n          }\n        );\n      }\n    }\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(react__WEBPACK_IMPORTED_MODULE_6__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\n    (next_script__WEBPACK_IMPORTED_MODULE_5___default()),\n    {\n      strategy: \"beforeInteractive\",\n      key: \"init:\" + missingModulesData.map((m) => m.fileName).join(\";\"),\n      id: \"init:\" + missingModulesData.map((m) => m.fileName).join(\";\"),\n      dangerouslySetInnerHTML: {\n        __html: `\n            if (!globalThis.__PlasmicBundlePromises) {\n              globalThis.__PlasmicBundlePromises = {};\n            }\n            ${missingModulesData.map(\n          (module) => `if (!globalThis.__PlasmicBundlePromises[${JSON.stringify(\n            module.fileName\n          )}]) {\n                  globalThis.__PlasmicBundlePromises[${JSON.stringify(\n            module.fileName\n          )}] = new Promise((resolve) => {\n                    globalThis.__PlasmicBundlePromises[${JSON.stringify(\n            \"__promise_resolve_\" + module.fileName\n          )}] = resolve;\n                  })\n                }\n              `\n        ).join(\"\\n\")}`.trim()\n      }\n    }\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\n    (next_script__WEBPACK_IMPORTED_MODULE_5___default()),\n    {\n      strategy: \"beforeInteractive\",\n      key: \"load:\" + missingModulesData.map((m) => m.fileName).join(\";\"),\n      id: \"load:\" + missingModulesData.map((m) => m.fileName).join(\";\"),\n      defer: true,\n      async: true,\n      src: loader.getChunksUrl(prefetchedData.bundle, missingModulesData)\n    }\n  ));\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItbmV4dGpzL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBTWtDO0FBb0JBO0FBQ3NDO0FBQ3BDO0FBQ0E7QUFDUztBQUNaO0FBQ0Q7O0FBRWhDO0FBQ3dEO0FBQ2hDOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1EQUFZLG1CQUFtQixpQkFBaUI7QUFDaEY7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3REFBd0QsS0FBSztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBWSxDQUFDLE9BQU87QUFDdkMsb0JBQW9CLGdEQUFTO0FBQzdCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLG1DQUFtQztBQUM3RCxPQUFPO0FBQ1AsTUFBTSxFQUFFLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQSxpQkFBaUIsYUFBb0I7QUFDckMsdUJBQXVCLE9BQU8sb0JBQW9CLGtFQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVEsT0FBTyxxQkFBcUIsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGdEQUFtQiwyQkFBMkIsbUJBQW1CO0FBQzFKLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHlCQUF5QiwwQ0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhLFVBQVU7QUFDbkUsS0FBSztBQUNMO0FBQ0E7QUFDQSxpREFBaUQsNEVBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RkFBdUY7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0ZBQWtGLElBQUk7QUFDdEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksR0FBRyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxJQUFJLEdBQUcsTUFBTTtBQUNsRSxjQUFjO0FBQ2QsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvRkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVE7QUFDekIsaUJBQWlCLHFEQUFRO0FBQ3pCLG1CQUFtQiwyQ0FBVTtBQUM3QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlGQUErQjtBQUMxQyxHQUFHO0FBQ0g7QUFDQSxzQkFBc0IsNkNBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CO0FBQy9DLE1BQU0scURBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLHNCQUFzQjtBQUNqQyxzQkFBc0IsZ0RBQW9CLHFDQUFxQyxXQUFXLEtBQUs7QUFDL0Y7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLGdEQUFvQixxQ0FBcUMsWUFBWSxtQkFBbUI7QUFDbkg7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWUsOEdBQThHLGdEQUFvQjtBQUMvTCxJQUFJLHlFQUF5QjtBQUM3QjtBQUNBLFlBQVkscURBQVE7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsQ0FBQywyQ0FBZSx3QkFBd0IsZ0RBQW9CO0FBQ3pHLElBQUksb0RBQU07QUFDVjtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGlFQUFpRTtBQUNqRTtBQUNBLFlBQVk7QUFDWix1REFBdUQ7QUFDdkQ7QUFDQSxZQUFZO0FBQ1oseURBQXlEO0FBQ3pEO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQW9CO0FBQ3pDLElBQUksb0RBQU07QUFDVjtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxcbG9hZGVyLW5leHRqc1xcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fcmVmbGVjdEdldCA9IFJlZmxlY3QuZ2V0O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19zdXBlckdldCA9IChjbHMsIG9iaiwga2V5KSA9PiBfX3JlZmxlY3RHZXQoX19nZXRQcm90b09mKGNscyksIGtleSwgb2JqKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9pbmRleC50c3hcbmltcG9ydCB7XG4gIFBsYXNtaWNSb290UHJvdmlkZXIgYXMgQ29tbW9uUGxhc21pY1Jvb3RQcm92aWRlcixcbiAgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YSBhcyBpbnRlcm5hbEV4dHJhY3RQbGFzbWljUXVlcnlEYXRhXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItcmVhY3RcIjtcbmltcG9ydCB7XG4gIERhdGFDdHhSZWFkZXIsXG4gIERhdGFQcm92aWRlcixcbiAgR2xvYmFsQWN0aW9uc0NvbnRleHQsXG4gIEdsb2JhbEFjdGlvbnNQcm92aWRlcixcbiAgUGFnZVBhcmFtc1Byb3ZpZGVyLFxuICBQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgUGxhc21pY0NhbnZhc0hvc3QsXG4gIFBsYXNtaWNDb21wb25lbnQsXG4gIFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCxcbiAgcGxhc21pY1ByZXBhc3MsXG4gIHJlcGVhdGVkRWxlbWVudCxcbiAgdXNlRGF0YUVudixcbiAgdXNlUGxhc21pY0NhbnZhc0NvbXBvbmVudEluZm8sXG4gIHVzZVBsYXNtaWNDYW52YXNDb250ZXh0LFxuICB1c2VQbGFzbWljQ29tcG9uZW50LFxuICB1c2VQbGFzbWljUXVlcnlEYXRhLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU2VsZWN0b3JzXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItcmVhY3RcIjtcbmltcG9ydCB7IEV4dHJhY3RQbGFzbWljUXVlcnlEYXRhIH0gZnJvbSBcIkBwbGFzbWljYXBwL25leHRqcy1hcHAtcm91dGVyXCI7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSBcIm5leHQvaGVhZC5qc1wiO1xuaW1wb3J0IE5leHRMaW5rIGZyb20gXCJuZXh0L2xpbmsuanNcIjtcbmltcG9ydCAqIGFzIE5leHRSb3V0ZXIgZnJvbSBcIm5leHQvcm91dGVyLmpzXCI7XG5pbXBvcnQgU2NyaXB0IGZyb20gXCJuZXh0L3NjcmlwdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY2FjaGUudHNcbmltcG9ydCB7IFBIQVNFX1BST0RVQ1RJT05fQlVJTEQgfSBmcm9tIFwibmV4dC9jb25zdGFudHNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbi8vIHNyYy9zZXJ2ZXItcmVxdWlyZS50c1xudmFyIHNlY3JldFJlcXVpcmU7XG50cnkge1xuICBzZWNyZXRSZXF1aXJlID0gZXZhbChcInJlcXVpcmVcIik7XG59IGNhdGNoIChlcnIpIHtcbiAgdHJ5IHtcbiAgICBzZWNyZXRSZXF1aXJlID0gZXZhbChcIihtb2R1bGUpID0+IGltcG9ydChtb2R1bGUpXCIpO1xuICB9IGNhdGNoIChlcnIyKSB7XG4gICAgc2VjcmV0UmVxdWlyZSA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gc2VydmVyUmVxdWlyZShtb2R1bGUpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXNlY3JldFJlcXVpcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyUmVxdWlyZSgpIC0tIGNhbiBvbmx5IGRvIHRoaXMgZnJvbSBhIE5vZGUgc2VydmVyIWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzZWNyZXRSZXF1aXJlKG1vZHVsZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJ5U2VydmVyUmVxdWlyZShtb2R1bGUpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWlyZTIgPSB5aWVsZCBzZXJ2ZXJSZXF1aXJlKG1vZHVsZSk7XG4gICAgICByZXR1cm4gcmVxdWlyZTI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJ5U2VydmVyUmVxdWlyZXMobW9kdWxlcykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgIGNvbnN0IHJlcXVpcmUyID0geWllbGQgdHJ5U2VydmVyUmVxdWlyZShtb2R1bGUpO1xuICAgICAgaWYgKHJlcXVpcmUyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlcXVpcmVGcygpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4gc2VydmVyUmVxdWlyZShcImZzXCIpO1xuICB9KTtcbn1cblxuLy8gc3JjL2NhY2hlLnRzXG52YXIgRmlsZUNhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihmaWxlUGF0aCkge1xuICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGZzID0geWllbGQgc2VydmVyUmVxdWlyZUZzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBmcy5wcm9taXNlcy5ta2RpcihwYXRoLmRpcm5hbWUodGhpcy5maWxlUGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gKHlpZWxkIGZzLnByb21pc2VzLnJlYWRGaWxlKHRoaXMuZmlsZVBhdGgpKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXQoZGF0YSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBmcyA9IHlpZWxkIHNlcnZlclJlcXVpcmVGcygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgZnMucHJvbWlzZXMud3JpdGVGaWxlKHRoaXMuZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciB3cml0aW5nIHRvIFBsYXNtaWMgY2FjaGU6ICR7ZXJyMn1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZnMgPSB5aWVsZCBzZXJ2ZXJSZXF1aXJlRnMoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIGZzLnByb21pc2VzLnVubGluayh0aGlzLmZpbGVQYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyKSB7XG4gIGxldCBoID0gMCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgaCAmPSBoKVxuICAgIGggPSAzMSAqIGggKyBzdHIuY2hhckNvZGVBdChpKyspO1xuICByZXR1cm4gTWF0aC5hYnMoaCk7XG59XG5mdW5jdGlvbiBtYWtlQ2FjaGUob3B0cykge1xuICBjb25zdCBjYWNoZURpciA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBcIi5uZXh0XCIsIFwiLnBsYXNtaWNcIik7XG4gIGNvbnN0IGNhY2hlUGF0aCA9IHBhdGguam9pbihcbiAgICBjYWNoZURpcixcbiAgICBgcGxhc21pYy0ke2hhc2hTdHJpbmcoXG4gICAgICBbLi4ub3B0cy5wcm9qZWN0cy5tYXAoKHApID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYCR7cC5pZH1AJHsoX2EgPSBwLnZlcnNpb24pICE9IG51bGwgPyBfYSA6IFwiXCJ9YDtcbiAgICAgIH0pXS5zb3J0KCkuam9pbihcIi1cIilcbiAgICApfSR7b3B0cy5wcmV2aWV3ID8gXCItcHJldmlld1wiIDogXCJcIn0tY2FjaGUuanNvbmBcbiAgKTtcbiAgcmV0dXJuIG5ldyBGaWxlQ2FjaGUoY2FjaGVQYXRoKTtcbn1cbmZ1bmN0aW9uIGluaXRQbGFzbWljTG9hZGVyV2l0aENhY2hlKGluaXRGbiwgX2EpIHtcbiAgdmFyIF9iID0gX2EsIHsgbmV4dE5hdmlnYXRpb24gfSA9IF9iLCBvcHRzID0gX19vYmpSZXN0KF9iLCBbXCJuZXh0TmF2aWdhdGlvblwiXSk7XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGlzUHJvZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbiAgY29uc3QgaXNCdWlsZFBoYXNlID0gcHJvY2Vzcy5lbnYuTkVYVF9QSEFTRSA9PT0gUEhBU0VfUFJPRFVDVElPTl9CVUlMRDtcbiAgY29uc3QgY2FjaGUgPSBpc0Jyb3dzZXIgfHwgaXNQcm9kID8gdm9pZCAwIDogbWFrZUNhY2hlKG9wdHMpO1xuICBjb25zdCBsb2FkZXIgPSBpbml0Rm4oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgb25DbGllbnRTaWRlRmV0Y2g6IFwid2FyblwiXG4gIH0sIG9wdHMpLCB7XG4gICAgY2FjaGUsXG4gICAgcGxhdGZvcm06IFwibmV4dGpzXCIsXG4gICAgcGxhdGZvcm1PcHRpb25zOiB7XG4gICAgICBuZXh0anM6IHtcbiAgICAgICAgYXBwRGlyOiAhIW5leHROYXZpZ2F0aW9uXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBGb3IgTmV4dGpzIDEyLCByZXZhbGlkYXRlIG1heSBpbiBmYWN0IHJlLXVzZSBhbiBleGlzdGluZyBpbnN0YW5jZVxuICAgIC8vIG9mIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgdGhhdCdzIGFscmVhZHkgaW4gbWVtb3J5LCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IHJlLXVzZSB0aGUgZGF0YSBjYWNoZWQgaW4gbWVtb3J5LlxuICAgIC8vIFdlIGFsc28gZW5mb3JjZSB0aGlzIGZvciBkZXYgbW9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlc3RhcnRcbiAgICAvLyB0aGUgZGV2IHNlcnZlciwgaW4gY2FzZSBnZXRTdGF0aWNQcm9wcygpIHJlLXVzZXMgdGhlIHNhbWUgUGxhc21pY0NvbXBvbmVudExvYWRlclxuICAgIC8vIFdlIGFsc28gZW5mb3JjZSB0aGF0IGR1cmluZyBidWlsZCBwaGFzZSwgd2UgcmUtdXNlIHRoZSBkYXRhIGNhY2hlZCBpbiBtZW1vcnlcbiAgICAvLyB0byBhdm9pZCByZS1mZXRjaGluZyB0aGUgZGF0YSBmcm9tIFBsYXNtaWMgc2VydmVycy5cbiAgICBhbHdheXNGcmVzaDogIWlzQnVpbGRQaGFzZSAmJiAhaXNCcm93c2VyXG4gIH0pKTtcbiAgaWYgKCFpc1Byb2QpIHtcbiAgICBjb25zdCBzdHJpbmdPcHRzID0gSlNPTi5zdHJpbmdpZnkob3B0cyk7XG4gICAgaWYgKHByb2Nlc3MuZW52LlBMQVNNSUNfT1BUUyAmJiBwcm9jZXNzLmVudi5QTEFTTUlDX09QVFMgIT09IHN0cmluZ09wdHMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFBMQVNNSUM6IFdlIGRldGVjdGVkIHRoYXQgeW91IGNyZWF0ZWQgYSBuZXcgUGxhc21pY0xvYWRlciB3aXRoIGRpZmZlcmVudCBjb25maWd1cmF0aW9ucy4gWW91IG1heSBuZWVkIHRvIHJlc3RhcnQgeW91ciBkZXYgc2VydmVyLlxuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuUExBU01JQ19PUFRTID0gc3RyaW5nT3B0cztcbiAgfVxuICBpZiAoY2FjaGUpIHtcbiAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlBMQVNNSUNfV0FUQ0hFRCAhPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgKCgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5QTEFTTUlDX1dBVENIRUQgPSBcInRydWVcIjtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3Vic2NyaWJpbmcgdG8gUGxhc21pYyBjaGFuZ2VzLi4uYCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFBsYXNtaWNSZW1vdGVDaGFuZ2VXYXRjaGVyID0gKHlpZWxkIHNlcnZlclJlcXVpcmUoXCJAcGxhc21pY2FwcC93YXRjaGVyXCIpKS5QbGFzbWljUmVtb3RlQ2hhbmdlV2F0Y2hlcjtcbiAgICAgICAgICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgUGxhc21pY1JlbW90ZUNoYW5nZVdhdGNoZXIoe1xuICAgICAgICAgICAgICBwcm9qZWN0czogb3B0cy5wcm9qZWN0cyxcbiAgICAgICAgICAgICAgaG9zdDogb3B0cy5ob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgIGxvYWRlci5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2F0Y2hlci5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uUHVibGlzaDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb3B0cy5wcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgICBjbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZG4ndCBzdWJzY3JpYmUgdG8gUGxhc21pYyBjaGFuZ2VzXCIsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICBsb2FkZXIuY2xlYXJDYWNoZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9hZGVyO1xufVxuXG4vLyBzcmMvbW9ja3MudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciBmYWtlUm91dGVyID0ge1xuICBwdXNoOiAoKSA9PiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSksXG4gIHJlcGxhY2U6ICgpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9KSxcbiAgcmVsb2FkOiAoKSA9PiB7XG4gIH0sXG4gIGJhY2s6ICgpID0+IHtcbiAgfSxcbiAgZm9yd2FyZDogKCkgPT4ge1xuICB9LFxuICBwcmVmZXRjaDogKCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuO1xuICB9KSxcbiAgYmVmb3JlUG9wU3RhdGU6ICgpID0+IHtcbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb246ICgpID0+IHtcbiAgICB9LFxuICAgIG9mZjogKCkgPT4ge1xuICAgIH0sXG4gICAgZW1pdDogKCkgPT4ge1xuICAgIH1cbiAgfSxcbiAgcm91dGU6IFwiL1wiLFxuICBhc1BhdGg6IFwiL1wiLFxuICBiYXNlUGF0aDogXCIvXCIsXG4gIHBhdGhuYW1lOiBcIi9cIixcbiAgcXVlcnk6IHt9LFxuICBpc0ZhbGxiYWNrOiBmYWxzZSxcbiAgaXNMb2NhbGVEb21haW46IGZhbHNlLFxuICBpc1JlYWR5OiB0cnVlLFxuICBpc1ByZXZpZXc6IGZhbHNlXG59O1xuZnVuY3Rpb24gd3JhcFJvdXRlckNvbnRleHQoZWxlbWVudCkge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBSb3V0ZXJDb250ZXh0ID0gKF9hID0geWllbGQgdHJ5U2VydmVyUmVxdWlyZXMoW1xuICAgICAgXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiLFxuICAgICAgXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dFwiXG4gICAgXSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5Sb3V0ZXJDb250ZXh0O1xuICAgIHJldHVybiAhIShSb3V0ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGZha2VSb3V0ZXIgfSwgZWxlbWVudCkgOiBlbGVtZW50O1xuICB9KTtcbn1cblxuLy8gc3JjL2luZGV4LnRzeFxudmFyIHJlYWN0TWFqb3JWZXJzaW9uID0gK1JlYWN0Mi52ZXJzaW9uLnNwbGl0KFwiLlwiKVswXTtcbmZ1bmN0aW9uIGZpbHRlckNvZGVGcm9tUmVuZGVyRGF0YShkYXRhKSB7XG4gIGlmIChyZWFjdE1ham9yVmVyc2lvbiA+PSAxOCAmJiAhIWRhdGEuYnVuZGxlLmJ1bmRsZUtleSkge1xuICAgIGNvbnN0IGVudHJ5cG9pbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgLi4uZGF0YS5lbnRyeUNvbXBNZXRhcy5tYXAoKGNvbXBNZXRhKSA9PiBjb21wTWV0YS5lbnRyeSksXG4gICAgICBcInJvb3QtcHJvdmlkZXIuanNcIixcbiAgICAgIC4uLmRhdGEuYnVuZGxlLnByb2plY3RzLm1hcCgoeCkgPT4geC5nbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWUpLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgIC4uLmRhdGEuYnVuZGxlLmNvbXBvbmVudHMuZmlsdGVyKChjKSA9PiBjLmlzR2xvYmFsQ29udGV4dFByb3ZpZGVyKS5tYXAoKGMpID0+IGMuZW50cnkpLFxuICAgICAgLi4uZGF0YS5idW5kbGUuZ2xvYmFsR3JvdXBzLm1hcCgoZykgPT4gZy5jb250ZXh0RmlsZSlcbiAgICBdKTtcbiAgICBkYXRhLmJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIgPSBkYXRhLmJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIubWFwKChtb2R1bGUpID0+IHtcbiAgICAgIGlmIChtb2R1bGUudHlwZSAhPT0gXCJjb2RlXCIgfHwgZW50cnlwb2ludHMuaGFzKG1vZHVsZS5maWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtb2R1bGUpLCB7IGNvZGU6IFwiXCIgfSk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBOZXh0SnNQbGFzbWljQ29tcG9uZW50TG9hZGVyID0gY2xhc3MgZXh0ZW5kcyBQbGFzbWljQ29tcG9uZW50TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWwpIHtcbiAgICBzdXBlcihpbnRlcm5hbCk7XG4gIH1cbiAgZ2V0QWN0aXZlVmFyaWF0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZXh0cmFjdEJ1aWx0aW5UcmFpdHMgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgICAgICAoX2IgPSAoX2EgPSBvcHRzLnJlcSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVybCkgIT0gbnVsbCA/IF9iIDogXCIvXCIsXG4gICAgICAgICAgYGh0dHBzOi8vJHsoX2QgPSAoX2MgPSBvcHRzLnJlcSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmhlYWRlcnMuaG9zdCkgIT0gbnVsbCA/IF9kIDogXCJzZXJ2ZXIuc2lkZVwifWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlVXJsOiB1cmwuaHJlZlxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRBY3RpdmVWYXJpYXRpb24oe1xuICAgICAgICBlbmFibGVVbnNlZWRlZEV4cGVyaW1lbnRzOiB0cnVlLFxuICAgICAgICB0cmFpdHM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBleHRyYWN0QnVpbHRpblRyYWl0cygpKSwgb3B0cy50cmFpdHMpLFxuICAgICAgICBnZXRLbm93blZhbHVlOiAoa2V5KSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICBpZiAob3B0cy5rbm93bikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMua25vd25ba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IG9wdHMucmVxKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29va2llc1tgcGxhc21pYzoke2tleX1gXSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlS25vd25WYWx1ZTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICBpZiAob3B0cy5yZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IGBwbGFzbWljOiR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgICAgICAgICBjb25zdCByZXNDb29raWUgPSAoX2IgPSAoX2EgPSBvcHRzLnJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEhlYWRlcihcIlNldC1Db29raWVcIikpICE9IG51bGwgPyBfYiA6IFtdO1xuICAgICAgICAgICAgbGV0IG5ld0Nvb2tpZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc0Nvb2tpZSkpIHtcbiAgICAgICAgICAgICAgbmV3Q29va2llcyA9IFsuLi5yZXNDb29raWUsIGBwbGFzbWljOiR7a2V5fT0ke3ZhbHVlfWBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3Q29va2llcyA9IFtgJHtyZXNDb29raWV9YCwgY29va2llXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IG9wdHMucmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2V0SGVhZGVyKFwiU2V0LUNvb2tpZVwiLCBuZXdDb29raWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIF9fc3VwZXJHZXQoTmV4dEpzUGxhc21pY0NvbXBvbmVudExvYWRlci5wcm90b3R5cGUsIHRoaXMsIFwibWF5YmVGZXRjaENvbXBvbmVudERhdGFcIikuY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICAgIGNvbnN0IHsgb3B0cyB9ID0gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKC4uLmFyZ3MpO1xuICAgICAgaWYgKGRhdGEgJiYgKChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmRlZmVyQ2h1bmtzKSB8fCAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5kZWZlckNodW5rcykgPT09IHZvaWQgMCAmJiBkYXRhLmJ1bmRsZS5kZWZlckNodW5rc0J5RGVmYXVsdCkpIHtcbiAgICAgICAgZmlsdGVyQ29kZUZyb21SZW5kZXJEYXRhKGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIF9fc3VwZXJHZXQoTmV4dEpzUGxhc21pY0NvbXBvbmVudExvYWRlci5wcm90b3R5cGUsIHRoaXMsIFwiZmV0Y2hDb21wb25lbnREYXRhXCIpLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICBjb25zdCB7IG9wdHMgfSA9IHBhcnNlRmV0Y2hDb21wb25lbnREYXRhQXJncyguLi5hcmdzKTtcbiAgICAgIGlmICgob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5kZWZlckNodW5rcykgfHwgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGVmZXJDaHVua3MpID09PSB2b2lkIDAgJiYgZGF0YS5idW5kbGUuZGVmZXJDaHVua3NCeURlZmF1bHQpIHtcbiAgICAgICAgZmlsdGVyQ29kZUZyb21SZW5kZXJEYXRhKGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZUZldGNoQ29tcG9uZW50RGF0YUFyZ3MoLi4uYXJncykge1xuICBsZXQgc3BlY3M7XG4gIGxldCBvcHRzO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgIHNwZWNzID0gYXJnc1swXTtcbiAgICBvcHRzID0gYXJnc1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzcGVjcyA9IGFyZ3M7XG4gICAgb3B0cyA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBzcGVjcywgb3B0cyB9O1xufVxuZnVuY3Rpb24gaW5pdFBsYXNtaWNMb2FkZXIob3B0cykge1xuICBjb25zdCBsb2FkZXIgPSBpbml0UGxhc21pY0xvYWRlcldpdGhDYWNoZShcbiAgICAob3B0czIpID0+IG5ldyBOZXh0SnNQbGFzbWljQ29tcG9uZW50TG9hZGVyKFxuICAgICAgbmV3IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcihvcHRzMilcbiAgICApLFxuICAgIG9wdHNcbiAgKTtcbiAgbG9hZGVyLnJlZ2lzdGVyTW9kdWxlcyh7XG4gICAgXCJuZXh0L2hlYWRcIjogTmV4dEhlYWQsXG4gICAgXCJuZXh0L2xpbmtcIjogTmV4dExpbmssXG4gICAgXCJuZXh0L3JvdXRlclwiOiBOZXh0Um91dGVyXG4gIH0pO1xuICBpZiAob3B0cy5uZXh0TmF2aWdhdGlvbikge1xuICAgIGxvYWRlci5yZWdpc3Rlck1vZHVsZXMoe1xuICAgICAgXCJuZXh0L25hdmlnYXRpb25cIjogb3B0cy5uZXh0TmF2aWdhdGlvblxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG5mdW5jdGlvbiBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YShlbGVtZW50KSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIGludGVybmFsRXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoeWllbGQgd3JhcFJvdXRlckNvbnRleHQoZWxlbWVudCkpO1xuICB9KTtcbn1cbnZhciBQbGFzbWljTmV4dExpbmsgPSBSZWFjdDIuZm9yd2FyZFJlZihmdW5jdGlvbiBQbGFzbWljTmV4dExpbmsyKHByb3BzLCByZWYpIHtcbiAgaWYgKHByb3BzLmhyZWYpIHtcbiAgICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgICBocmVmLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHNjcm9sbCxcbiAgICAgIHNoYWxsb3csXG4gICAgICBwYXNzSHJlZixcbiAgICAgIHByZWZldGNoLFxuICAgICAgbG9jYWxlXG4gICAgfSA9IF9hLCByZXN0ID0gX19vYmpSZXN0KF9hLCBbXG4gICAgICBcImhyZWZcIixcbiAgICAgIFwicmVwbGFjZVwiLFxuICAgICAgXCJzY3JvbGxcIixcbiAgICAgIFwic2hhbGxvd1wiLFxuICAgICAgXCJwYXNzSHJlZlwiLFxuICAgICAgXCJwcmVmZXRjaFwiLFxuICAgICAgXCJsb2NhbGVcIlxuICAgIF0pO1xuICAgIGNvbnN0IGlzRnJhZ21lbnQgPSB0eXBlb2YgaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBocmVmLnN0YXJ0c1dpdGgoXCIjXCIpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBOZXh0TGluayxcbiAgICAgIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgc2Nyb2xsOiBzY3JvbGwgIT0gbnVsbCA/IHNjcm9sbCA6IGlzRnJhZ21lbnQgPyBmYWxzZSA6IHZvaWQgMCxcbiAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgcGFzc0hyZWYsXG4gICAgICAgIHByZWZldGNoLFxuICAgICAgICBsb2NhbGVcbiAgICAgIH0sIHsgbGVnYWN5QmVoYXZpb3I6IHRydWUgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3QpLCB7IHJlZiB9KSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzKSwgeyBocmVmOiB2b2lkIDAsIHJlZiB9KSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gUGxhc21pY1Jvb3RQcm92aWRlcihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgIXByb3BzLnNraXBDaHVua3MgJiYgcmVuZGVyRHluYW1pY1BheWxvYWRTY3JpcHRzKHByb3BzLmxvYWRlciwgcHJvcHMucHJlZmV0Y2hlZERhdGEpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29tbW9uUGxhc21pY1Jvb3RQcm92aWRlcixcbiAgICBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBIZWFkOiBOZXh0SGVhZCxcbiAgICAgIExpbms6IFBsYXNtaWNOZXh0TGlua1xuICAgIH0sIHByb3BzKVxuICApKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckR5bmFtaWNQYXlsb2FkU2NyaXB0cyhsb2FkZXIsIHByZWZldGNoZWREYXRhKSB7XG4gIGNvbnN0IG1pc3NpbmdNb2R1bGVzRGF0YSA9IHByZWZldGNoZWREYXRhICYmIHByZWZldGNoZWREYXRhLmJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIuZmlsdGVyKFxuICAgIChtb2R1bGUpID0+IG1vZHVsZS50eXBlID09PSBcImNvZGVcIiAmJiAhbW9kdWxlLmNvZGVcbiAgKTtcbiAgaWYgKCFtaXNzaW5nTW9kdWxlc0RhdGEgfHwgbWlzc2luZ01vZHVsZXNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXMpIHtcbiAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXMgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7IGZpbGVOYW1lIH0gb2YgbWlzc2luZ01vZHVsZXNEYXRhKSB7XG4gICAgICBpZiAoIWdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbZmlsZU5hbWVdKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbZmlsZU5hbWVdID0gbmV3IFByb21pc2UoXG4gICAgICAgICAgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbXCJfX3Byb21pc2VfcmVzb2x2ZV9cIiArIGZpbGVOYW1lXSA9IHJlc29sdmU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgIFNjcmlwdCxcbiAgICB7XG4gICAgICBzdHJhdGVneTogXCJiZWZvcmVJbnRlcmFjdGl2ZVwiLFxuICAgICAga2V5OiBcImluaXQ6XCIgKyBtaXNzaW5nTW9kdWxlc0RhdGEubWFwKChtKSA9PiBtLmZpbGVOYW1lKS5qb2luKFwiO1wiKSxcbiAgICAgIGlkOiBcImluaXQ6XCIgKyBtaXNzaW5nTW9kdWxlc0RhdGEubWFwKChtKSA9PiBtLmZpbGVOYW1lKS5qb2luKFwiO1wiKSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgaWYgKCFnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzKSB7XG4gICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7bWlzc2luZ01vZHVsZXNEYXRhLm1hcChcbiAgICAgICAgICAobW9kdWxlKSA9PiBgaWYgKCFnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBtb2R1bGUuZmlsZU5hbWVcbiAgICAgICAgICApfV0pIHtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIG1vZHVsZS5maWxlTmFtZVxuICAgICAgICAgICl9XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIFwiX19wcm9taXNlX3Jlc29sdmVfXCIgKyBtb2R1bGUuZmlsZU5hbWVcbiAgICAgICAgICApfV0gPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgKS5qb2luKFwiXFxuXCIpfWAudHJpbSgpXG4gICAgICB9XG4gICAgfVxuICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgU2NyaXB0LFxuICAgIHtcbiAgICAgIHN0cmF0ZWd5OiBcImJlZm9yZUludGVyYWN0aXZlXCIsXG4gICAgICBrZXk6IFwibG9hZDpcIiArIG1pc3NpbmdNb2R1bGVzRGF0YS5tYXAoKG0pID0+IG0uZmlsZU5hbWUpLmpvaW4oXCI7XCIpLFxuICAgICAgaWQ6IFwibG9hZDpcIiArIG1pc3NpbmdNb2R1bGVzRGF0YS5tYXAoKG0pID0+IG0uZmlsZU5hbWUpLmpvaW4oXCI7XCIpLFxuICAgICAgZGVmZXI6IHRydWUsXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIHNyYzogbG9hZGVyLmdldENodW5rc1VybChwcmVmZXRjaGVkRGF0YS5idW5kbGUsIG1pc3NpbmdNb2R1bGVzRGF0YSlcbiAgICB9XG4gICkpO1xufVxuZXhwb3J0IHtcbiAgRGF0YUN0eFJlYWRlcixcbiAgRGF0YVByb3ZpZGVyLFxuICBHbG9iYWxBY3Rpb25zQ29udGV4dCxcbiAgR2xvYmFsQWN0aW9uc1Byb3ZpZGVyLFxuICBOZXh0SnNQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBQYWdlUGFyYW1zUHJvdmlkZXIsXG4gIFBsYXNtaWNDYW52YXNDb250ZXh0LFxuICBQbGFzbWljQ2FudmFzSG9zdCxcbiAgUGxhc21pY0NvbXBvbmVudCxcbiAgUGxhc21pY1Jvb3RQcm92aWRlcixcbiAgUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0LFxuICBFeHRyYWN0UGxhc21pY1F1ZXJ5RGF0YSBhcyBfX0VYUEVSTUlFTlRBTF9fRXh0cmFjdFBsYXNtaWNRdWVyeURhdGEsXG4gIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhLFxuICBpbml0UGxhc21pY0xvYWRlcixcbiAgcGxhc21pY1ByZXBhc3MsXG4gIHJlcGVhdGVkRWxlbWVudCxcbiAgdXNlRGF0YUVudixcbiAgdXNlUGxhc21pY0NhbnZhc0NvbXBvbmVudEluZm8sXG4gIHVzZVBsYXNtaWNDYW52YXNDb250ZXh0LFxuICB1c2VQbGFzbWljQ29tcG9uZW50LFxuICB1c2VQbGFzbWljUXVlcnlEYXRhLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU2VsZWN0b3JzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/loader-nextjs/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-react/dist/index.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataCtxReader: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataCtxReader),\n/* harmony export */   DataProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsProvider),\n/* harmony export */   InternalPlasmicComponentLoader: () => (/* binding */ InternalPlasmicComponentLoader),\n/* harmony export */   PageParamsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasHost),\n/* harmony export */   PlasmicComponent: () => (/* binding */ PlasmicComponent),\n/* harmony export */   PlasmicComponentLoader: () => (/* binding */ PlasmicComponentLoader),\n/* harmony export */   PlasmicRootProvider: () => (/* binding */ PlasmicRootProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicTranslatorContext),\n/* harmony export */   convertBundlesToComponentRenderData: () => (/* binding */ convertBundlesToComponentRenderData),\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   extractPlasmicQueryDataFromElement: () => (/* binding */ extractPlasmicQueryDataFromElement),\n/* harmony export */   hydrateFromElement: () => (/* binding */ hydrateFromElement),\n/* harmony export */   initPlasmicLoader: () => (/* binding */ initPlasmicLoader),\n/* harmony export */   matchesPagePath: () => (/* binding */ matchesPagePath),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   renderToElement: () => (/* binding */ renderToElement),\n/* harmony export */   renderToString: () => (/* binding */ renderToString),\n/* harmony export */   repeatedElement: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.repeatedElement),\n/* harmony export */   useDataEnv: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useDataEnv),\n/* harmony export */   usePlasmicCanvasComponentInfo: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.usePlasmicCanvasComponentInfo),\n/* harmony export */   usePlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.usePlasmicCanvasContext),\n/* harmony export */   usePlasmicComponent: () => (/* binding */ usePlasmicComponent),\n/* harmony export */   usePlasmicQueryData: () => (/* reexport safe */ _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.usePlasmicQueryData),\n/* harmony export */   useSelector: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelector),\n/* harmony export */   useSelectors: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/data-sources-context */ \"(pages-dir-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/host */ \"(pages-dir-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js\");\n/* harmony import */ var _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/loader-core */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @plasmicapp/query */ \"(pages-dir-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(pages-dir-browser)/./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pascalcase */ \"(pages-dir-browser)/./node_modules/pascalcase/index.js\");\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pascalcase__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @plasmicapp/loader-splits */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @plasmicapp/prepass */ \"(pages-dir-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-dom/server */ \"(pages-dir-browser)/./node_modules/react-dom/server.browser.js\");\n\"use client\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/loader-client.ts\n\n\n\n\n\n\n\n\n\n\n// src/PlasmicRootProvider.tsx\n\n\n\n\n// src/utils.tsx\n\n\nvar isBrowser = typeof window !== \"undefined\";\nfunction useForceUpdate() {\n  const [, setTick] = react__WEBPACK_IMPORTED_MODULE_4__.useState(0);\n  const update = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\nfunction useStableLookupSpec(spec) {\n  return useStableLookupSpecs(spec)[0];\n}\nfunction useStableLookupSpecs(...specs) {\n  const [stableSpecs, setStableSpecs] = react__WEBPACK_IMPORTED_MODULE_4__.useState(specs);\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    if (specs.length !== stableSpecs.length || specs.some((s, i) => !areLookupSpecsEqual(s, stableSpecs[i]))) {\n      setStableSpecs(specs);\n    }\n  }, [specs, stableSpecs]);\n  return stableSpecs;\n}\nfunction areLookupSpecsEqual(spec1, spec2) {\n  if (spec1 === spec2) {\n    return true;\n  }\n  if (typeof spec1 !== typeof spec2) {\n    return false;\n  }\n  const fullSpec1 = toFullLookup(spec1);\n  const fullSpec2 = toFullLookup(spec2);\n  return (isNameSpec(fullSpec1) && isNameSpec(fullSpec2) && fullSpec1.name === fullSpec2.name && fullSpec1.isCode === fullSpec2.isCode || isPathSpec(fullSpec1) && isPathSpec(fullSpec2) && fullSpec1.path === fullSpec2.path) && fullSpec1.projectId === fullSpec2.projectId;\n}\nfunction isNameSpec(lookup) {\n  return \"name\" in lookup;\n}\nfunction isPathSpec(lookup) {\n  return \"path\" in lookup;\n}\nfunction toFullLookup(lookup) {\n  const namePart = typeof lookup === \"string\" ? lookup : lookup.name;\n  const projectId = typeof lookup === \"string\" ? void 0 : lookup.projectId;\n  const codeComponent = typeof lookup === \"string\" ? void 0 : lookup.isCode;\n  if (codeComponent !== true && namePart.startsWith(\"/\")) {\n    return { path: normalizePath(namePart), projectId };\n  } else {\n    return {\n      name: codeComponent ? namePart : normalizeName(namePart),\n      rawName: namePart.trim(),\n      projectId,\n      isCode: codeComponent\n    };\n  }\n}\nfunction normalizePath(path) {\n  return path.trim();\n}\nfunction normalizeName(name) {\n  return pascalcase__WEBPACK_IMPORTED_MODULE_8___default()(name).trim();\n}\nfunction useIsMounted() {\n  const ref = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n  const isMounted = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(() => ref.current, []);\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n  return isMounted;\n}\nfunction matchesPagePath(pattern, path) {\n  const normalizedPattern = \"/\" + pattern.replace(/^\\/|\\/$/g, \"\");\n  const normalizedPath = \"/\" + path.replace(/^\\/|\\/$/g, \"\");\n  const regexString = normalizedPattern.replace(/\\/\\[\\[\\.\\.\\.([^\\]^]+)]]/g, \"(?:/([^]*))?\").replace(/\\/\\[\\.\\.\\.([^\\]^]+)]/g, \"/([^]*)\").replace(/\\[([^\\]^]+)]/g, \"([^/]+)\").replace(/\\//g, \"\\\\/\");\n  const regex = new RegExp(`^/?${regexString}$`);\n  const match = normalizedPath.match(regex);\n  if (!match)\n    return false;\n  const slugNames = [...pattern.matchAll(/\\[\\.?\\.?\\.?([^[\\]]+)]/g)].map(\n    (m) => m[1]\n  );\n  const params = {};\n  for (let i = 0; i < slugNames.length; i++) {\n    const slugName = slugNames[i];\n    const value = match[i + 1];\n    if (pattern.includes(`[[...${slugName}]]`)) {\n      params[slugName] = value ? value.split(\"/\").filter(Boolean) : [];\n    } else if (pattern.includes(`[...${slugName}]`)) {\n      params[slugName] = value.split(\"/\").filter(Boolean);\n    } else if (value !== void 0) {\n      params[slugName] = value;\n    }\n  }\n  return { params };\n}\nfunction isDynamicPagePath(path) {\n  return !!path.match(/\\[[^/]*\\]/);\n}\nfunction matchesCompMeta(lookup, meta) {\n  if (lookup.projectId && meta.projectId !== lookup.projectId) {\n    return false;\n  }\n  return isNameSpec(lookup) ? (lookup.name === meta.name || lookup.rawName === meta.name || lookup.rawName === meta.displayName) && (lookup.isCode == null || lookup.isCode === meta.isCode) : !!(meta.path && matchesPagePath(meta.path, lookup.path));\n}\nfunction getCompMetas(metas, lookup) {\n  const full = toFullLookup(lookup);\n  return metas.filter((meta) => matchesCompMeta(full, meta)).map(\n    (meta) => {\n      if (isNameSpec(full) || !meta.path) {\n        return meta;\n      }\n      const match = matchesPagePath(meta.path, full.path);\n      if (!match) {\n        return meta;\n      }\n      return __spreadProps(__spreadValues({}, meta), { params: match.params });\n    }\n  ).sort(\n    (meta1, meta2) => (\n      // We sort the matched component metas by the number of path params, so\n      // if there are two pages `/products/foo` and `/products/[slug]`,\n      // the first one will have higher precedence.\n      Array.from(Object.keys(meta1.params || {})).length - Array.from(Object.keys(meta2.params || {})).length\n    )\n  );\n}\nfunction getLookupSpecName(lookup) {\n  if (typeof lookup === \"string\") {\n    return lookup;\n  } else if (lookup.projectId) {\n    return `${lookup.name} (project ${lookup.projectId})`;\n  } else {\n    return lookup.name;\n  }\n}\nfunction MaybeWrap(props) {\n  return props.cond ? props.wrapper(props.children) : props.children;\n}\nfunction uniq(elements) {\n  return Array.from(new Set(elements));\n}\nfunction intersect(a, b) {\n  const setB = new Set(b);\n  return a.filter((elt) => setB.has(elt));\n}\n\n// src/variation.ts\nfunction getPlasmicCookieValues() {\n  return Object.fromEntries(\n    document.cookie.split(\"; \").filter((cookie) => cookie.includes(\"plasmic:\")).map((cookie) => cookie.split(\"=\")).map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\nfunction updatePlasmicCookieValue(key, value) {\n  document.cookie = `plasmic:${key}=${value}`;\n}\nvar getGlobalVariantsFromSplits = (splits, variation) => {\n  const globalVariants = [];\n  Object.keys(variation).map((variationKey) => {\n    const [_type, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split) {\n      const slice = split.slices.find((s) => s.id === sliceId || s.externalId === sliceId);\n      if (slice) {\n        slice.contents.map((x) => {\n          globalVariants.push({\n            name: x.group,\n            value: x.variant,\n            projectId: x.projectId\n          });\n        });\n      }\n    }\n  });\n  return globalVariants;\n};\nvar mergeGlobalVariantsSpec = (target, from) => {\n  let result = [...target];\n  const existingGlobalVariants = new Set(\n    target.map((t) => {\n      var _a;\n      return `${t.name}-${(_a = t.projectId) != null ? _a : \"\"}`;\n    })\n  );\n  const newGlobals = from.filter(\n    (t) => {\n      var _a;\n      return !existingGlobalVariants.has(`${t.name}-${(_a = t.projectId) != null ? _a : \"\"}`);\n    }\n  );\n  if (newGlobals.length > 0) {\n    result = [...result, ...newGlobals];\n  }\n  return result;\n};\n\n// src/PlasmicRootProvider.tsx\nvar PlasmicRootContext = react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction PlasmicRootProvider(props) {\n  const {\n    globalVariants,\n    prefetchedData,\n    children,\n    skipCss,\n    skipFonts,\n    prefetchedQueryData,\n    suspenseForQueryData,\n    globalContextsProps,\n    variation,\n    translator,\n    Head,\n    Link,\n    pageRoute,\n    pageParams,\n    pageQuery,\n    suspenseFallback,\n    disableLoadingBoundary,\n    disableRootLoadingBoundary\n  } = props;\n  const loader = props.loader.__internal;\n  if (prefetchedData) {\n    loader.registerPrefetchedBundle(prefetchedData.bundle);\n  }\n  const [splits, setSplits] = react__WEBPACK_IMPORTED_MODULE_4__.useState(loader.getActiveSplits());\n  const forceUpdate = useForceUpdate();\n  const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(\n    () => ({\n      onDataFetched: () => {\n        setSplits(loader.getActiveSplits());\n        forceUpdate();\n      }\n    }),\n    [loader, forceUpdate]\n  );\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    loader.subscribePlasmicRoot(watcher);\n    return () => loader.unsubscribePlasmicRoot(watcher);\n  }, [watcher, loader]);\n  const currentContextValue = react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n  const { user, userAuthToken, isUserLoading, authRedirectUri } = props;\n  const value = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(() => {\n    var _a, _b, _c;\n    const withCurrentContextValueFallback = (v, key) => {\n      return v !== void 0 ? v : currentContextValue == null ? void 0 : currentContextValue[key];\n    };\n    return {\n      globalVariants: [\n        ...mergeGlobalVariantsSpec(\n          globalVariants != null ? globalVariants : [],\n          getGlobalVariantsFromSplits(splits, variation != null ? variation : {})\n        ),\n        ...(_a = currentContextValue == null ? void 0 : currentContextValue.globalVariants) != null ? _a : []\n      ],\n      globalContextsProps: __spreadValues(__spreadValues({}, (_b = currentContextValue == null ? void 0 : currentContextValue.globalContextsProps) != null ? _b : {}), globalContextsProps != null ? globalContextsProps : {}),\n      loader: withCurrentContextValueFallback(loader, \"loader\"),\n      variation: __spreadValues(__spreadValues({}, (_c = currentContextValue == null ? void 0 : currentContextValue.variation) != null ? _c : {}), variation != null ? variation : {}),\n      translator: withCurrentContextValueFallback(translator, \"translator\"),\n      Head: withCurrentContextValueFallback(Head, \"Head\"),\n      Link: withCurrentContextValueFallback(Link, \"Link\"),\n      user: withCurrentContextValueFallback(user, \"user\"),\n      userAuthToken: withCurrentContextValueFallback(\n        userAuthToken,\n        \"userAuthToken\"\n      ),\n      isUserLoading: withCurrentContextValueFallback(\n        isUserLoading,\n        \"isUserLoading\"\n      ),\n      authRedirectUri: withCurrentContextValueFallback(\n        authRedirectUri,\n        \"authRedirectUri\"\n      ),\n      suspenseFallback: withCurrentContextValueFallback(\n        suspenseFallback,\n        \"suspenseFallback\"\n      ),\n      disableLoadingBoundary: withCurrentContextValueFallback(\n        disableLoadingBoundary,\n        \"disableLoadingBoundary\"\n      )\n    };\n  }, [\n    globalVariants,\n    variation,\n    globalContextsProps,\n    loader,\n    splits,\n    translator,\n    Head,\n    Link,\n    user,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    suspenseFallback,\n    disableLoadingBoundary,\n    currentContextValue\n  ]);\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    loader.trackRender({\n      renderCtx: {\n        // We track the provider as a single entity\n        rootComponentId: \"provider\",\n        teamIds: loader.getTeamIds(),\n        projectIds: loader.getProjectIds()\n      },\n      variation: value.variation\n    });\n  }, [loader, value]);\n  const reactMajorVersion = +react__WEBPACK_IMPORTED_MODULE_4__.version.split(\".\")[0];\n  const shouldDisableRootLoadingBoundary = disableRootLoadingBoundary != null ? disableRootLoadingBoundary : loader.getBundle().disableRootLoadingBoundaryByDefault;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n    _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.PlasmicQueryDataProvider,\n    {\n      prefetchedCache: prefetchedQueryData,\n      suspense: suspenseForQueryData\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicRootContext.Provider, { value }, !skipCss && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n      PlasmicCss,\n      {\n        loader,\n        prefetchedData,\n        skipFonts\n      }\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n      _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider,\n      {\n        route: pageRoute,\n        params: pageParams,\n        query: pageQuery\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n        MaybeWrap,\n        {\n          cond: !shouldDisableRootLoadingBoundary && reactMajorVersion >= 18,\n          wrapper: (contents) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, { fallback: suspenseFallback != null ? suspenseFallback : \"Loading...\" }, contents)\n        },\n        children\n      )\n    ))\n  );\n}\nvar PlasmicCss = react__WEBPACK_IMPORTED_MODULE_4__.memo(function PlasmicCss2(props) {\n  const { loader, prefetchedData, skipFonts } = props;\n  const [useScopedCss, setUseScopedCss] = react__WEBPACK_IMPORTED_MODULE_4__.useState(!!prefetchedData);\n  const builtCss = buildCss(loader, {\n    scopedCompMetas: useScopedCss && prefetchedData ? prefetchedData.bundle.components : void 0,\n    skipFonts\n  });\n  const forceUpdate = useForceUpdate();\n  const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(\n    () => ({\n      onDataFetched: () => {\n        setUseScopedCss(false);\n        forceUpdate();\n      }\n    }),\n    [loader, forceUpdate]\n  );\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    loader.subscribePlasmicRoot(watcher);\n    return () => loader.unsubscribePlasmicRoot(watcher);\n  }, [watcher, loader]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"style\", { dangerouslySetInnerHTML: { __html: builtCss } });\n});\nfunction buildCss(loader, opts) {\n  const { scopedCompMetas, skipFonts } = opts;\n  const cssFiles = scopedCompMetas && /* @__PURE__ */ new Set([\n    \"entrypoint.css\",\n    ...scopedCompMetas.map((c) => c.cssFile)\n  ]);\n  const cssModules = loader.getLookup().getCss().filter((f) => !cssFiles || cssFiles.has(f.fileName));\n  const getPri = (fileName) => fileName === \"entrypoint.css\" ? 0 : 1;\n  const compareModules = (a, b) => getPri(a.fileName) !== getPri(b.fileName) ? getPri(a.fileName) - getPri(b.fileName) : a.fileName.localeCompare(b.fileName);\n  cssModules.sort(compareModules);\n  const remoteFonts = loader.getLookup().getRemoteFonts();\n  return `\n    ${skipFonts ? \"\" : remoteFonts.map((f) => `@import url('${f.url}');`).join(\"\\n\")}\n    ${cssModules.map((mod) => mod.source).join(\"\\n\")}\n  `;\n}\nfunction usePlasmicRootContext() {\n  return react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n}\n\n// src/global-variants.ts\nfunction createUseGlobalVariant(name, projectId) {\n  return () => {\n    var _a;\n    const rootContext = usePlasmicRootContext();\n    if (!rootContext) {\n      return void 0;\n    }\n    const loader = rootContext.loader;\n    const spec = [\n      ...loader.getGlobalVariants(),\n      ...(_a = rootContext.globalVariants) != null ? _a : []\n    ].find(\n      (spec2) => spec2.name === name && (!spec2.projectId || spec2.projectId === projectId)\n    );\n    return spec ? spec.value : void 0;\n  };\n}\n\n// src/loader-shared.ts\n\n\n\n\n// src/bundles.ts\n\nfunction getUsedComps(allComponents, entryCompIds) {\n  const q = [...entryCompIds];\n  const seenIds = new Set(entryCompIds);\n  const componentMetaById = new Map(\n    allComponents.map((meta) => [meta.id, meta])\n  );\n  const usedComps = [];\n  while (q.length > 0) {\n    const [id] = q.splice(0, 1);\n    const meta = componentMetaById.get(id);\n    if (!meta) {\n      continue;\n    }\n    usedComps.push(meta);\n    meta.usedComponents.forEach((usedCompId) => {\n      if (!seenIds.has(usedCompId)) {\n        seenIds.add(usedCompId);\n        q.push(usedCompId);\n      }\n    });\n  }\n  return usedComps;\n}\nfunction prepComponentData(bundle, compMetas, opts) {\n  if (compMetas.length === 0) {\n    return {\n      entryCompMetas: bundle.components,\n      bundle,\n      remoteFontUrls: []\n    };\n  }\n  const usedComps = getUsedComps(\n    bundle.components,\n    compMetas.map((compMeta) => compMeta.id)\n  );\n  const compPaths = usedComps.map((compMeta) => compMeta.entry);\n  const subBundle = (0,_plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.getBundleSubset)(\n    bundle,\n    [\n      \"entrypoint.css\",\n      ...compPaths,\n      \"root-provider.js\",\n      ...bundle.projects.map((x) => x.globalContextsProviderFileName).filter((x) => !!x),\n      // We need to explicitly include global context provider components\n      // to make sure they are kept in bundle.components. That's because\n      // for esbuild, just the globalContextsProviderFileName is not enough,\n      // because it will import a chunk that includes the global context\n      // component, instead of importing that global context component's\n      // entry file. And because nothing depends on the global context component's\n      // entry file, we end up excluding the global context component from\n      // bundle.components, which then makes its substitution not work.\n      // Instead, we forcibly include it here (we'll definitely need it anyway!).\n      ...bundle.components.filter((c) => c.isGlobalContextProvider).map((c) => c.entry),\n      ...bundle.globalGroups.map((g) => g.contextFile)\n    ],\n    opts\n  );\n  const remoteFontUrls = [];\n  subBundle.projects.forEach(\n    (p) => remoteFontUrls.push(...p.remoteFonts.map((f) => f.url))\n  );\n  return {\n    entryCompMetas: compMetas,\n    bundle: subBundle,\n    remoteFontUrls\n  };\n}\nfunction mergeBundles(target, from) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const existingProjects = new Set(target.projects.map((p) => p.id));\n  const newProjects = from.projects.filter((p) => !existingProjects.has(p.id));\n  if (newProjects.length > 0) {\n    target = __spreadProps(__spreadValues({}, target), {\n      projects: [...target.projects, ...newProjects]\n    });\n  }\n  const existingCompIds = new Set(target.components.map((c) => c.id));\n  function shouldIncludeComponentInBundle(c) {\n    var _a2;\n    if (existingCompIds.has(c.id)) {\n      return false;\n    }\n    if (!existingProjects.has(c.projectId)) {\n      return true;\n    }\n    const targetBundleFilteredIds = (_a2 = target.filteredIds[c.projectId]) != null ? _a2 : [];\n    return targetBundleFilteredIds.includes(c.id);\n  }\n  const newCompMetas = from.components.filter(\n    (m) => shouldIncludeComponentInBundle(m)\n  );\n  if (newCompMetas.length > 0) {\n    target = __spreadProps(__spreadValues({}, target), {\n      components: [...target.components, ...newCompMetas]\n    });\n    target.filteredIds = Object.fromEntries(\n      Object.entries(target.filteredIds).map(([k, v]) => [k, [...v]])\n    );\n    from.projects.forEach((fromProject) => {\n      var _a2, _b2;\n      const projectId = fromProject.id;\n      const fromBundleFilteredIds = (_a2 = from.filteredIds[projectId]) != null ? _a2 : [];\n      if (!existingProjects.has(projectId)) {\n        target.filteredIds[projectId] = [...fromBundleFilteredIds];\n      } else {\n        target.filteredIds[projectId] = intersect(\n          (_b2 = target.filteredIds[projectId]) != null ? _b2 : [],\n          fromBundleFilteredIds\n        );\n      }\n    });\n  }\n  const existingModules = {\n    browser: new Set(target.modules.browser.map((m) => m.fileName)),\n    server: new Set(target.modules.server.map((m) => m.fileName))\n  };\n  const newModules = {\n    browser: from.modules.browser.filter(\n      (m) => !existingModules.browser.has(m.fileName)\n    ),\n    server: from.modules.server.filter(\n      (m) => !existingModules.server.has(m.fileName)\n    )\n  };\n  if (newModules.browser.length > 0 || newModules.server.length > 0) {\n    target = __spreadProps(__spreadValues({}, target), {\n      modules: {\n        browser: [...target.modules.browser, ...newModules.browser],\n        server: [...target.modules.server, ...newModules.server]\n      }\n    });\n  }\n  const existingGlobalIds = new Set(target.globalGroups.map((g) => g.id));\n  const newGlobals = from.globalGroups.filter(\n    (g) => !existingGlobalIds.has(g.id)\n  );\n  if (newGlobals.length > 0) {\n    target = __spreadProps(__spreadValues({}, target), {\n      globalGroups: [...target.globalGroups, ...newGlobals]\n    });\n  }\n  const existingSplitIds = new Set(target.activeSplits.map((s) => s.id));\n  const newSplits = (_a = from.activeSplits.filter(\n    // Don't include splits belonging to projects already present\n    // in the target bundle\n    (s) => !existingSplitIds.has(s.id) && !existingProjects.has(s.projectId)\n  )) != null ? _a : [];\n  if (newSplits.length > 0) {\n    target = __spreadProps(__spreadValues({}, target), {\n      activeSplits: [...target.activeSplits, ...newSplits]\n    });\n  }\n  target.bundleKey = (_c = (_b = target.bundleKey) != null ? _b : from.bundleKey) != null ? _c : null;\n  target.deferChunksByDefault = (_e = (_d = target.deferChunksByDefault) != null ? _d : from.deferChunksByDefault) != null ? _e : false;\n  target.disableRootLoadingBoundaryByDefault = (_g = (_f = target.disableRootLoadingBoundaryByDefault) != null ? _f : from.disableRootLoadingBoundaryByDefault) != null ? _g : false;\n  return target;\n}\nvar convertBundlesToComponentRenderData = (bundles, compMetas) => {\n  if (bundles.length === 0) {\n    return null;\n  }\n  const mergedBundles = bundles.reduce((prev, cur) => mergeBundles(prev, cur));\n  return prepComponentData(mergedBundles, compMetas);\n};\n\n// src/component-lookup.ts\nfunction getFirstCompMeta(metas, lookup) {\n  const filtered = getCompMetas(metas, lookup);\n  return filtered.length === 0 ? void 0 : filtered[0];\n}\nvar ComponentLookup = class {\n  constructor(bundle, registry) {\n    this.bundle = bundle;\n    this.registry = registry;\n  }\n  getComponentMeta(spec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    return compMeta;\n  }\n  getComponent(spec, opts = {}) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (!compMeta) {\n      throw new Error(`Component not found: ${spec}`);\n    }\n    const moduleName = compMeta.entry;\n    if (!this.registry.hasModule(moduleName, opts)) {\n      throw new Error(`Component not yet fetched: ${compMeta.name}`);\n    }\n    const entry = this.registry.load(moduleName, {\n      forceOriginal: opts.forceOriginal\n    });\n    return !opts.forceOriginal && typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n  }\n  hasComponent(spec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (compMeta) {\n      return this.registry.hasModule(compMeta.entry);\n    }\n    return false;\n  }\n  getGlobalContexts() {\n    const customGlobalMetas = this.bundle.globalGroups.filter(\n      (m) => m.type === \"global-user-defined\"\n    );\n    return customGlobalMetas.map((meta) => ({\n      meta,\n      context: this.registry.load(meta.contextFile).default\n    }));\n  }\n  getGlobalContextsProvider(spec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    const projectMeta = compMeta ? this.bundle.projects.find((x) => x.id === compMeta.projectId) : void 0;\n    if (!projectMeta || !projectMeta.globalContextsProviderFileName || !this.registry.hasModule(projectMeta.globalContextsProviderFileName)) {\n      return void 0;\n    }\n    const entry = this.registry.load(\n      projectMeta.globalContextsProviderFileName\n    );\n    return typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n  }\n  getRootProvider() {\n    const entry = this.registry.load(\"root-provider.js\");\n    return entry.default;\n  }\n  getCss() {\n    return this.bundle.modules.browser.filter(\n      (mod) => mod.type === \"asset\" && mod.fileName.endsWith(\"css\")\n    );\n  }\n  getRemoteFonts() {\n    return this.bundle.projects.flatMap((p) => p.remoteFonts);\n  }\n};\n\n// src/loader-shared.ts\nvar SUBSTITUTED_COMPONENTS = {};\nvar REGISTERED_CODE_COMPONENT_HELPERS = {};\nvar SUBSTITUTED_GLOBAL_VARIANT_HOOKS = {};\nvar REGISTERED_CUSTOM_FUNCTIONS = {};\nfunction customFunctionImportAlias(meta) {\n  const customFunctionPrefix = `__fn_`;\n  return meta.namespace ? `${customFunctionPrefix}${meta.namespace}__${meta.name}` : `${customFunctionPrefix}${meta.name}`;\n}\nfunction internalSetRegisteredFunction(fn, meta) {\n  REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;\n}\nfunction parseFetchComponentDataArgs(...args) {\n  let specs;\n  let opts;\n  if (Array.isArray(args[0])) {\n    specs = args[0];\n    opts = args[1];\n  } else {\n    specs = args;\n    opts = void 0;\n  }\n  return { specs, opts };\n}\nvar BaseInternalPlasmicComponentLoader = class {\n  constructor(args) {\n    this.registry = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.Registry();\n    this.globalVariants = [];\n    this.subs = [];\n    this.bundle = {\n      modules: {\n        browser: [],\n        server: []\n      },\n      components: [],\n      globalGroups: [],\n      projects: [],\n      activeSplits: [],\n      bundleKey: null,\n      deferChunksByDefault: false,\n      disableRootLoadingBoundaryByDefault: false,\n      filteredIds: {}\n    };\n    this.opts = args.opts;\n    this.fetcher = args.fetcher;\n    this.tracker = args.tracker;\n    this.onBundleMerged = args.onBundleMerged;\n    this.onBundleFetched = args.onBundleFetched;\n    this.registerModules(args.builtinModules);\n  }\n  maybeGetCompMetas(...specs) {\n    const found = /* @__PURE__ */ new Set();\n    const missing = [];\n    for (const spec of specs) {\n      const filteredMetas = getCompMetas(this.bundle.components, spec);\n      if (filteredMetas.length > 0) {\n        filteredMetas.forEach((meta) => found.add(meta));\n      } else {\n        missing.push(spec);\n      }\n    }\n    return { found: Array.from(found.keys()), missing };\n  }\n  maybeFetchComponentData(...args) {\n    return __async(this, null, function* () {\n      const { specs, opts } = parseFetchComponentDataArgs(...args);\n      const returnWithSpecsToFetch = (specsToFetch) => __async(this, null, function* () {\n        yield this.fetchMissingData({ missingSpecs: specsToFetch });\n        const { found: existingMetas2, missing: missingSpecs2 } = this.maybeGetCompMetas(...specs);\n        if (missingSpecs2.length > 0) {\n          return null;\n        }\n        return prepComponentData(this.bundle, existingMetas2, opts);\n      });\n      if (this.opts.alwaysFresh) {\n        return yield returnWithSpecsToFetch(specs);\n      }\n      const { found: existingMetas, missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n      if (missingSpecs.length === 0) {\n        return prepComponentData(this.bundle, existingMetas, opts);\n      }\n      return yield returnWithSpecsToFetch(missingSpecs);\n    });\n  }\n  fetchComponentData(...args) {\n    return __async(this, null, function* () {\n      const { specs, opts } = parseFetchComponentDataArgs(...args);\n      const data = yield this.maybeFetchComponentData(specs, opts);\n      if (!data) {\n        const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n        throw new Error(\n          `Unable to find components ${missingSpecs.map(getLookupSpecName).join(\", \")}`\n        );\n      }\n      return data;\n    });\n  }\n  fetchPages(opts) {\n    return __async(this, null, function* () {\n      this.maybeReportClientSideFetch(\n        () => `Plasmic: fetching all page metadata in the browser`\n      );\n      const data = yield this.fetchAllData();\n      return data.components.filter(\n        (comp) => comp.isPage && comp.path && ((opts == null ? void 0 : opts.includeDynamicPages) || !isDynamicPagePath(comp.path))\n      );\n    });\n  }\n  fetchComponents() {\n    return __async(this, null, function* () {\n      this.maybeReportClientSideFetch(\n        () => `Plasmic: fetching all component metadata in the browser`\n      );\n      const data = yield this.fetchAllData();\n      return data.components;\n    });\n  }\n  getActiveSplits() {\n    return this.bundle.activeSplits;\n  }\n  getChunksUrl(bundle, modules) {\n    return this.fetcher.getChunksUrl(bundle, modules);\n  }\n  fetchMissingData(opts) {\n    return __async(this, null, function* () {\n      this.maybeReportClientSideFetch(\n        () => `Plasmic: fetching missing components in the browser: ${opts.missingSpecs.map((spec) => getLookupSpecName(spec)).join(\", \")}`\n      );\n      return this.fetchAllData();\n    });\n  }\n  maybeReportClientSideFetch(mkMsg) {\n    if (isBrowser && this.opts.onClientSideFetch) {\n      const msg = mkMsg();\n      if (this.opts.onClientSideFetch === \"warn\") {\n        console.warn(msg);\n      } else {\n        throw new Error(msg);\n      }\n    }\n  }\n  fetchAllData() {\n    return __async(this, null, function* () {\n      var _a;\n      const bundle = yield this.fetcher.fetchAllData();\n      this.tracker.trackFetch();\n      this.mergeBundle(bundle);\n      (_a = this.onBundleFetched) == null ? void 0 : _a.call(this);\n      return bundle;\n    });\n  }\n  mergeBundle(newBundle) {\n    var _a, _b;\n    newBundle.bundleKey = (_a = newBundle.bundleKey) != null ? _a : null;\n    if (newBundle.bundleKey && this.bundle.bundleKey && newBundle.bundleKey !== this.bundle.bundleKey) {\n      console.warn(\n        `Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.\nConflicting values:\n${newBundle.bundleKey}\n${this.bundle.bundleKey}`\n      );\n    }\n    this.bundle = mergeBundles(newBundle, this.bundle);\n    (_b = this.onBundleMerged) == null ? void 0 : _b.call(this);\n  }\n  getBundle() {\n    return this.bundle;\n  }\n  clearCache() {\n    this.bundle = {\n      modules: {\n        browser: [],\n        server: []\n      },\n      components: [],\n      globalGroups: [],\n      projects: [],\n      activeSplits: [],\n      bundleKey: null,\n      deferChunksByDefault: false,\n      disableRootLoadingBoundaryByDefault: false,\n      filteredIds: {}\n    };\n    this.registry.clear();\n  }\n  registerModules(modules) {\n    if (Object.keys(modules).some(\n      (name) => this.registry.getRegisteredModule(name) !== modules[name]\n    )) {\n      if (!this.registry.isEmpty()) {\n        console.warn(\n          \"Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over.\"\n        );\n        this.registry.clear();\n      }\n      for (const key of Object.keys(modules)) {\n        this.registry.register(key, modules[key]);\n      }\n    }\n  }\n  substituteComponent(component, name) {\n    this.internalSubstituteComponent(component, name, void 0);\n  }\n  internalSubstituteComponent(component, name, codeComponentHelpers) {\n    if (!this.isRegistryEmpty()) {\n      console.warn(\n        \"Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over.\"\n      );\n      this.clearRegistry();\n    }\n    this.subs.push({ lookup: name, component, codeComponentHelpers });\n  }\n  refreshRegistry() {\n    for (const sub of this.subs) {\n      const metas = getCompMetas(this.getBundle().components, sub.lookup);\n      metas.forEach((meta) => {\n        SUBSTITUTED_COMPONENTS[meta.id] = sub.component;\n        if (sub.codeComponentHelpers) {\n          REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;\n        }\n      });\n    }\n    this.registry.updateModules(this.getBundle());\n  }\n  isRegistryEmpty() {\n    return this.registry.isEmpty();\n  }\n  clearRegistry() {\n    this.registry.clear();\n  }\n  setGlobalVariants(globalVariants) {\n    this.globalVariants = globalVariants;\n  }\n  getGlobalVariants() {\n    return this.globalVariants;\n  }\n  registerPrefetchedBundle(bundle) {\n    if (!isBrowser) {\n      const cachedBundle = (0,_plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__.internal_getCachedBundleInNodeServer)(this.opts);\n      if (cachedBundle) {\n        this.mergeBundle(cachedBundle);\n      }\n    }\n    this.mergeBundle(bundle);\n  }\n  getLookup() {\n    return new ComponentLookup(this.getBundle(), this.registry);\n  }\n  trackConversion(value = 0) {\n    this.tracker.trackConversion(value);\n  }\n  getActiveVariation(opts) {\n    return __async(this, null, function* () {\n      yield this.fetchComponents();\n      return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getActiveVariation)(__spreadProps(__spreadValues({}, opts), {\n        splits: this.getBundle().activeSplits\n      }));\n    });\n  }\n  getTeamIds() {\n    return uniq(\n      this.getBundle().projects.map(\n        (p) => p.teamId ? `${p.teamId}${p.indirect ? \"@indirect\" : \"\"}` : null\n      ).filter((x) => !!x)\n    );\n  }\n  getProjectIds() {\n    return uniq(\n      this.getBundle().projects.map(\n        (p) => `${p.id}${p.indirect ? \"@indirect\" : \"\"}`\n      )\n    );\n  }\n  trackRender(opts) {\n    this.tracker.trackRender(opts);\n  }\n  loadServerQueriesModule(fileName) {\n    return this.registry.load(fileName);\n  }\n};\nvar PlasmicComponentLoader = class {\n  constructor(internal) {\n    this.warnedRegisterComponent = false;\n    this.__internal = internal;\n  }\n  /**\n   * Sets global variants to be used for all components.  Note that\n   * this is not reactive, and will not re-render all components\n   * already mounted; instead, it should be used to activate global\n   * variants that should always be activated for the lifetime of this\n   * app.  If you'd like to reactively change the global variants,\n   * you should specify them via <PlasmicRootProvider />\n   */\n  setGlobalVariants(globalVariants) {\n    this.__internal.setGlobalVariants(globalVariants);\n  }\n  registerModules(modules) {\n    this.__internal.registerModules(modules);\n  }\n  /**\n   * Register custom components that should be swapped in for\n   * components defined in your project.  You can use this to\n   * swap in / substitute a Plasmic component with a \"real\" component.\n   */\n  substituteComponent(component, name) {\n    this.__internal.substituteComponent(component, name);\n  }\n  registerComponent(component, metaOrName) {\n    if (metaOrName && typeof metaOrName === \"object\" && \"props\" in metaOrName) {\n      this.__internal.registerComponent(component, metaOrName);\n    } else {\n      if ( true && !this.warnedRegisterComponent) {\n        console.warn(\n          `PlasmicLoader: Using deprecated method \\`registerComponent\\` for component substitution. Please consider using \\`substituteComponent\\` instead.`\n        );\n        this.warnedRegisterComponent = true;\n      }\n      this.substituteComponent(component, metaOrName);\n    }\n  }\n  registerFunction(fn, meta) {\n    this.__internal.registerFunction(fn, meta);\n  }\n  registerGlobalContext(context, meta) {\n    this.__internal.registerGlobalContext(context, meta);\n  }\n  registerTrait(trait, meta) {\n    this.__internal.registerTrait(trait, meta);\n  }\n  registerToken(token) {\n    this.__internal.registerToken(token);\n  }\n  fetchComponentData(...args) {\n    return this.__internal.fetchComponentData(...args);\n  }\n  maybeFetchComponentData(...args) {\n    return __async(this, null, function* () {\n      return this.__internal.maybeFetchComponentData(...args);\n    });\n  }\n  /**\n   * Returns all the page component metadata for these projects.\n   */\n  fetchPages(opts) {\n    return __async(this, null, function* () {\n      return this.__internal.fetchPages(opts);\n    });\n  }\n  /**\n   * Returns all components metadata for these projects.\n   */\n  fetchComponents() {\n    return __async(this, null, function* () {\n      return this.__internal.fetchComponents();\n    });\n  }\n  _getActiveVariation(opts) {\n    return __async(this, null, function* () {\n      return this.__internal.getActiveVariation(opts);\n    });\n  }\n  getActiveVariation(opts) {\n    return __async(this, null, function* () {\n      return this._getActiveVariation({\n        traits: opts.traits,\n        getKnownValue: (key) => {\n          if (opts.known) {\n            return opts.known[key];\n          } else {\n            const cookies = getPlasmicCookieValues();\n            return cookies[key];\n          }\n        },\n        updateKnownValue: (key, value) => {\n          if (!opts.known) {\n            updatePlasmicCookieValue(key, value);\n          }\n        }\n      });\n    });\n  }\n  getChunksUrl(bundle, modules) {\n    return this.__internal.getChunksUrl(bundle, modules);\n  }\n  getExternalVariation(variation, filters) {\n    return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getExternalIds)(this.getActiveSplits(), variation, filters);\n  }\n  getActiveSplits() {\n    return this.__internal.getActiveSplits();\n  }\n  trackConversion(value = 0) {\n    this.__internal.trackConversion(value);\n  }\n  clearCache() {\n    return this.__internal.clearCache();\n  }\n  unstable__getServerQueriesData(renderData, $ctx) {\n    return __async(this, null, function* () {\n      if (renderData.entryCompMetas.length === 0) {\n        return {};\n      }\n      const fileName = renderData.entryCompMetas[0].serverQueriesExecFuncFileName;\n      if (!fileName) {\n        return {};\n      }\n      const module = this.__internal.loadServerQueriesModule(fileName);\n      const { executeServerQueries } = module;\n      try {\n        const $serverQueries = yield executeServerQueries($ctx);\n        return $serverQueries;\n      } catch (err) {\n        console.error(\"Error executing server queries function\", err);\n        return {};\n      }\n    });\n  }\n};\n\n// src/loader-client.ts\nvar InternalPlasmicComponentLoader = class extends BaseInternalPlasmicComponentLoader {\n  constructor(opts) {\n    const tracker = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicTracker(__spreadProps(__spreadValues({}, opts), {\n      projectIds: opts.projects.map((p) => p.id)\n    }));\n    super({\n      opts,\n      tracker,\n      fetcher: new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicModulesFetcher(opts),\n      onBundleMerged: () => {\n        this.refreshRegistry();\n      },\n      onBundleFetched: () => {\n        this.roots.forEach((watcher) => {\n          var _a;\n          return (_a = watcher.onDataFetched) == null ? void 0 : _a.call(watcher);\n        });\n      },\n      builtinModules: {\n        react: (react__WEBPACK_IMPORTED_MODULE_4___default()),\n        \"react-dom\": (react_dom__WEBPACK_IMPORTED_MODULE_5___default()),\n        \"react/jsx-runtime\": react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__,\n        \"react/jsx-dev-runtime\": react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__,\n        // Also inject @plasmicapp/query and @plasmicapp/host to use the\n        // same contexts here and in loader-downloaded code.\n        \"@plasmicapp/query\": _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__,\n        \"@plasmicapp/data-sources-context\": _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__,\n        \"@plasmicapp/host\": _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__,\n        \"@plasmicapp/loader-runtime-registry\": {\n          components: SUBSTITUTED_COMPONENTS,\n          globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n          codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,\n          functions: REGISTERED_CUSTOM_FUNCTIONS\n        }\n      }\n    });\n    this.roots = [];\n  }\n  registerComponent(component, meta) {\n    var _a, _b;\n    const stateHelpers = Object.fromEntries(\n      Object.entries((_a = meta.states) != null ? _a : {}).filter(\n        ([_, stateSpec]) => Object.keys(stateSpec).some((key) => _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.includes(key))\n      ).map(([stateName, stateSpec]) => [\n        stateName,\n        Object.fromEntries(\n          _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.filter((key) => key in stateSpec).map((key) => [key, stateSpec[key]])\n        )\n      ])\n    );\n    const helpers = { states: stateHelpers };\n    this.internalSubstituteComponent(\n      component,\n      { name: meta.name, isCode: true },\n      Object.keys(stateHelpers).length > 0 ? helpers : void 0\n    );\n    (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerComponent)(component, __spreadValues(__spreadProps(__spreadValues({}, meta), {\n      // Import path is not used as we will use component substitution\n      importPath: (_b = meta.importPath) != null ? _b : \"\"\n    }), Object.keys(stateHelpers).length > 0 ? {\n      componentHelpers: {\n        helpers,\n        importPath: \"\",\n        importName: \"\"\n      }\n    } : {}));\n  }\n  registerFunction(fn, meta) {\n    var _a;\n    (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerFunction)(fn, __spreadProps(__spreadValues({}, meta), {\n      importPath: (_a = meta.importPath) != null ? _a : \"\"\n    }));\n    internalSetRegisteredFunction(fn, meta);\n  }\n  registerGlobalContext(context, meta) {\n    var _a;\n    this.substituteComponent(context, { name: meta.name, isCode: true });\n    (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerGlobalContext)(context, __spreadProps(__spreadValues({}, meta), {\n      importPath: (_a = meta.importPath) != null ? _a : \"\"\n    }));\n  }\n  registerTrait(trait, meta) {\n    (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerTrait)(trait, meta);\n  }\n  registerToken(token) {\n    (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerToken)(token);\n  }\n  subscribePlasmicRoot(watcher) {\n    this.roots.push(watcher);\n  }\n  unsubscribePlasmicRoot(watcher) {\n    const index = this.roots.indexOf(watcher);\n    if (index >= 0) {\n      this.roots.splice(index, 1);\n    }\n  }\n  refreshRegistry() {\n    for (const globalGroup of this.getBundle().globalGroups) {\n      if (globalGroup.type !== \"global-screen\") {\n        SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] = createUseGlobalVariant(globalGroup.name, globalGroup.projectId);\n      }\n    }\n    super.refreshRegistry();\n  }\n};\n\n// src/index.ts\n\n\n\n// src/PlasmicComponent.tsx\n\n\n// src/usePlasmicComponent.tsx\n\nfunction usePlasmicComponent(spec, opts = {}) {\n  const rootContext = usePlasmicRootContext();\n  if (!rootContext) {\n    throw new Error(\n      `You can only use usePlasmicComponent if wrapped in <PlasmicRootProvider />`\n    );\n  }\n  const loader = rootContext.loader;\n  const lookup = loader.getLookup();\n  const component = lookup.hasComponent(spec) ? lookup.getComponent(spec, opts) : void 0;\n  const stableSpec = useStableLookupSpec(spec);\n  const isMounted = useIsMounted();\n  const forceUpdate = useForceUpdate();\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    if (!component) {\n      (() => __async(this, null, function* () {\n        yield loader.fetchComponentData(stableSpec);\n        if (isMounted()) {\n          forceUpdate();\n        }\n      }))();\n    }\n  }, [component, stableSpec]);\n  return component;\n}\n\n// src/PlasmicComponent.tsx\nvar PlasmicComponentContext = react__WEBPACK_IMPORTED_MODULE_4__.createContext(false);\nfunction PlasmicComponent(props) {\n  const { component, projectId, componentProps, forceOriginal } = props;\n  const rootContext = usePlasmicRootContext();\n  const isRootLoader = !react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicComponentContext);\n  if (!rootContext) {\n    throw new Error(\n      `You must use <PlasmicRootProvider/> at the root of your app`\n    );\n  }\n  const _a = rootContext, {\n    loader,\n    globalContextsProps,\n    variation,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    translator\n  } = _a, rest = __objRest(_a, [\n    \"loader\",\n    \"globalContextsProps\",\n    \"variation\",\n    \"userAuthToken\",\n    \"isUserLoading\",\n    \"authRedirectUri\",\n    \"translator\"\n  ]);\n  const Component = usePlasmicComponent(\n    { name: component, projectId, isCode: false },\n    { forceOriginal }\n  );\n  react__WEBPACK_IMPORTED_MODULE_4__.useEffect(() => {\n    if (isRootLoader) {\n      const meta = loader.getLookup().getComponentMeta({ name: component, projectId });\n      if (meta) {\n        loader.trackRender({\n          renderCtx: {\n            rootProjectId: meta.projectId,\n            rootComponentId: meta.id,\n            rootComponentName: component,\n            teamIds: loader.getTeamIds(),\n            projectIds: loader.getProjectIds()\n          },\n          variation\n        });\n      }\n    }\n  }, [component, projectId, loader, variation]);\n  const element = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(() => {\n    var _a2;\n    if (!Component) {\n      return null;\n    }\n    let elt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(Component, __spreadValues({}, componentProps));\n    if (isRootLoader) {\n      const lookup = loader.getLookup();\n      const ReactWebRootProvider = lookup.getRootProvider();\n      const GlobalContextsProvider = lookup.getGlobalContextsProvider({\n        name: component,\n        projectId\n      });\n      elt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n        ReactWebRootProvider,\n        __spreadProps(__spreadValues({}, rest), {\n          userAuthToken,\n          isUserLoading,\n          authRedirectUri,\n          i18n: {\n            translator,\n            tagPrefix: (_a2 = loader.opts.i18n) == null ? void 0 : _a2.tagPrefix\n          }\n        }),\n        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\n          MaybeWrap,\n          {\n            cond: !!GlobalContextsProvider,\n            wrapper: (children) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(GlobalContextsProvider, __spreadValues({}, globalContextsProps), children)\n          },\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicComponentContext.Provider, { value: true }, elt)\n        )\n      );\n    }\n    return elt;\n  }, [\n    Component,\n    componentProps,\n    loader,\n    isRootLoader,\n    component,\n    projectId,\n    globalContextsProps,\n    userAuthToken,\n    // Just use the token to memo, `user` should be derived from it\n    isUserLoading,\n    authRedirectUri\n  ]);\n  return element;\n}\n\n// src/prepass-client.ts\n\nfunction extractPlasmicQueryData(element) {\n  return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n}\nfunction plasmicPrepass(element) {\n  return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.plasmicPrepass)(element);\n}\n\n// src/render.tsx\n\n\n\n\nfunction renderToElement(_0, _1, _2) {\n  return __async(this, arguments, function* (loader, target, lookup, opts = {}) {\n    return new Promise((resolve) => {\n      const element = makeElement(loader, lookup, opts);\n      react_dom__WEBPACK_IMPORTED_MODULE_5___default().render(element, target, () => resolve());\n    });\n  });\n}\nfunction renderToString(loader, lookup, opts = {}) {\n  const element = makeElement(loader, lookup, opts);\n  return (0,react_dom_server__WEBPACK_IMPORTED_MODULE_12__.renderToString)(element);\n}\nfunction extractPlasmicQueryDataFromElement(_0, _1) {\n  return __async(this, arguments, function* (loader, lookup, opts = {}) {\n    const element = makeElement(loader, lookup, opts);\n    return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n  });\n}\nfunction hydrateFromElement(_0, _1, _2) {\n  return __async(this, arguments, function* (loader, target, lookup, opts = {}) {\n    return new Promise((resolve) => {\n      const element = makeElement(loader, lookup, opts);\n      react_dom__WEBPACK_IMPORTED_MODULE_5___default().hydrate(element, target, () => resolve());\n    });\n  });\n}\nfunction makeElement(loader, lookup, opts = {}) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(\n    PlasmicRootProvider,\n    {\n      loader,\n      prefetchedData: opts.prefetchedData,\n      globalVariants: opts.globalVariants,\n      prefetchedQueryData: opts.prefetchedQueryData,\n      pageParams: opts.pageParams,\n      pageQuery: opts.pageQuery\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(\n      PlasmicComponent,\n      {\n        component: typeof lookup === \"string\" ? lookup : lookup.name,\n        projectId: typeof lookup === \"string\" ? void 0 : lookup.projectId,\n        componentProps: opts.componentProps\n      }\n    )\n  );\n}\n\n// src/index.ts\nfunction initPlasmicLoader(opts) {\n  const internal = new InternalPlasmicComponentLoader(opts);\n  return new PlasmicComponentLoader(internal);\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItcmVhY3QvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzhFO0FBQzlCO0FBUXRCO0FBQ21HO0FBQzNFO0FBQ3ZCO0FBQ007QUFDc0I7QUFDUDs7QUFFaEQ7QUFDc0Q7QUFDTztBQUM3Qjs7QUFFaEM7QUFDb0M7QUFDTDtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLDJDQUFjO0FBQ3BDLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUFjO0FBQ3RELEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0EsY0FBYyx5Q0FBWTtBQUMxQixvQkFBb0IsOENBQWlCO0FBQ3JDLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLE1BQU0saUNBQWlDLFNBQVM7QUFDaEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscURBQXFEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLGFBQWEsV0FBVyxpQkFBaUI7QUFDdkQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxHQUFHLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcscUNBQXFDO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPLEdBQUcscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGdEQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFlO0FBQzdDO0FBQ0Esa0JBQWtCLDBDQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEJBQThCLDZDQUFpQjtBQUMvQyxVQUFVLHNEQUFzRDtBQUNoRSxnQkFBZ0IsMENBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQseUdBQXlHLHlEQUF5RDtBQUM3TjtBQUNBLGlEQUFpRCwrRkFBK0YscUNBQXFDO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCw2QkFBNkIsMENBQWM7QUFDM0M7QUFDQSx5QkFBeUIsZ0RBQW9CO0FBQzdDLElBQUksdUVBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsZ0RBQW9CLGdDQUFnQyxPQUFPLDhCQUE4QixnREFBb0I7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFvQjtBQUMzQyxNQUFNLGdFQUFrQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsZ0RBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnREFBb0IsQ0FBQywyQ0FBZSxJQUFJLHNFQUFzRTtBQUMvSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1Q0FBVztBQUM1QixVQUFVLG9DQUFvQztBQUM5QywwQ0FBMEMsMkNBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBDQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLGdEQUFvQixZQUFZLDJCQUEyQixvQkFBb0I7QUFDeEcsQ0FBQztBQUNEO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdEQUF3RCxNQUFNLEdBQUc7QUFDdkUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQWlCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdpQztBQUdHO0FBQzJDOztBQUUvRTtBQUdpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3RUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCLEVBQUUsZUFBZSxJQUFJLFVBQVUsT0FBTyxxQkFBcUIsRUFBRSxVQUFVO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEUsZ0JBQWdCLGdEQUFnRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQSx1Q0FBdUMsK0NBQStDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG9FQUFvRTtBQUMxSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFLHNCQUFzQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnR0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RUFBa0IsZ0NBQWdDO0FBQy9EO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTLEVBQUUsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEVBQUUsOEJBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxLQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBFQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlLGdDQUFnQztBQUN2RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEVBQXNCO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsZUFBZSw4Q0FBTTtBQUNyQixxQkFBcUIsa0RBQVE7QUFDN0IsNkJBQTZCLDhDQUFVO0FBQ3ZDLGlDQUFpQyxrREFBYTtBQUM5QztBQUNBO0FBQ0EsNkJBQTZCLDhDQUFZO0FBQ3pDLDRDQUE0Qyw2REFBeUI7QUFDckUsNEJBQTRCLDZDQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsaUVBQWlFLDhEQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJLG1FQUFpQiwwREFBMEQ7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRUFBZ0Isb0NBQW9DO0FBQ3hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RSxJQUFJLHVFQUFxQix5Q0FBeUM7QUFDbEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksK0RBQWE7QUFDakI7QUFDQTtBQUNBLElBQUksK0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFnQjBCO0FBQzhCOztBQUV4RDtBQUNnQzs7QUFFaEM7QUFDZ0M7QUFDaEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGdEQUFvQjtBQUNsRDtBQUNBLFVBQVUsc0RBQXNEO0FBQ2hFO0FBQ0Esd0JBQXdCLDZDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUEyQztBQUNqRCxNQUFNO0FBQ047QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBLHlEQUF5RCw0QkFBNEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiwwQ0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnREFBb0IsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEIsZ0RBQW9CO0FBQ2hEO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QixnREFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdEQUFvQiwwQ0FBMEM7QUFDakgsV0FBVztBQUNYLDBCQUEwQixnREFBb0IscUNBQXFDLGFBQWE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUk2QjtBQUM3QjtBQUNBLFNBQVMsNkVBQXdCO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLG9FQUFzQjtBQUMvQjs7QUFFQTtBQUMwRjtBQUMvRDtBQUNPO0FBQ3VDO0FBQ3pFO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxNQUFNLHVEQUFnQjtBQUN0QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsU0FBUyxpRUFBbUI7QUFDNUI7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLFdBQVcsNkVBQXdCO0FBQ25DLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxNQUFNLHdEQUFpQjtBQUN2QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsOENBQThDO0FBQzlDLHlCQUF5QiwwREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMERBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK0JFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcQHBsYXNtaWNhcHBcXGxvYWRlci1yZWFjdFxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9sb2FkZXItY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBQbGFzbWljRGF0YVNvdXJjZXNDb250ZXh0IGZyb20gXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiO1xuaW1wb3J0ICogYXMgUGxhc21pY0hvc3QgZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7XG4gIHJlZ2lzdGVyQ29tcG9uZW50LFxuICByZWdpc3RlckZ1bmN0aW9uLFxuICByZWdpc3Rlckdsb2JhbENvbnRleHQsXG4gIHJlZ2lzdGVyVG9rZW4sXG4gIHJlZ2lzdGVyVHJhaXQsXG4gIHN0YXRlSGVscGVyc0tleXNcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7IFBsYXNtaWNNb2R1bGVzRmV0Y2hlciBhcyBQbGFzbWljTW9kdWxlc0ZldGNoZXIyLCBQbGFzbWljVHJhY2tlciBhcyBQbGFzbWljVHJhY2tlcjIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmVcIjtcbmltcG9ydCAqIGFzIFBsYXNtaWNRdWVyeSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0ICogYXMganN4RGV2UnVudGltZSBmcm9tIFwicmVhY3QvanN4LWRldi1ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBqc3hSdW50aW1lIGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuXG4vLyBzcmMvUGxhc21pY1Jvb3RQcm92aWRlci50c3hcbmltcG9ydCB7IFBhZ2VQYXJhbXNQcm92aWRlciB9IGZyb20gXCJAcGxhc21pY2FwcC9ob3N0XCI7XG5pbXBvcnQgeyBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3V0aWxzLnRzeFxuaW1wb3J0IHBhc2NhbGNhc2UgZnJvbSBcInBhc2NhbGNhc2VcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgY29uc3QgWywgc2V0VGlja10gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgY29uc3QgdXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFRpY2soKHRpY2spID0+IHRpY2sgKyAxKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gdXNlU3RhYmxlTG9va3VwU3BlYyhzcGVjKSB7XG4gIHJldHVybiB1c2VTdGFibGVMb29rdXBTcGVjcyhzcGVjKVswXTtcbn1cbmZ1bmN0aW9uIHVzZVN0YWJsZUxvb2t1cFNwZWNzKC4uLnNwZWNzKSB7XG4gIGNvbnN0IFtzdGFibGVTcGVjcywgc2V0U3RhYmxlU3BlY3NdID0gUmVhY3QudXNlU3RhdGUoc3BlY3MpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzcGVjcy5sZW5ndGggIT09IHN0YWJsZVNwZWNzLmxlbmd0aCB8fCBzcGVjcy5zb21lKChzLCBpKSA9PiAhYXJlTG9va3VwU3BlY3NFcXVhbChzLCBzdGFibGVTcGVjc1tpXSkpKSB7XG4gICAgICBzZXRTdGFibGVTcGVjcyhzcGVjcyk7XG4gICAgfVxuICB9LCBbc3BlY3MsIHN0YWJsZVNwZWNzXSk7XG4gIHJldHVybiBzdGFibGVTcGVjcztcbn1cbmZ1bmN0aW9uIGFyZUxvb2t1cFNwZWNzRXF1YWwoc3BlYzEsIHNwZWMyKSB7XG4gIGlmIChzcGVjMSA9PT0gc3BlYzIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHNwZWMxICE9PSB0eXBlb2Ygc3BlYzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZnVsbFNwZWMxID0gdG9GdWxsTG9va3VwKHNwZWMxKTtcbiAgY29uc3QgZnVsbFNwZWMyID0gdG9GdWxsTG9va3VwKHNwZWMyKTtcbiAgcmV0dXJuIChpc05hbWVTcGVjKGZ1bGxTcGVjMSkgJiYgaXNOYW1lU3BlYyhmdWxsU3BlYzIpICYmIGZ1bGxTcGVjMS5uYW1lID09PSBmdWxsU3BlYzIubmFtZSAmJiBmdWxsU3BlYzEuaXNDb2RlID09PSBmdWxsU3BlYzIuaXNDb2RlIHx8IGlzUGF0aFNwZWMoZnVsbFNwZWMxKSAmJiBpc1BhdGhTcGVjKGZ1bGxTcGVjMikgJiYgZnVsbFNwZWMxLnBhdGggPT09IGZ1bGxTcGVjMi5wYXRoKSAmJiBmdWxsU3BlYzEucHJvamVjdElkID09PSBmdWxsU3BlYzIucHJvamVjdElkO1xufVxuZnVuY3Rpb24gaXNOYW1lU3BlYyhsb29rdXApIHtcbiAgcmV0dXJuIFwibmFtZVwiIGluIGxvb2t1cDtcbn1cbmZ1bmN0aW9uIGlzUGF0aFNwZWMobG9va3VwKSB7XG4gIHJldHVybiBcInBhdGhcIiBpbiBsb29rdXA7XG59XG5mdW5jdGlvbiB0b0Z1bGxMb29rdXAobG9va3VwKSB7XG4gIGNvbnN0IG5hbWVQYXJ0ID0gdHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIiA/IGxvb2t1cCA6IGxvb2t1cC5uYW1lO1xuICBjb25zdCBwcm9qZWN0SWQgPSB0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gdm9pZCAwIDogbG9va3VwLnByb2plY3RJZDtcbiAgY29uc3QgY29kZUNvbXBvbmVudCA9IHR5cGVvZiBsb29rdXAgPT09IFwic3RyaW5nXCIgPyB2b2lkIDAgOiBsb29rdXAuaXNDb2RlO1xuICBpZiAoY29kZUNvbXBvbmVudCAhPT0gdHJ1ZSAmJiBuYW1lUGFydC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB7IHBhdGg6IG5vcm1hbGl6ZVBhdGgobmFtZVBhcnQpLCBwcm9qZWN0SWQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY29kZUNvbXBvbmVudCA/IG5hbWVQYXJ0IDogbm9ybWFsaXplTmFtZShuYW1lUGFydCksXG4gICAgICByYXdOYW1lOiBuYW1lUGFydC50cmltKCksXG4gICAgICBwcm9qZWN0SWQsXG4gICAgICBpc0NvZGU6IGNvZGVDb21wb25lbnRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIHJldHVybiBwYXNjYWxjYXNlKG5hbWUpLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gaXNNb3VudGVkO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1BhZ2VQYXRoKHBhdHRlcm4sIHBhdGgpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdHRlcm4gPSBcIi9cIiArIHBhdHRlcm4ucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpO1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IFwiL1wiICsgcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7XG4gIGNvbnN0IHJlZ2V4U3RyaW5nID0gbm9ybWFsaXplZFBhdHRlcm4ucmVwbGFjZSgvXFwvXFxbXFxbXFwuXFwuXFwuKFteXFxdXl0rKV1dL2csIFwiKD86LyhbXl0qKSk/XCIpLnJlcGxhY2UoL1xcL1xcW1xcLlxcLlxcLihbXlxcXV5dKyldL2csIFwiLyhbXl0qKVwiKS5yZXBsYWNlKC9cXFsoW15cXF1eXSspXS9nLCBcIihbXi9dKylcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIik7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXi8/JHtyZWdleFN0cmluZ30kYCk7XG4gIGNvbnN0IG1hdGNoID0gbm9ybWFsaXplZFBhdGgubWF0Y2gocmVnZXgpO1xuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc2x1Z05hbWVzID0gWy4uLnBhdHRlcm4ubWF0Y2hBbGwoL1xcW1xcLj9cXC4/XFwuPyhbXltcXF1dKyldL2cpXS5tYXAoXG4gICAgKG0pID0+IG1bMV1cbiAgKTtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2x1Z05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2x1Z05hbWUgPSBzbHVnTmFtZXNbaV07XG4gICAgY29uc3QgdmFsdWUgPSBtYXRjaFtpICsgMV07XG4gICAgaWYgKHBhdHRlcm4uaW5jbHVkZXMoYFtbLi4uJHtzbHVnTmFtZX1dXWApKSB7XG4gICAgICBwYXJhbXNbc2x1Z05hbWVdID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLmluY2x1ZGVzKGBbLi4uJHtzbHVnTmFtZX1dYCkpIHtcbiAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB2YWx1ZS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBwYXJhbXMgfTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pY1BhZ2VQYXRoKHBhdGgpIHtcbiAgcmV0dXJuICEhcGF0aC5tYXRjaCgvXFxbW14vXSpcXF0vKTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNDb21wTWV0YShsb29rdXAsIG1ldGEpIHtcbiAgaWYgKGxvb2t1cC5wcm9qZWN0SWQgJiYgbWV0YS5wcm9qZWN0SWQgIT09IGxvb2t1cC5wcm9qZWN0SWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTmFtZVNwZWMobG9va3VwKSA/IChsb29rdXAubmFtZSA9PT0gbWV0YS5uYW1lIHx8IGxvb2t1cC5yYXdOYW1lID09PSBtZXRhLm5hbWUgfHwgbG9va3VwLnJhd05hbWUgPT09IG1ldGEuZGlzcGxheU5hbWUpICYmIChsb29rdXAuaXNDb2RlID09IG51bGwgfHwgbG9va3VwLmlzQ29kZSA9PT0gbWV0YS5pc0NvZGUpIDogISEobWV0YS5wYXRoICYmIG1hdGNoZXNQYWdlUGF0aChtZXRhLnBhdGgsIGxvb2t1cC5wYXRoKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wTWV0YXMobWV0YXMsIGxvb2t1cCkge1xuICBjb25zdCBmdWxsID0gdG9GdWxsTG9va3VwKGxvb2t1cCk7XG4gIHJldHVybiBtZXRhcy5maWx0ZXIoKG1ldGEpID0+IG1hdGNoZXNDb21wTWV0YShmdWxsLCBtZXRhKSkubWFwKFxuICAgIChtZXRhKSA9PiB7XG4gICAgICBpZiAoaXNOYW1lU3BlYyhmdWxsKSB8fCAhbWV0YS5wYXRoKSB7XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzUGFnZVBhdGgobWV0YS5wYXRoLCBmdWxsLnBhdGgpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhKSwgeyBwYXJhbXM6IG1hdGNoLnBhcmFtcyB9KTtcbiAgICB9XG4gICkuc29ydChcbiAgICAobWV0YTEsIG1ldGEyKSA9PiAoXG4gICAgICAvLyBXZSBzb3J0IHRoZSBtYXRjaGVkIGNvbXBvbmVudCBtZXRhcyBieSB0aGUgbnVtYmVyIG9mIHBhdGggcGFyYW1zLCBzb1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIHR3byBwYWdlcyBgL3Byb2R1Y3RzL2Zvb2AgYW5kIGAvcHJvZHVjdHMvW3NsdWddYCxcbiAgICAgIC8vIHRoZSBmaXJzdCBvbmUgd2lsbCBoYXZlIGhpZ2hlciBwcmVjZWRlbmNlLlxuICAgICAgQXJyYXkuZnJvbShPYmplY3Qua2V5cyhtZXRhMS5wYXJhbXMgfHwge30pKS5sZW5ndGggLSBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG1ldGEyLnBhcmFtcyB8fCB7fSkpLmxlbmd0aFxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldExvb2t1cFNwZWNOYW1lKGxvb2t1cCkge1xuICBpZiAodHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBsb29rdXA7XG4gIH0gZWxzZSBpZiAobG9va3VwLnByb2plY3RJZCkge1xuICAgIHJldHVybiBgJHtsb29rdXAubmFtZX0gKHByb2plY3QgJHtsb29rdXAucHJvamVjdElkfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb29rdXAubmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gTWF5YmVXcmFwKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5jb25kID8gcHJvcHMud3JhcHBlcihwcm9wcy5jaGlsZHJlbikgOiBwcm9wcy5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHVuaXEoZWxlbWVudHMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChlbGVtZW50cykpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIpIHtcbiAgY29uc3Qgc2V0QiA9IG5ldyBTZXQoYik7XG4gIHJldHVybiBhLmZpbHRlcigoZWx0KSA9PiBzZXRCLmhhcyhlbHQpKTtcbn1cblxuLy8gc3JjL3ZhcmlhdGlvbi50c1xuZnVuY3Rpb24gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKS5maWx0ZXIoKGNvb2tpZSkgPT4gY29va2llLmluY2x1ZGVzKFwicGxhc21pYzpcIikpLm1hcCgoY29va2llKSA9PiBjb29raWUuc3BsaXQoXCI9XCIpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleS5zcGxpdChcIjpcIilbMV0sIHZhbHVlXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBsYXNtaWNDb29raWVWYWx1ZShrZXksIHZhbHVlKSB7XG4gIGRvY3VtZW50LmNvb2tpZSA9IGBwbGFzbWljOiR7a2V5fT0ke3ZhbHVlfWA7XG59XG52YXIgZ2V0R2xvYmFsVmFyaWFudHNGcm9tU3BsaXRzID0gKHNwbGl0cywgdmFyaWF0aW9uKSA9PiB7XG4gIGNvbnN0IGdsb2JhbFZhcmlhbnRzID0gW107XG4gIE9iamVjdC5rZXlzKHZhcmlhdGlvbikubWFwKCh2YXJpYXRpb25LZXkpID0+IHtcbiAgICBjb25zdCBbX3R5cGUsIHNwbGl0SWRdID0gdmFyaWF0aW9uS2V5LnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBzbGljZUlkID0gdmFyaWF0aW9uW3ZhcmlhdGlvbktleV07XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdHMuZmluZChcbiAgICAgIChzKSA9PiBzLmlkID09PSBzcGxpdElkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc3BsaXRJZFxuICAgICk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBjb25zdCBzbGljZSA9IHNwbGl0LnNsaWNlcy5maW5kKChzKSA9PiBzLmlkID09PSBzbGljZUlkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc2xpY2VJZCk7XG4gICAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgc2xpY2UuY29udGVudHMubWFwKCh4KSA9PiB7XG4gICAgICAgICAgZ2xvYmFsVmFyaWFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiB4Lmdyb3VwLFxuICAgICAgICAgICAgdmFsdWU6IHgudmFyaWFudCxcbiAgICAgICAgICAgIHByb2plY3RJZDogeC5wcm9qZWN0SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGdsb2JhbFZhcmlhbnRzO1xufTtcbnZhciBtZXJnZUdsb2JhbFZhcmlhbnRzU3BlYyA9ICh0YXJnZXQsIGZyb20pID0+IHtcbiAgbGV0IHJlc3VsdCA9IFsuLi50YXJnZXRdO1xuICBjb25zdCBleGlzdGluZ0dsb2JhbFZhcmlhbnRzID0gbmV3IFNldChcbiAgICB0YXJnZXQubWFwKCh0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gYCR7dC5uYW1lfS0keyhfYSA9IHQucHJvamVjdElkKSAhPSBudWxsID8gX2EgOiBcIlwifWA7XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgbmV3R2xvYmFscyA9IGZyb20uZmlsdGVyKFxuICAgICh0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gIWV4aXN0aW5nR2xvYmFsVmFyaWFudHMuaGFzKGAke3QubmFtZX0tJHsoX2EgPSB0LnByb2plY3RJZCkgIT0gbnVsbCA/IF9hIDogXCJcIn1gKTtcbiAgICB9XG4gICk7XG4gIGlmIChuZXdHbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgPSBbLi4ucmVzdWx0LCAuLi5uZXdHbG9iYWxzXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gc3JjL1BsYXNtaWNSb290UHJvdmlkZXIudHN4XG52YXIgUGxhc21pY1Jvb3RDb250ZXh0ID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIFBsYXNtaWNSb290UHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGdsb2JhbFZhcmlhbnRzLFxuICAgIHByZWZldGNoZWREYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIHNraXBDc3MsXG4gICAgc2tpcEZvbnRzLFxuICAgIHByZWZldGNoZWRRdWVyeURhdGEsXG4gICAgc3VzcGVuc2VGb3JRdWVyeURhdGEsXG4gICAgZ2xvYmFsQ29udGV4dHNQcm9wcyxcbiAgICB2YXJpYXRpb24sXG4gICAgdHJhbnNsYXRvcixcbiAgICBIZWFkLFxuICAgIExpbmssXG4gICAgcGFnZVJvdXRlLFxuICAgIHBhZ2VQYXJhbXMsXG4gICAgcGFnZVF1ZXJ5LFxuICAgIHN1c3BlbnNlRmFsbGJhY2ssXG4gICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeSxcbiAgICBkaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxvYWRlciA9IHByb3BzLmxvYWRlci5fX2ludGVybmFsO1xuICBpZiAocHJlZmV0Y2hlZERhdGEpIHtcbiAgICBsb2FkZXIucmVnaXN0ZXJQcmVmZXRjaGVkQnVuZGxlKHByZWZldGNoZWREYXRhLmJ1bmRsZSk7XG4gIH1cbiAgY29uc3QgW3NwbGl0cywgc2V0U3BsaXRzXSA9IFJlYWN0Mi51c2VTdGF0ZShsb2FkZXIuZ2V0QWN0aXZlU3BsaXRzKCkpO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHdhdGNoZXIgPSBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgb25EYXRhRmV0Y2hlZDogKCkgPT4ge1xuICAgICAgICBzZXRTcGxpdHMobG9hZGVyLmdldEFjdGl2ZVNwbGl0cygpKTtcbiAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBbbG9hZGVyLCBmb3JjZVVwZGF0ZV1cbiAgKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZGVyLnN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXIpO1xuICAgIHJldHVybiAoKSA9PiBsb2FkZXIudW5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyKTtcbiAgfSwgW3dhdGNoZXIsIGxvYWRlcl0pO1xuICBjb25zdCBjdXJyZW50Q29udGV4dFZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoUGxhc21pY1Jvb3RDb250ZXh0KTtcbiAgY29uc3QgeyB1c2VyLCB1c2VyQXV0aFRva2VuLCBpc1VzZXJMb2FkaW5nLCBhdXRoUmVkaXJlY3RVcmkgfSA9IHByb3BzO1xuICBjb25zdCB2YWx1ZSA9IFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrID0gKHYsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHYgIT09IHZvaWQgMCA/IHYgOiBjdXJyZW50Q29udGV4dFZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Q29udGV4dFZhbHVlW2tleV07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2xvYmFsVmFyaWFudHM6IFtcbiAgICAgICAgLi4ubWVyZ2VHbG9iYWxWYXJpYW50c1NwZWMoXG4gICAgICAgICAgZ2xvYmFsVmFyaWFudHMgIT0gbnVsbCA/IGdsb2JhbFZhcmlhbnRzIDogW10sXG4gICAgICAgICAgZ2V0R2xvYmFsVmFyaWFudHNGcm9tU3BsaXRzKHNwbGl0cywgdmFyaWF0aW9uICE9IG51bGwgPyB2YXJpYXRpb24gOiB7fSlcbiAgICAgICAgKSxcbiAgICAgICAgLi4uKF9hID0gY3VycmVudENvbnRleHRWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvbnRleHRWYWx1ZS5nbG9iYWxWYXJpYW50cykgIT0gbnVsbCA/IF9hIDogW11cbiAgICAgIF0sXG4gICAgICBnbG9iYWxDb250ZXh0c1Byb3BzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgKF9iID0gY3VycmVudENvbnRleHRWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvbnRleHRWYWx1ZS5nbG9iYWxDb250ZXh0c1Byb3BzKSAhPSBudWxsID8gX2IgOiB7fSksIGdsb2JhbENvbnRleHRzUHJvcHMgIT0gbnVsbCA/IGdsb2JhbENvbnRleHRzUHJvcHMgOiB7fSksXG4gICAgICBsb2FkZXI6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2sobG9hZGVyLCBcImxvYWRlclwiKSxcbiAgICAgIHZhcmlhdGlvbjogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIChfYyA9IGN1cnJlbnRDb250ZXh0VmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRDb250ZXh0VmFsdWUudmFyaWF0aW9uKSAhPSBudWxsID8gX2MgOiB7fSksIHZhcmlhdGlvbiAhPSBudWxsID8gdmFyaWF0aW9uIDoge30pLFxuICAgICAgdHJhbnNsYXRvcjogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayh0cmFuc2xhdG9yLCBcInRyYW5zbGF0b3JcIiksXG4gICAgICBIZWFkOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKEhlYWQsIFwiSGVhZFwiKSxcbiAgICAgIExpbms6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soTGluaywgXCJMaW5rXCIpLFxuICAgICAgdXNlcjogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayh1c2VyLCBcInVzZXJcIiksXG4gICAgICB1c2VyQXV0aFRva2VuOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKFxuICAgICAgICB1c2VyQXV0aFRva2VuLFxuICAgICAgICBcInVzZXJBdXRoVG9rZW5cIlxuICAgICAgKSxcbiAgICAgIGlzVXNlckxvYWRpbmc6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soXG4gICAgICAgIGlzVXNlckxvYWRpbmcsXG4gICAgICAgIFwiaXNVc2VyTG9hZGluZ1wiXG4gICAgICApLFxuICAgICAgYXV0aFJlZGlyZWN0VXJpOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKFxuICAgICAgICBhdXRoUmVkaXJlY3RVcmksXG4gICAgICAgIFwiYXV0aFJlZGlyZWN0VXJpXCJcbiAgICAgICksXG4gICAgICBzdXNwZW5zZUZhbGxiYWNrOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKFxuICAgICAgICBzdXNwZW5zZUZhbGxiYWNrLFxuICAgICAgICBcInN1c3BlbnNlRmFsbGJhY2tcIlxuICAgICAgKSxcbiAgICAgIGRpc2FibGVMb2FkaW5nQm91bmRhcnk6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soXG4gICAgICAgIGRpc2FibGVMb2FkaW5nQm91bmRhcnksXG4gICAgICAgIFwiZGlzYWJsZUxvYWRpbmdCb3VuZGFyeVwiXG4gICAgICApXG4gICAgfTtcbiAgfSwgW1xuICAgIGdsb2JhbFZhcmlhbnRzLFxuICAgIHZhcmlhdGlvbixcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIGxvYWRlcixcbiAgICBzcGxpdHMsXG4gICAgdHJhbnNsYXRvcixcbiAgICBIZWFkLFxuICAgIExpbmssXG4gICAgdXNlcixcbiAgICB1c2VyQXV0aFRva2VuLFxuICAgIGlzVXNlckxvYWRpbmcsXG4gICAgYXV0aFJlZGlyZWN0VXJpLFxuICAgIHN1c3BlbnNlRmFsbGJhY2ssXG4gICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeSxcbiAgICBjdXJyZW50Q29udGV4dFZhbHVlXG4gIF0pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkZXIudHJhY2tSZW5kZXIoe1xuICAgICAgcmVuZGVyQ3R4OiB7XG4gICAgICAgIC8vIFdlIHRyYWNrIHRoZSBwcm92aWRlciBhcyBhIHNpbmdsZSBlbnRpdHlcbiAgICAgICAgcm9vdENvbXBvbmVudElkOiBcInByb3ZpZGVyXCIsXG4gICAgICAgIHRlYW1JZHM6IGxvYWRlci5nZXRUZWFtSWRzKCksXG4gICAgICAgIHByb2plY3RJZHM6IGxvYWRlci5nZXRQcm9qZWN0SWRzKClcbiAgICAgIH0sXG4gICAgICB2YXJpYXRpb246IHZhbHVlLnZhcmlhdGlvblxuICAgIH0pO1xuICB9LCBbbG9hZGVyLCB2YWx1ZV0pO1xuICBjb25zdCByZWFjdE1ham9yVmVyc2lvbiA9ICtSZWFjdDIudmVyc2lvbi5zcGxpdChcIi5cIilbMF07XG4gIGNvbnN0IHNob3VsZERpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5ID0gZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnkgIT0gbnVsbCA/IGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5IDogbG9hZGVyLmdldEJ1bmRsZSgpLmRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgIFBsYXNtaWNRdWVyeURhdGFQcm92aWRlcixcbiAgICB7XG4gICAgICBwcmVmZXRjaGVkQ2FjaGU6IHByZWZldGNoZWRRdWVyeURhdGEsXG4gICAgICBzdXNwZW5zZTogc3VzcGVuc2VGb3JRdWVyeURhdGFcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChQbGFzbWljUm9vdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUgfSwgIXNraXBDc3MgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUGxhc21pY0NzcyxcbiAgICAgIHtcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBwcmVmZXRjaGVkRGF0YSxcbiAgICAgICAgc2tpcEZvbnRzXG4gICAgICB9XG4gICAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUGFnZVBhcmFtc1Byb3ZpZGVyLFxuICAgICAge1xuICAgICAgICByb3V0ZTogcGFnZVJvdXRlLFxuICAgICAgICBwYXJhbXM6IHBhZ2VQYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiBwYWdlUXVlcnlcbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIE1heWJlV3JhcCxcbiAgICAgICAge1xuICAgICAgICAgIGNvbmQ6ICFzaG91bGREaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeSAmJiByZWFjdE1ham9yVmVyc2lvbiA+PSAxOCxcbiAgICAgICAgICB3cmFwcGVyOiAoY29udGVudHMpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuU3VzcGVuc2UsIHsgZmFsbGJhY2s6IHN1c3BlbnNlRmFsbGJhY2sgIT0gbnVsbCA/IHN1c3BlbnNlRmFsbGJhY2sgOiBcIkxvYWRpbmcuLi5cIiB9LCBjb250ZW50cylcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIClcbiAgICApKVxuICApO1xufVxudmFyIFBsYXNtaWNDc3MgPSBSZWFjdDIubWVtbyhmdW5jdGlvbiBQbGFzbWljQ3NzMihwcm9wcykge1xuICBjb25zdCB7IGxvYWRlciwgcHJlZmV0Y2hlZERhdGEsIHNraXBGb250cyB9ID0gcHJvcHM7XG4gIGNvbnN0IFt1c2VTY29wZWRDc3MsIHNldFVzZVNjb3BlZENzc10gPSBSZWFjdDIudXNlU3RhdGUoISFwcmVmZXRjaGVkRGF0YSk7XG4gIGNvbnN0IGJ1aWx0Q3NzID0gYnVpbGRDc3MobG9hZGVyLCB7XG4gICAgc2NvcGVkQ29tcE1ldGFzOiB1c2VTY29wZWRDc3MgJiYgcHJlZmV0Y2hlZERhdGEgPyBwcmVmZXRjaGVkRGF0YS5idW5kbGUuY29tcG9uZW50cyA6IHZvaWQgMCxcbiAgICBza2lwRm9udHNcbiAgfSk7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgY29uc3Qgd2F0Y2hlciA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBvbkRhdGFGZXRjaGVkOiAoKSA9PiB7XG4gICAgICAgIHNldFVzZVNjb3BlZENzcyhmYWxzZSk7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgW2xvYWRlciwgZm9yY2VVcGRhdGVdXG4gICk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRlci5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyKTtcbiAgICByZXR1cm4gKCkgPT4gbG9hZGVyLnVuc3Vic2NyaWJlUGxhc21pY1Jvb3Qod2F0Y2hlcik7XG4gIH0sIFt3YXRjaGVyLCBsb2FkZXJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBidWlsdENzcyB9IH0pO1xufSk7XG5mdW5jdGlvbiBidWlsZENzcyhsb2FkZXIsIG9wdHMpIHtcbiAgY29uc3QgeyBzY29wZWRDb21wTWV0YXMsIHNraXBGb250cyB9ID0gb3B0cztcbiAgY29uc3QgY3NzRmlsZXMgPSBzY29wZWRDb21wTWV0YXMgJiYgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIFwiZW50cnlwb2ludC5jc3NcIixcbiAgICAuLi5zY29wZWRDb21wTWV0YXMubWFwKChjKSA9PiBjLmNzc0ZpbGUpXG4gIF0pO1xuICBjb25zdCBjc3NNb2R1bGVzID0gbG9hZGVyLmdldExvb2t1cCgpLmdldENzcygpLmZpbHRlcigoZikgPT4gIWNzc0ZpbGVzIHx8IGNzc0ZpbGVzLmhhcyhmLmZpbGVOYW1lKSk7XG4gIGNvbnN0IGdldFByaSA9IChmaWxlTmFtZSkgPT4gZmlsZU5hbWUgPT09IFwiZW50cnlwb2ludC5jc3NcIiA/IDAgOiAxO1xuICBjb25zdCBjb21wYXJlTW9kdWxlcyA9IChhLCBiKSA9PiBnZXRQcmkoYS5maWxlTmFtZSkgIT09IGdldFByaShiLmZpbGVOYW1lKSA/IGdldFByaShhLmZpbGVOYW1lKSAtIGdldFByaShiLmZpbGVOYW1lKSA6IGEuZmlsZU5hbWUubG9jYWxlQ29tcGFyZShiLmZpbGVOYW1lKTtcbiAgY3NzTW9kdWxlcy5zb3J0KGNvbXBhcmVNb2R1bGVzKTtcbiAgY29uc3QgcmVtb3RlRm9udHMgPSBsb2FkZXIuZ2V0TG9va3VwKCkuZ2V0UmVtb3RlRm9udHMoKTtcbiAgcmV0dXJuIGBcbiAgICAke3NraXBGb250cyA/IFwiXCIgOiByZW1vdGVGb250cy5tYXAoKGYpID0+IGBAaW1wb3J0IHVybCgnJHtmLnVybH0nKTtgKS5qb2luKFwiXFxuXCIpfVxuICAgICR7Y3NzTW9kdWxlcy5tYXAoKG1vZCkgPT4gbW9kLnNvdXJjZSkuam9pbihcIlxcblwiKX1cbiAgYDtcbn1cbmZ1bmN0aW9uIHVzZVBsYXNtaWNSb290Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KFBsYXNtaWNSb290Q29udGV4dCk7XG59XG5cbi8vIHNyYy9nbG9iYWwtdmFyaWFudHMudHNcbmZ1bmN0aW9uIGNyZWF0ZVVzZUdsb2JhbFZhcmlhbnQobmFtZSwgcHJvamVjdElkKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJvb3RDb250ZXh0ID0gdXNlUGxhc21pY1Jvb3RDb250ZXh0KCk7XG4gICAgaWYgKCFyb290Q29udGV4dCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVyID0gcm9vdENvbnRleHQubG9hZGVyO1xuICAgIGNvbnN0IHNwZWMgPSBbXG4gICAgICAuLi5sb2FkZXIuZ2V0R2xvYmFsVmFyaWFudHMoKSxcbiAgICAgIC4uLihfYSA9IHJvb3RDb250ZXh0Lmdsb2JhbFZhcmlhbnRzKSAhPSBudWxsID8gX2EgOiBbXVxuICAgIF0uZmluZChcbiAgICAgIChzcGVjMikgPT4gc3BlYzIubmFtZSA9PT0gbmFtZSAmJiAoIXNwZWMyLnByb2plY3RJZCB8fCBzcGVjMi5wcm9qZWN0SWQgPT09IHByb2plY3RJZClcbiAgICApO1xuICAgIHJldHVybiBzcGVjID8gc3BlYy52YWx1ZSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLy8gc3JjL2xvYWRlci1zaGFyZWQudHNcbmltcG9ydCB7XG4gIFJlZ2lzdHJ5XG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0IHtcbiAgaW50ZXJuYWxfZ2V0Q2FjaGVkQnVuZGxlSW5Ob2RlU2VydmVyXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlclwiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlVmFyaWF0aW9uLCBnZXRFeHRlcm5hbElkcyB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItc3BsaXRzXCI7XG5cbi8vIHNyYy9idW5kbGVzLnRzXG5pbXBvcnQge1xuICBnZXRCdW5kbGVTdWJzZXRcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1jb3JlXCI7XG5mdW5jdGlvbiBnZXRVc2VkQ29tcHMoYWxsQ29tcG9uZW50cywgZW50cnlDb21wSWRzKSB7XG4gIGNvbnN0IHEgPSBbLi4uZW50cnlDb21wSWRzXTtcbiAgY29uc3Qgc2VlbklkcyA9IG5ldyBTZXQoZW50cnlDb21wSWRzKTtcbiAgY29uc3QgY29tcG9uZW50TWV0YUJ5SWQgPSBuZXcgTWFwKFxuICAgIGFsbENvbXBvbmVudHMubWFwKChtZXRhKSA9PiBbbWV0YS5pZCwgbWV0YV0pXG4gICk7XG4gIGNvbnN0IHVzZWRDb21wcyA9IFtdO1xuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2lkXSA9IHEuc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0IG1ldGEgPSBjb21wb25lbnRNZXRhQnlJZC5nZXQoaWQpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHVzZWRDb21wcy5wdXNoKG1ldGEpO1xuICAgIG1ldGEudXNlZENvbXBvbmVudHMuZm9yRWFjaCgodXNlZENvbXBJZCkgPT4ge1xuICAgICAgaWYgKCFzZWVuSWRzLmhhcyh1c2VkQ29tcElkKSkge1xuICAgICAgICBzZWVuSWRzLmFkZCh1c2VkQ29tcElkKTtcbiAgICAgICAgcS5wdXNoKHVzZWRDb21wSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1c2VkQ29tcHM7XG59XG5mdW5jdGlvbiBwcmVwQ29tcG9uZW50RGF0YShidW5kbGUsIGNvbXBNZXRhcywgb3B0cykge1xuICBpZiAoY29tcE1ldGFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRyeUNvbXBNZXRhczogYnVuZGxlLmNvbXBvbmVudHMsXG4gICAgICBidW5kbGUsXG4gICAgICByZW1vdGVGb250VXJsczogW11cbiAgICB9O1xuICB9XG4gIGNvbnN0IHVzZWRDb21wcyA9IGdldFVzZWRDb21wcyhcbiAgICBidW5kbGUuY29tcG9uZW50cyxcbiAgICBjb21wTWV0YXMubWFwKChjb21wTWV0YSkgPT4gY29tcE1ldGEuaWQpXG4gICk7XG4gIGNvbnN0IGNvbXBQYXRocyA9IHVzZWRDb21wcy5tYXAoKGNvbXBNZXRhKSA9PiBjb21wTWV0YS5lbnRyeSk7XG4gIGNvbnN0IHN1YkJ1bmRsZSA9IGdldEJ1bmRsZVN1YnNldChcbiAgICBidW5kbGUsXG4gICAgW1xuICAgICAgXCJlbnRyeXBvaW50LmNzc1wiLFxuICAgICAgLi4uY29tcFBhdGhzLFxuICAgICAgXCJyb290LXByb3ZpZGVyLmpzXCIsXG4gICAgICAuLi5idW5kbGUucHJvamVjdHMubWFwKCh4KSA9PiB4Lmdsb2JhbENvbnRleHRzUHJvdmlkZXJGaWxlTmFtZSkuZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IGluY2x1ZGUgZ2xvYmFsIGNvbnRleHQgcHJvdmlkZXIgY29tcG9uZW50c1xuICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGtlcHQgaW4gYnVuZGxlLmNvbXBvbmVudHMuIFRoYXQncyBiZWNhdXNlXG4gICAgICAvLyBmb3IgZXNidWlsZCwganVzdCB0aGUgZ2xvYmFsQ29udGV4dHNQcm92aWRlckZpbGVOYW1lIGlzIG5vdCBlbm91Z2gsXG4gICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgaW1wb3J0IGEgY2h1bmsgdGhhdCBpbmNsdWRlcyB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAgIC8vIGNvbXBvbmVudCwgaW5zdGVhZCBvZiBpbXBvcnRpbmcgdGhhdCBnbG9iYWwgY29udGV4dCBjb21wb25lbnQnc1xuICAgICAgLy8gZW50cnkgZmlsZS4gQW5kIGJlY2F1c2Ugbm90aGluZyBkZXBlbmRzIG9uIHRoZSBnbG9iYWwgY29udGV4dCBjb21wb25lbnQnc1xuICAgICAgLy8gZW50cnkgZmlsZSwgd2UgZW5kIHVwIGV4Y2x1ZGluZyB0aGUgZ2xvYmFsIGNvbnRleHQgY29tcG9uZW50IGZyb21cbiAgICAgIC8vIGJ1bmRsZS5jb21wb25lbnRzLCB3aGljaCB0aGVuIG1ha2VzIGl0cyBzdWJzdGl0dXRpb24gbm90IHdvcmsuXG4gICAgICAvLyBJbnN0ZWFkLCB3ZSBmb3JjaWJseSBpbmNsdWRlIGl0IGhlcmUgKHdlJ2xsIGRlZmluaXRlbHkgbmVlZCBpdCBhbnl3YXkhKS5cbiAgICAgIC4uLmJ1bmRsZS5jb21wb25lbnRzLmZpbHRlcigoYykgPT4gYy5pc0dsb2JhbENvbnRleHRQcm92aWRlcikubWFwKChjKSA9PiBjLmVudHJ5KSxcbiAgICAgIC4uLmJ1bmRsZS5nbG9iYWxHcm91cHMubWFwKChnKSA9PiBnLmNvbnRleHRGaWxlKVxuICAgIF0sXG4gICAgb3B0c1xuICApO1xuICBjb25zdCByZW1vdGVGb250VXJscyA9IFtdO1xuICBzdWJCdW5kbGUucHJvamVjdHMuZm9yRWFjaChcbiAgICAocCkgPT4gcmVtb3RlRm9udFVybHMucHVzaCguLi5wLnJlbW90ZUZvbnRzLm1hcCgoZikgPT4gZi51cmwpKVxuICApO1xuICByZXR1cm4ge1xuICAgIGVudHJ5Q29tcE1ldGFzOiBjb21wTWV0YXMsXG4gICAgYnVuZGxlOiBzdWJCdW5kbGUsXG4gICAgcmVtb3RlRm9udFVybHNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlQnVuZGxlcyh0YXJnZXQsIGZyb20pIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICBjb25zdCBleGlzdGluZ1Byb2plY3RzID0gbmV3IFNldCh0YXJnZXQucHJvamVjdHMubWFwKChwKSA9PiBwLmlkKSk7XG4gIGNvbnN0IG5ld1Byb2plY3RzID0gZnJvbS5wcm9qZWN0cy5maWx0ZXIoKHApID0+ICFleGlzdGluZ1Byb2plY3RzLmhhcyhwLmlkKSk7XG4gIGlmIChuZXdQcm9qZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgdGFyZ2V0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KSwge1xuICAgICAgcHJvamVjdHM6IFsuLi50YXJnZXQucHJvamVjdHMsIC4uLm5ld1Byb2plY3RzXVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tcElkcyA9IG5ldyBTZXQodGFyZ2V0LmNvbXBvbmVudHMubWFwKChjKSA9PiBjLmlkKSk7XG4gIGZ1bmN0aW9uIHNob3VsZEluY2x1ZGVDb21wb25lbnRJbkJ1bmRsZShjKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoZXhpc3RpbmdDb21wSWRzLmhhcyhjLmlkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4aXN0aW5nUHJvamVjdHMuaGFzKGMucHJvamVjdElkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEJ1bmRsZUZpbHRlcmVkSWRzID0gKF9hMiA9IHRhcmdldC5maWx0ZXJlZElkc1tjLnByb2plY3RJZF0pICE9IG51bGwgPyBfYTIgOiBbXTtcbiAgICByZXR1cm4gdGFyZ2V0QnVuZGxlRmlsdGVyZWRJZHMuaW5jbHVkZXMoYy5pZCk7XG4gIH1cbiAgY29uc3QgbmV3Q29tcE1ldGFzID0gZnJvbS5jb21wb25lbnRzLmZpbHRlcihcbiAgICAobSkgPT4gc2hvdWxkSW5jbHVkZUNvbXBvbmVudEluQnVuZGxlKG0pXG4gICk7XG4gIGlmIChuZXdDb21wTWV0YXMubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRhcmdldCksIHtcbiAgICAgIGNvbXBvbmVudHM6IFsuLi50YXJnZXQuY29tcG9uZW50cywgLi4ubmV3Q29tcE1ldGFzXVxuICAgIH0pO1xuICAgIHRhcmdldC5maWx0ZXJlZElkcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRhcmdldC5maWx0ZXJlZElkcykubWFwKChbaywgdl0pID0+IFtrLCBbLi4udl1dKVxuICAgICk7XG4gICAgZnJvbS5wcm9qZWN0cy5mb3JFYWNoKChmcm9tUHJvamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgY29uc3QgcHJvamVjdElkID0gZnJvbVByb2plY3QuaWQ7XG4gICAgICBjb25zdCBmcm9tQnVuZGxlRmlsdGVyZWRJZHMgPSAoX2EyID0gZnJvbS5maWx0ZXJlZElkc1twcm9qZWN0SWRdKSAhPSBudWxsID8gX2EyIDogW107XG4gICAgICBpZiAoIWV4aXN0aW5nUHJvamVjdHMuaGFzKHByb2plY3RJZCkpIHtcbiAgICAgICAgdGFyZ2V0LmZpbHRlcmVkSWRzW3Byb2plY3RJZF0gPSBbLi4uZnJvbUJ1bmRsZUZpbHRlcmVkSWRzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5maWx0ZXJlZElkc1twcm9qZWN0SWRdID0gaW50ZXJzZWN0KFxuICAgICAgICAgIChfYjIgPSB0YXJnZXQuZmlsdGVyZWRJZHNbcHJvamVjdElkXSkgIT0gbnVsbCA/IF9iMiA6IFtdLFxuICAgICAgICAgIGZyb21CdW5kbGVGaWx0ZXJlZElkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nTW9kdWxlcyA9IHtcbiAgICBicm93c2VyOiBuZXcgU2V0KHRhcmdldC5tb2R1bGVzLmJyb3dzZXIubWFwKChtKSA9PiBtLmZpbGVOYW1lKSksXG4gICAgc2VydmVyOiBuZXcgU2V0KHRhcmdldC5tb2R1bGVzLnNlcnZlci5tYXAoKG0pID0+IG0uZmlsZU5hbWUpKVxuICB9O1xuICBjb25zdCBuZXdNb2R1bGVzID0ge1xuICAgIGJyb3dzZXI6IGZyb20ubW9kdWxlcy5icm93c2VyLmZpbHRlcihcbiAgICAgIChtKSA9PiAhZXhpc3RpbmdNb2R1bGVzLmJyb3dzZXIuaGFzKG0uZmlsZU5hbWUpXG4gICAgKSxcbiAgICBzZXJ2ZXI6IGZyb20ubW9kdWxlcy5zZXJ2ZXIuZmlsdGVyKFxuICAgICAgKG0pID0+ICFleGlzdGluZ01vZHVsZXMuc2VydmVyLmhhcyhtLmZpbGVOYW1lKVxuICAgIClcbiAgfTtcbiAgaWYgKG5ld01vZHVsZXMuYnJvd3Nlci5sZW5ndGggPiAwIHx8IG5ld01vZHVsZXMuc2VydmVyLmxlbmd0aCA+IDApIHtcbiAgICB0YXJnZXQgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpLCB7XG4gICAgICBtb2R1bGVzOiB7XG4gICAgICAgIGJyb3dzZXI6IFsuLi50YXJnZXQubW9kdWxlcy5icm93c2VyLCAuLi5uZXdNb2R1bGVzLmJyb3dzZXJdLFxuICAgICAgICBzZXJ2ZXI6IFsuLi50YXJnZXQubW9kdWxlcy5zZXJ2ZXIsIC4uLm5ld01vZHVsZXMuc2VydmVyXVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nR2xvYmFsSWRzID0gbmV3IFNldCh0YXJnZXQuZ2xvYmFsR3JvdXBzLm1hcCgoZykgPT4gZy5pZCkpO1xuICBjb25zdCBuZXdHbG9iYWxzID0gZnJvbS5nbG9iYWxHcm91cHMuZmlsdGVyKFxuICAgIChnKSA9PiAhZXhpc3RpbmdHbG9iYWxJZHMuaGFzKGcuaWQpXG4gICk7XG4gIGlmIChuZXdHbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICB0YXJnZXQgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0YXJnZXQpLCB7XG4gICAgICBnbG9iYWxHcm91cHM6IFsuLi50YXJnZXQuZ2xvYmFsR3JvdXBzLCAuLi5uZXdHbG9iYWxzXVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nU3BsaXRJZHMgPSBuZXcgU2V0KHRhcmdldC5hY3RpdmVTcGxpdHMubWFwKChzKSA9PiBzLmlkKSk7XG4gIGNvbnN0IG5ld1NwbGl0cyA9IChfYSA9IGZyb20uYWN0aXZlU3BsaXRzLmZpbHRlcihcbiAgICAvLyBEb24ndCBpbmNsdWRlIHNwbGl0cyBiZWxvbmdpbmcgdG8gcHJvamVjdHMgYWxyZWFkeSBwcmVzZW50XG4gICAgLy8gaW4gdGhlIHRhcmdldCBidW5kbGVcbiAgICAocykgPT4gIWV4aXN0aW5nU3BsaXRJZHMuaGFzKHMuaWQpICYmICFleGlzdGluZ1Byb2plY3RzLmhhcyhzLnByb2plY3RJZClcbiAgKSkgIT0gbnVsbCA/IF9hIDogW107XG4gIGlmIChuZXdTcGxpdHMubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRhcmdldCksIHtcbiAgICAgIGFjdGl2ZVNwbGl0czogWy4uLnRhcmdldC5hY3RpdmVTcGxpdHMsIC4uLm5ld1NwbGl0c11cbiAgICB9KTtcbiAgfVxuICB0YXJnZXQuYnVuZGxlS2V5ID0gKF9jID0gKF9iID0gdGFyZ2V0LmJ1bmRsZUtleSkgIT0gbnVsbCA/IF9iIDogZnJvbS5idW5kbGVLZXkpICE9IG51bGwgPyBfYyA6IG51bGw7XG4gIHRhcmdldC5kZWZlckNodW5rc0J5RGVmYXVsdCA9IChfZSA9IChfZCA9IHRhcmdldC5kZWZlckNodW5rc0J5RGVmYXVsdCkgIT0gbnVsbCA/IF9kIDogZnJvbS5kZWZlckNodW5rc0J5RGVmYXVsdCkgIT0gbnVsbCA/IF9lIDogZmFsc2U7XG4gIHRhcmdldC5kaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdCA9IChfZyA9IChfZiA9IHRhcmdldC5kaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdCkgIT0gbnVsbCA/IF9mIDogZnJvbS5kaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdCkgIT0gbnVsbCA/IF9nIDogZmFsc2U7XG4gIHJldHVybiB0YXJnZXQ7XG59XG52YXIgY29udmVydEJ1bmRsZXNUb0NvbXBvbmVudFJlbmRlckRhdGEgPSAoYnVuZGxlcywgY29tcE1ldGFzKSA9PiB7XG4gIGlmIChidW5kbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1lcmdlZEJ1bmRsZXMgPSBidW5kbGVzLnJlZHVjZSgocHJldiwgY3VyKSA9PiBtZXJnZUJ1bmRsZXMocHJldiwgY3VyKSk7XG4gIHJldHVybiBwcmVwQ29tcG9uZW50RGF0YShtZXJnZWRCdW5kbGVzLCBjb21wTWV0YXMpO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudC1sb29rdXAudHNcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcE1ldGEobWV0YXMsIGxvb2t1cCkge1xuICBjb25zdCBmaWx0ZXJlZCA9IGdldENvbXBNZXRhcyhtZXRhcywgbG9va3VwKTtcbiAgcmV0dXJuIGZpbHRlcmVkLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IGZpbHRlcmVkWzBdO1xufVxudmFyIENvbXBvbmVudExvb2t1cCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYnVuZGxlLCByZWdpc3RyeSkge1xuICAgIHRoaXMuYnVuZGxlID0gYnVuZGxlO1xuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgfVxuICBnZXRDb21wb25lbnRNZXRhKHNwZWMpIHtcbiAgICBjb25zdCBjb21wTWV0YSA9IGdldEZpcnN0Q29tcE1ldGEodGhpcy5idW5kbGUuY29tcG9uZW50cywgc3BlYyk7XG4gICAgcmV0dXJuIGNvbXBNZXRhO1xuICB9XG4gIGdldENvbXBvbmVudChzcGVjLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBjb21wTWV0YSA9IGdldEZpcnN0Q29tcE1ldGEodGhpcy5idW5kbGUuY29tcG9uZW50cywgc3BlYyk7XG4gICAgaWYgKCFjb21wTWV0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgbm90IGZvdW5kOiAke3NwZWN9YCk7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBjb21wTWV0YS5lbnRyeTtcbiAgICBpZiAoIXRoaXMucmVnaXN0cnkuaGFzTW9kdWxlKG1vZHVsZU5hbWUsIG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBub3QgeWV0IGZldGNoZWQ6ICR7Y29tcE1ldGEubmFtZX1gKTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnJlZ2lzdHJ5LmxvYWQobW9kdWxlTmFtZSwge1xuICAgICAgZm9yY2VPcmlnaW5hbDogb3B0cy5mb3JjZU9yaWdpbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuICFvcHRzLmZvcmNlT3JpZ2luYWwgJiYgdHlwZW9mIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuZ2V0UGxhc21pY0NvbXBvbmVudCkgPT09IFwiZnVuY3Rpb25cIiA/IGVudHJ5LmdldFBsYXNtaWNDb21wb25lbnQoKSA6IGVudHJ5LmRlZmF1bHQ7XG4gIH1cbiAgaGFzQ29tcG9uZW50KHNwZWMpIHtcbiAgICBjb25zdCBjb21wTWV0YSA9IGdldEZpcnN0Q29tcE1ldGEodGhpcy5idW5kbGUuY29tcG9uZW50cywgc3BlYyk7XG4gICAgaWYgKGNvbXBNZXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5oYXNNb2R1bGUoY29tcE1ldGEuZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0R2xvYmFsQ29udGV4dHMoKSB7XG4gICAgY29uc3QgY3VzdG9tR2xvYmFsTWV0YXMgPSB0aGlzLmJ1bmRsZS5nbG9iYWxHcm91cHMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0udHlwZSA9PT0gXCJnbG9iYWwtdXNlci1kZWZpbmVkXCJcbiAgICApO1xuICAgIHJldHVybiBjdXN0b21HbG9iYWxNZXRhcy5tYXAoKG1ldGEpID0+ICh7XG4gICAgICBtZXRhLFxuICAgICAgY29udGV4dDogdGhpcy5yZWdpc3RyeS5sb2FkKG1ldGEuY29udGV4dEZpbGUpLmRlZmF1bHRcbiAgICB9KSk7XG4gIH1cbiAgZ2V0R2xvYmFsQ29udGV4dHNQcm92aWRlcihzcGVjKSB7XG4gICAgY29uc3QgY29tcE1ldGEgPSBnZXRGaXJzdENvbXBNZXRhKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgIGNvbnN0IHByb2plY3RNZXRhID0gY29tcE1ldGEgPyB0aGlzLmJ1bmRsZS5wcm9qZWN0cy5maW5kKCh4KSA9PiB4LmlkID09PSBjb21wTWV0YS5wcm9qZWN0SWQpIDogdm9pZCAwO1xuICAgIGlmICghcHJvamVjdE1ldGEgfHwgIXByb2plY3RNZXRhLmdsb2JhbENvbnRleHRzUHJvdmlkZXJGaWxlTmFtZSB8fCAhdGhpcy5yZWdpc3RyeS5oYXNNb2R1bGUocHJvamVjdE1ldGEuZ2xvYmFsQ29udGV4dHNQcm92aWRlckZpbGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnJlZ2lzdHJ5LmxvYWQoXG4gICAgICBwcm9qZWN0TWV0YS5nbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWVcbiAgICApO1xuICAgIHJldHVybiB0eXBlb2YgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5nZXRQbGFzbWljQ29tcG9uZW50KSA9PT0gXCJmdW5jdGlvblwiID8gZW50cnkuZ2V0UGxhc21pY0NvbXBvbmVudCgpIDogZW50cnkuZGVmYXVsdDtcbiAgfVxuICBnZXRSb290UHJvdmlkZXIoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnJlZ2lzdHJ5LmxvYWQoXCJyb290LXByb3ZpZGVyLmpzXCIpO1xuICAgIHJldHVybiBlbnRyeS5kZWZhdWx0O1xuICB9XG4gIGdldENzcygpIHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGUubW9kdWxlcy5icm93c2VyLmZpbHRlcihcbiAgICAgIChtb2QpID0+IG1vZC50eXBlID09PSBcImFzc2V0XCIgJiYgbW9kLmZpbGVOYW1lLmVuZHNXaXRoKFwiY3NzXCIpXG4gICAgKTtcbiAgfVxuICBnZXRSZW1vdGVGb250cygpIHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGUucHJvamVjdHMuZmxhdE1hcCgocCkgPT4gcC5yZW1vdGVGb250cyk7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkZXItc2hhcmVkLnRzXG52YXIgU1VCU1RJVFVURURfQ09NUE9ORU5UUyA9IHt9O1xudmFyIFJFR0lTVEVSRURfQ09ERV9DT01QT05FTlRfSEVMUEVSUyA9IHt9O1xudmFyIFNVQlNUSVRVVEVEX0dMT0JBTF9WQVJJQU5UX0hPT0tTID0ge307XG52YXIgUkVHSVNURVJFRF9DVVNUT01fRlVOQ1RJT05TID0ge307XG5mdW5jdGlvbiBjdXN0b21GdW5jdGlvbkltcG9ydEFsaWFzKG1ldGEpIHtcbiAgY29uc3QgY3VzdG9tRnVuY3Rpb25QcmVmaXggPSBgX19mbl9gO1xuICByZXR1cm4gbWV0YS5uYW1lc3BhY2UgPyBgJHtjdXN0b21GdW5jdGlvblByZWZpeH0ke21ldGEubmFtZXNwYWNlfV9fJHttZXRhLm5hbWV9YCA6IGAke2N1c3RvbUZ1bmN0aW9uUHJlZml4fSR7bWV0YS5uYW1lfWA7XG59XG5mdW5jdGlvbiBpbnRlcm5hbFNldFJlZ2lzdGVyZWRGdW5jdGlvbihmbiwgbWV0YSkge1xuICBSRUdJU1RFUkVEX0NVU1RPTV9GVU5DVElPTlNbY3VzdG9tRnVuY3Rpb25JbXBvcnRBbGlhcyhtZXRhKV0gPSBmbjtcbn1cbmZ1bmN0aW9uIHBhcnNlRmV0Y2hDb21wb25lbnREYXRhQXJncyguLi5hcmdzKSB7XG4gIGxldCBzcGVjcztcbiAgbGV0IG9wdHM7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgc3BlY3MgPSBhcmdzWzBdO1xuICAgIG9wdHMgPSBhcmdzWzFdO1xuICB9IGVsc2Uge1xuICAgIHNwZWNzID0gYXJncztcbiAgICBvcHRzID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IHNwZWNzLCBvcHRzIH07XG59XG52YXIgQmFzZUludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMucmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcbiAgICB0aGlzLmdsb2JhbFZhcmlhbnRzID0gW107XG4gICAgdGhpcy5zdWJzID0gW107XG4gICAgdGhpcy5idW5kbGUgPSB7XG4gICAgICBtb2R1bGVzOiB7XG4gICAgICAgIGJyb3dzZXI6IFtdLFxuICAgICAgICBzZXJ2ZXI6IFtdXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czogW10sXG4gICAgICBnbG9iYWxHcm91cHM6IFtdLFxuICAgICAgcHJvamVjdHM6IFtdLFxuICAgICAgYWN0aXZlU3BsaXRzOiBbXSxcbiAgICAgIGJ1bmRsZUtleTogbnVsbCxcbiAgICAgIGRlZmVyQ2h1bmtzQnlEZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0OiBmYWxzZSxcbiAgICAgIGZpbHRlcmVkSWRzOiB7fVxuICAgIH07XG4gICAgdGhpcy5vcHRzID0gYXJncy5vcHRzO1xuICAgIHRoaXMuZmV0Y2hlciA9IGFyZ3MuZmV0Y2hlcjtcbiAgICB0aGlzLnRyYWNrZXIgPSBhcmdzLnRyYWNrZXI7XG4gICAgdGhpcy5vbkJ1bmRsZU1lcmdlZCA9IGFyZ3Mub25CdW5kbGVNZXJnZWQ7XG4gICAgdGhpcy5vbkJ1bmRsZUZldGNoZWQgPSBhcmdzLm9uQnVuZGxlRmV0Y2hlZDtcbiAgICB0aGlzLnJlZ2lzdGVyTW9kdWxlcyhhcmdzLmJ1aWx0aW5Nb2R1bGVzKTtcbiAgfVxuICBtYXliZUdldENvbXBNZXRhcyguLi5zcGVjcykge1xuICAgIGNvbnN0IGZvdW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgZm9yIChjb25zdCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZE1ldGFzID0gZ2V0Q29tcE1ldGFzKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgICAgaWYgKGZpbHRlcmVkTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWx0ZXJlZE1ldGFzLmZvckVhY2goKG1ldGEpID0+IGZvdW5kLmFkZChtZXRhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXNzaW5nLnB1c2goc3BlYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvdW5kOiBBcnJheS5mcm9tKGZvdW5kLmtleXMoKSksIG1pc3NpbmcgfTtcbiAgfVxuICBtYXliZUZldGNoQ29tcG9uZW50RGF0YSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHsgc3BlY3MsIG9wdHMgfSA9IHBhcnNlRmV0Y2hDb21wb25lbnREYXRhQXJncyguLi5hcmdzKTtcbiAgICAgIGNvbnN0IHJldHVybldpdGhTcGVjc1RvRmV0Y2ggPSAoc3BlY3NUb0ZldGNoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZmV0Y2hNaXNzaW5nRGF0YSh7IG1pc3NpbmdTcGVjczogc3BlY3NUb0ZldGNoIH0pO1xuICAgICAgICBjb25zdCB7IGZvdW5kOiBleGlzdGluZ01ldGFzMiwgbWlzc2luZzogbWlzc2luZ1NwZWNzMiB9ID0gdGhpcy5tYXliZUdldENvbXBNZXRhcyguLi5zcGVjcyk7XG4gICAgICAgIGlmIChtaXNzaW5nU3BlY3MyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlcENvbXBvbmVudERhdGEodGhpcy5idW5kbGUsIGV4aXN0aW5nTWV0YXMyLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMub3B0cy5hbHdheXNGcmVzaCkge1xuICAgICAgICByZXR1cm4geWllbGQgcmV0dXJuV2l0aFNwZWNzVG9GZXRjaChzcGVjcyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGZvdW5kOiBleGlzdGluZ01ldGFzLCBtaXNzaW5nOiBtaXNzaW5nU3BlY3MgfSA9IHRoaXMubWF5YmVHZXRDb21wTWV0YXMoLi4uc3BlY3MpO1xuICAgICAgaWYgKG1pc3NpbmdTcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHByZXBDb21wb25lbnREYXRhKHRoaXMuYnVuZGxlLCBleGlzdGluZ01ldGFzLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5aWVsZCByZXR1cm5XaXRoU3BlY3NUb0ZldGNoKG1pc3NpbmdTcGVjcyk7XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgeyBzcGVjcywgb3B0cyB9ID0gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKC4uLmFyZ3MpO1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMubWF5YmVGZXRjaENvbXBvbmVudERhdGEoc3BlY3MsIG9wdHMpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgbWlzc2luZzogbWlzc2luZ1NwZWNzIH0gPSB0aGlzLm1heWJlR2V0Q29tcE1ldGFzKC4uLnNwZWNzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBVbmFibGUgdG8gZmluZCBjb21wb25lbnRzICR7bWlzc2luZ1NwZWNzLm1hcChnZXRMb29rdXBTcGVjTmFtZSkuam9pbihcIiwgXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xuICB9XG4gIGZldGNoUGFnZXMob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLm1heWJlUmVwb3J0Q2xpZW50U2lkZUZldGNoKFxuICAgICAgICAoKSA9PiBgUGxhc21pYzogZmV0Y2hpbmcgYWxsIHBhZ2UgbWV0YWRhdGEgaW4gdGhlIGJyb3dzZXJgXG4gICAgICApO1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMuZmV0Y2hBbGxEYXRhKCk7XG4gICAgICByZXR1cm4gZGF0YS5jb21wb25lbnRzLmZpbHRlcihcbiAgICAgICAgKGNvbXApID0+IGNvbXAuaXNQYWdlICYmIGNvbXAucGF0aCAmJiAoKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5jbHVkZUR5bmFtaWNQYWdlcykgfHwgIWlzRHluYW1pY1BhZ2VQYXRoKGNvbXAucGF0aCkpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGZldGNoQ29tcG9uZW50cygpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5tYXliZVJlcG9ydENsaWVudFNpZGVGZXRjaChcbiAgICAgICAgKCkgPT4gYFBsYXNtaWM6IGZldGNoaW5nIGFsbCBjb21wb25lbnQgbWV0YWRhdGEgaW4gdGhlIGJyb3dzZXJgXG4gICAgICApO1xuICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMuZmV0Y2hBbGxEYXRhKCk7XG4gICAgICByZXR1cm4gZGF0YS5jb21wb25lbnRzO1xuICAgIH0pO1xuICB9XG4gIGdldEFjdGl2ZVNwbGl0cygpIHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGUuYWN0aXZlU3BsaXRzO1xuICB9XG4gIGdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaGVyLmdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpO1xuICB9XG4gIGZldGNoTWlzc2luZ0RhdGEob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLm1heWJlUmVwb3J0Q2xpZW50U2lkZUZldGNoKFxuICAgICAgICAoKSA9PiBgUGxhc21pYzogZmV0Y2hpbmcgbWlzc2luZyBjb21wb25lbnRzIGluIHRoZSBicm93c2VyOiAke29wdHMubWlzc2luZ1NwZWNzLm1hcCgoc3BlYykgPT4gZ2V0TG9va3VwU3BlY05hbWUoc3BlYykpLmpvaW4oXCIsIFwiKX1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hBbGxEYXRhKCk7XG4gICAgfSk7XG4gIH1cbiAgbWF5YmVSZXBvcnRDbGllbnRTaWRlRmV0Y2gobWtNc2cpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIHRoaXMub3B0cy5vbkNsaWVudFNpZGVGZXRjaCkge1xuICAgICAgY29uc3QgbXNnID0gbWtNc2coKTtcbiAgICAgIGlmICh0aGlzLm9wdHMub25DbGllbnRTaWRlRmV0Y2ggPT09IFwid2FyblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZldGNoQWxsRGF0YSgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgYnVuZGxlID0geWllbGQgdGhpcy5mZXRjaGVyLmZldGNoQWxsRGF0YSgpO1xuICAgICAgdGhpcy50cmFja2VyLnRyYWNrRmV0Y2goKTtcbiAgICAgIHRoaXMubWVyZ2VCdW5kbGUoYnVuZGxlKTtcbiAgICAgIChfYSA9IHRoaXMub25CdW5kbGVGZXRjaGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBidW5kbGU7XG4gICAgfSk7XG4gIH1cbiAgbWVyZ2VCdW5kbGUobmV3QnVuZGxlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBuZXdCdW5kbGUuYnVuZGxlS2V5ID0gKF9hID0gbmV3QnVuZGxlLmJ1bmRsZUtleSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICBpZiAobmV3QnVuZGxlLmJ1bmRsZUtleSAmJiB0aGlzLmJ1bmRsZS5idW5kbGVLZXkgJiYgbmV3QnVuZGxlLmJ1bmRsZUtleSAhPT0gdGhpcy5idW5kbGUuYnVuZGxlS2V5KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGFzbWljIEVycm9yOiBEaWZmZXJlbnQgY29kZSBleHBvcnQgaGFzaGVzLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91ciBhcHAgaXMgdXNpbmcgZGlmZmVyZW50IGxvYWRlcnMgd2l0aCBkaWZmZXJlbnQgcHJvamVjdCBJRHMgb3IgcHJvamVjdCB2ZXJzaW9ucy5cbkNvbmZsaWN0aW5nIHZhbHVlczpcbiR7bmV3QnVuZGxlLmJ1bmRsZUtleX1cbiR7dGhpcy5idW5kbGUuYnVuZGxlS2V5fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYnVuZGxlID0gbWVyZ2VCdW5kbGVzKG5ld0J1bmRsZSwgdGhpcy5idW5kbGUpO1xuICAgIChfYiA9IHRoaXMub25CdW5kbGVNZXJnZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xuICB9XG4gIGdldEJ1bmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGU7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLmJ1bmRsZSA9IHtcbiAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgYnJvd3NlcjogW10sXG4gICAgICAgIHNlcnZlcjogW11cbiAgICAgIH0sXG4gICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgIGdsb2JhbEdyb3VwczogW10sXG4gICAgICBwcm9qZWN0czogW10sXG4gICAgICBhY3RpdmVTcGxpdHM6IFtdLFxuICAgICAgYnVuZGxlS2V5OiBudWxsLFxuICAgICAgZGVmZXJDaHVua3NCeURlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQ6IGZhbHNlLFxuICAgICAgZmlsdGVyZWRJZHM6IHt9XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5LmNsZWFyKCk7XG4gIH1cbiAgcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMobW9kdWxlcykuc29tZShcbiAgICAgIChuYW1lKSA9PiB0aGlzLnJlZ2lzdHJ5LmdldFJlZ2lzdGVyZWRNb2R1bGUobmFtZSkgIT09IG1vZHVsZXNbbmFtZV1cbiAgICApKSB7XG4gICAgICBpZiAoIXRoaXMucmVnaXN0cnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkNhbGxpbmcgUGxhc21pY0NvbXBvbmVudExvYWRlci5yZWdpc3Rlck1vZHVsZXMoKSBhZnRlciBQbGFzbWljIGNvbXBvbmVudCBoYXMgcmVuZGVyZWQ7IHN0YXJ0aW5nIG92ZXIuXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5jbGVhcigpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobW9kdWxlcykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5yZWdpc3RlcihrZXksIG1vZHVsZXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN1YnN0aXR1dGVDb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN1YnN0aXR1dGVDb21wb25lbnQoY29tcG9uZW50LCBuYW1lLCB2b2lkIDApO1xuICB9XG4gIGludGVybmFsU3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG5hbWUsIGNvZGVDb21wb25lbnRIZWxwZXJzKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVnaXN0cnlFbXB0eSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiQ2FsbGluZyBQbGFzbWljQ29tcG9uZW50TG9hZGVyLnJlZ2lzdGVyU3Vic3RpdHV0aW9uKCkgYWZ0ZXIgUGxhc21pYyBjb21wb25lbnQgaGFzIHJlbmRlcmVkOyBzdGFydGluZyBvdmVyLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5jbGVhclJlZ2lzdHJ5KCk7XG4gICAgfVxuICAgIHRoaXMuc3Vicy5wdXNoKHsgbG9va3VwOiBuYW1lLCBjb21wb25lbnQsIGNvZGVDb21wb25lbnRIZWxwZXJzIH0pO1xuICB9XG4gIHJlZnJlc2hSZWdpc3RyeSgpIHtcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLnN1YnMpIHtcbiAgICAgIGNvbnN0IG1ldGFzID0gZ2V0Q29tcE1ldGFzKHRoaXMuZ2V0QnVuZGxlKCkuY29tcG9uZW50cywgc3ViLmxvb2t1cCk7XG4gICAgICBtZXRhcy5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIFNVQlNUSVRVVEVEX0NPTVBPTkVOVFNbbWV0YS5pZF0gPSBzdWIuY29tcG9uZW50O1xuICAgICAgICBpZiAoc3ViLmNvZGVDb21wb25lbnRIZWxwZXJzKSB7XG4gICAgICAgICAgUkVHSVNURVJFRF9DT0RFX0NPTVBPTkVOVF9IRUxQRVJTW21ldGEuaWRdID0gc3ViLmNvZGVDb21wb25lbnRIZWxwZXJzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZWdpc3RyeS51cGRhdGVNb2R1bGVzKHRoaXMuZ2V0QnVuZGxlKCkpO1xuICB9XG4gIGlzUmVnaXN0cnlFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5pc0VtcHR5KCk7XG4gIH1cbiAgY2xlYXJSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5LmNsZWFyKCk7XG4gIH1cbiAgc2V0R2xvYmFsVmFyaWFudHMoZ2xvYmFsVmFyaWFudHMpIHtcbiAgICB0aGlzLmdsb2JhbFZhcmlhbnRzID0gZ2xvYmFsVmFyaWFudHM7XG4gIH1cbiAgZ2V0R2xvYmFsVmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsVmFyaWFudHM7XG4gIH1cbiAgcmVnaXN0ZXJQcmVmZXRjaGVkQnVuZGxlKGJ1bmRsZSkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICBjb25zdCBjYWNoZWRCdW5kbGUgPSBpbnRlcm5hbF9nZXRDYWNoZWRCdW5kbGVJbk5vZGVTZXJ2ZXIodGhpcy5vcHRzKTtcbiAgICAgIGlmIChjYWNoZWRCdW5kbGUpIHtcbiAgICAgICAgdGhpcy5tZXJnZUJ1bmRsZShjYWNoZWRCdW5kbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1lcmdlQnVuZGxlKGJ1bmRsZSk7XG4gIH1cbiAgZ2V0TG9va3VwKCkge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50TG9va3VwKHRoaXMuZ2V0QnVuZGxlKCksIHRoaXMucmVnaXN0cnkpO1xuICB9XG4gIHRyYWNrQ29udmVyc2lvbih2YWx1ZSA9IDApIHtcbiAgICB0aGlzLnRyYWNrZXIudHJhY2tDb252ZXJzaW9uKHZhbHVlKTtcbiAgfVxuICBnZXRBY3RpdmVWYXJpYXRpb24ob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmZldGNoQ29tcG9uZW50cygpO1xuICAgICAgcmV0dXJuIGdldEFjdGl2ZVZhcmlhdGlvbihfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRzKSwge1xuICAgICAgICBzcGxpdHM6IHRoaXMuZ2V0QnVuZGxlKCkuYWN0aXZlU3BsaXRzXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGVhbUlkcygpIHtcbiAgICByZXR1cm4gdW5pcShcbiAgICAgIHRoaXMuZ2V0QnVuZGxlKCkucHJvamVjdHMubWFwKFxuICAgICAgICAocCkgPT4gcC50ZWFtSWQgPyBgJHtwLnRlYW1JZH0ke3AuaW5kaXJlY3QgPyBcIkBpbmRpcmVjdFwiIDogXCJcIn1gIDogbnVsbFxuICAgICAgKS5maWx0ZXIoKHgpID0+ICEheClcbiAgICApO1xuICB9XG4gIGdldFByb2plY3RJZHMoKSB7XG4gICAgcmV0dXJuIHVuaXEoXG4gICAgICB0aGlzLmdldEJ1bmRsZSgpLnByb2plY3RzLm1hcChcbiAgICAgICAgKHApID0+IGAke3AuaWR9JHtwLmluZGlyZWN0ID8gXCJAaW5kaXJlY3RcIiA6IFwiXCJ9YFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgdHJhY2tSZW5kZXIob3B0cykge1xuICAgIHRoaXMudHJhY2tlci50cmFja1JlbmRlcihvcHRzKTtcbiAgfVxuICBsb2FkU2VydmVyUXVlcmllc01vZHVsZShmaWxlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmxvYWQoZmlsZU5hbWUpO1xuICB9XG59O1xudmFyIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsKSB7XG4gICAgdGhpcy53YXJuZWRSZWdpc3RlckNvbXBvbmVudCA9IGZhbHNlO1xuICAgIHRoaXMuX19pbnRlcm5hbCA9IGludGVybmFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGdsb2JhbCB2YXJpYW50cyB0byBiZSB1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gIE5vdGUgdGhhdFxuICAgKiB0aGlzIGlzIG5vdCByZWFjdGl2ZSwgYW5kIHdpbGwgbm90IHJlLXJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgKiBhbHJlYWR5IG1vdW50ZWQ7IGluc3RlYWQsIGl0IHNob3VsZCBiZSB1c2VkIHRvIGFjdGl2YXRlIGdsb2JhbFxuICAgKiB2YXJpYW50cyB0aGF0IHNob3VsZCBhbHdheXMgYmUgYWN0aXZhdGVkIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhpc1xuICAgKiBhcHAuICBJZiB5b3UnZCBsaWtlIHRvIHJlYWN0aXZlbHkgY2hhbmdlIHRoZSBnbG9iYWwgdmFyaWFudHMsXG4gICAqIHlvdSBzaG91bGQgc3BlY2lmeSB0aGVtIHZpYSA8UGxhc21pY1Jvb3RQcm92aWRlciAvPlxuICAgKi9cbiAgc2V0R2xvYmFsVmFyaWFudHMoZ2xvYmFsVmFyaWFudHMpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwuc2V0R2xvYmFsVmFyaWFudHMoZ2xvYmFsVmFyaWFudHMpO1xuICB9XG4gIHJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgYmUgc3dhcHBlZCBpbiBmb3JcbiAgICogY29tcG9uZW50cyBkZWZpbmVkIGluIHlvdXIgcHJvamVjdC4gIFlvdSBjYW4gdXNlIHRoaXMgdG9cbiAgICogc3dhcCBpbiAvIHN1YnN0aXR1dGUgYSBQbGFzbWljIGNvbXBvbmVudCB3aXRoIGEgXCJyZWFsXCIgY29tcG9uZW50LlxuICAgKi9cbiAgc3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwuc3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG5hbWUpO1xuICB9XG4gIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCwgbWV0YU9yTmFtZSkge1xuICAgIGlmIChtZXRhT3JOYW1lICYmIHR5cGVvZiBtZXRhT3JOYW1lID09PSBcIm9iamVjdFwiICYmIFwicHJvcHNcIiBpbiBtZXRhT3JOYW1lKSB7XG4gICAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50LCBtZXRhT3JOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgIXRoaXMud2FybmVkUmVnaXN0ZXJDb21wb25lbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBQbGFzbWljTG9hZGVyOiBVc2luZyBkZXByZWNhdGVkIG1ldGhvZCBcXGByZWdpc3RlckNvbXBvbmVudFxcYCBmb3IgY29tcG9uZW50IHN1YnN0aXR1dGlvbi4gUGxlYXNlIGNvbnNpZGVyIHVzaW5nIFxcYHN1YnN0aXR1dGVDb21wb25lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMud2FybmVkUmVnaXN0ZXJDb21wb25lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zdWJzdGl0dXRlQ29tcG9uZW50KGNvbXBvbmVudCwgbWV0YU9yTmFtZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb24oZm4sIG1ldGEpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJGdW5jdGlvbihmbiwgbWV0YSk7XG4gIH1cbiAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0KGNvbnRleHQsIG1ldGEpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJHbG9iYWxDb250ZXh0KGNvbnRleHQsIG1ldGEpO1xuICB9XG4gIHJlZ2lzdGVyVHJhaXQodHJhaXQsIG1ldGEpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJUcmFpdCh0cmFpdCwgbWV0YSk7XG4gIH1cbiAgcmVnaXN0ZXJUb2tlbih0b2tlbikge1xuICAgIHRoaXMuX19pbnRlcm5hbC5yZWdpc3RlclRva2VuKHRva2VuKTtcbiAgfVxuICBmZXRjaENvbXBvbmVudERhdGEoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWwuZmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpO1xuICB9XG4gIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5tYXliZUZldGNoQ29tcG9uZW50RGF0YSguLi5hcmdzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIHBhZ2UgY29tcG9uZW50IG1ldGFkYXRhIGZvciB0aGVzZSBwcm9qZWN0cy5cbiAgICovXG4gIGZldGNoUGFnZXMob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmZldGNoUGFnZXMob3B0cyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNvbXBvbmVudHMgbWV0YWRhdGEgZm9yIHRoZXNlIHByb2plY3RzLlxuICAgKi9cbiAgZmV0Y2hDb21wb25lbnRzKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmZldGNoQ29tcG9uZW50cygpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRBY3RpdmVWYXJpYXRpb24ob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmdldEFjdGl2ZVZhcmlhdGlvbihvcHRzKTtcbiAgICB9KTtcbiAgfVxuICBnZXRBY3RpdmVWYXJpYXRpb24ob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0QWN0aXZlVmFyaWF0aW9uKHtcbiAgICAgICAgdHJhaXRzOiBvcHRzLnRyYWl0cyxcbiAgICAgICAgZ2V0S25vd25WYWx1ZTogKGtleSkgPT4ge1xuICAgICAgICAgIGlmIChvcHRzLmtub3duKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5rbm93bltrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUtub3duVmFsdWU6IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKCFvcHRzLmtub3duKSB7XG4gICAgICAgICAgICB1cGRhdGVQbGFzbWljQ29va2llVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5nZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKTtcbiAgfVxuICBnZXRFeHRlcm5hbFZhcmlhdGlvbih2YXJpYXRpb24sIGZpbHRlcnMpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZXJuYWxJZHModGhpcy5nZXRBY3RpdmVTcGxpdHMoKSwgdmFyaWF0aW9uLCBmaWx0ZXJzKTtcbiAgfVxuICBnZXRBY3RpdmVTcGxpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5nZXRBY3RpdmVTcGxpdHMoKTtcbiAgfVxuICB0cmFja0NvbnZlcnNpb24odmFsdWUgPSAwKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnRyYWNrQ29udmVyc2lvbih2YWx1ZSk7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmNsZWFyQ2FjaGUoKTtcbiAgfVxuICB1bnN0YWJsZV9fZ2V0U2VydmVyUXVlcmllc0RhdGEocmVuZGVyRGF0YSwgJGN0eCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAocmVuZGVyRGF0YS5lbnRyeUNvbXBNZXRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsZU5hbWUgPSByZW5kZXJEYXRhLmVudHJ5Q29tcE1ldGFzWzBdLnNlcnZlclF1ZXJpZXNFeGVjRnVuY0ZpbGVOYW1lO1xuICAgICAgaWYgKCFmaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLl9faW50ZXJuYWwubG9hZFNlcnZlclF1ZXJpZXNNb2R1bGUoZmlsZU5hbWUpO1xuICAgICAgY29uc3QgeyBleGVjdXRlU2VydmVyUXVlcmllcyB9ID0gbW9kdWxlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgJHNlcnZlclF1ZXJpZXMgPSB5aWVsZCBleGVjdXRlU2VydmVyUXVlcmllcygkY3R4KTtcbiAgICAgICAgcmV0dXJuICRzZXJ2ZXJRdWVyaWVzO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgc2VydmVyIHF1ZXJpZXMgZnVuY3Rpb25cIiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVyLWNsaWVudC50c1xudmFyIEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciA9IGNsYXNzIGV4dGVuZHMgQmFzZUludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFBsYXNtaWNUcmFja2VyMihfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRzKSwge1xuICAgICAgcHJvamVjdElkczogb3B0cy5wcm9qZWN0cy5tYXAoKHApID0+IHAuaWQpXG4gICAgfSkpO1xuICAgIHN1cGVyKHtcbiAgICAgIG9wdHMsXG4gICAgICB0cmFja2VyLFxuICAgICAgZmV0Y2hlcjogbmV3IFBsYXNtaWNNb2R1bGVzRmV0Y2hlcjIob3B0cyksXG4gICAgICBvbkJ1bmRsZU1lcmdlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnJlZnJlc2hSZWdpc3RyeSgpO1xuICAgICAgfSxcbiAgICAgIG9uQnVuZGxlRmV0Y2hlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RzLmZvckVhY2goKHdhdGNoZXIpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IHdhdGNoZXIub25EYXRhRmV0Y2hlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwod2F0Y2hlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGJ1aWx0aW5Nb2R1bGVzOiB7XG4gICAgICAgIHJlYWN0OiBSZWFjdDMsXG4gICAgICAgIFwicmVhY3QtZG9tXCI6IFJlYWN0RE9NLFxuICAgICAgICBcInJlYWN0L2pzeC1ydW50aW1lXCI6IGpzeFJ1bnRpbWUsXG4gICAgICAgIFwicmVhY3QvanN4LWRldi1ydW50aW1lXCI6IGpzeERldlJ1bnRpbWUsXG4gICAgICAgIC8vIEFsc28gaW5qZWN0IEBwbGFzbWljYXBwL3F1ZXJ5IGFuZCBAcGxhc21pY2FwcC9ob3N0IHRvIHVzZSB0aGVcbiAgICAgICAgLy8gc2FtZSBjb250ZXh0cyBoZXJlIGFuZCBpbiBsb2FkZXItZG93bmxvYWRlZCBjb2RlLlxuICAgICAgICBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI6IFBsYXNtaWNRdWVyeSxcbiAgICAgICAgXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiOiBQbGFzbWljRGF0YVNvdXJjZXNDb250ZXh0LFxuICAgICAgICBcIkBwbGFzbWljYXBwL2hvc3RcIjogUGxhc21pY0hvc3QsXG4gICAgICAgIFwiQHBsYXNtaWNhcHAvbG9hZGVyLXJ1bnRpbWUtcmVnaXN0cnlcIjoge1xuICAgICAgICAgIGNvbXBvbmVudHM6IFNVQlNUSVRVVEVEX0NPTVBPTkVOVFMsXG4gICAgICAgICAgZ2xvYmFsVmFyaWFudEhvb2tzOiBTVUJTVElUVVRFRF9HTE9CQUxfVkFSSUFOVF9IT09LUyxcbiAgICAgICAgICBjb2RlQ29tcG9uZW50SGVscGVyczogUkVHSVNURVJFRF9DT0RFX0NPTVBPTkVOVF9IRUxQRVJTLFxuICAgICAgICAgIGZ1bmN0aW9uczogUkVHSVNURVJFRF9DVVNUT01fRlVOQ1RJT05TXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJvb3RzID0gW107XG4gIH1cbiAgcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50LCBtZXRhKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBzdGF0ZUhlbHBlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcygoX2EgPSBtZXRhLnN0YXRlcykgIT0gbnVsbCA/IF9hIDoge30pLmZpbHRlcihcbiAgICAgICAgKFtfLCBzdGF0ZVNwZWNdKSA9PiBPYmplY3Qua2V5cyhzdGF0ZVNwZWMpLnNvbWUoKGtleSkgPT4gc3RhdGVIZWxwZXJzS2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgKS5tYXAoKFtzdGF0ZU5hbWUsIHN0YXRlU3BlY10pID0+IFtcbiAgICAgICAgc3RhdGVOYW1lLFxuICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgc3RhdGVIZWxwZXJzS2V5cy5maWx0ZXIoKGtleSkgPT4ga2V5IGluIHN0YXRlU3BlYykubWFwKChrZXkpID0+IFtrZXksIHN0YXRlU3BlY1trZXldXSlcbiAgICAgICAgKVxuICAgICAgXSlcbiAgICApO1xuICAgIGNvbnN0IGhlbHBlcnMgPSB7IHN0YXRlczogc3RhdGVIZWxwZXJzIH07XG4gICAgdGhpcy5pbnRlcm5hbFN1YnN0aXR1dGVDb21wb25lbnQoXG4gICAgICBjb21wb25lbnQsXG4gICAgICB7IG5hbWU6IG1ldGEubmFtZSwgaXNDb2RlOiB0cnVlIH0sXG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZUhlbHBlcnMpLmxlbmd0aCA+IDAgPyBoZWxwZXJzIDogdm9pZCAwXG4gICAgKTtcbiAgICByZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEpLCB7XG4gICAgICAvLyBJbXBvcnQgcGF0aCBpcyBub3QgdXNlZCBhcyB3ZSB3aWxsIHVzZSBjb21wb25lbnQgc3Vic3RpdHV0aW9uXG4gICAgICBpbXBvcnRQYXRoOiAoX2IgPSBtZXRhLmltcG9ydFBhdGgpICE9IG51bGwgPyBfYiA6IFwiXCJcbiAgICB9KSwgT2JqZWN0LmtleXMoc3RhdGVIZWxwZXJzKS5sZW5ndGggPiAwID8ge1xuICAgICAgY29tcG9uZW50SGVscGVyczoge1xuICAgICAgICBoZWxwZXJzLFxuICAgICAgICBpbXBvcnRQYXRoOiBcIlwiLFxuICAgICAgICBpbXBvcnROYW1lOiBcIlwiXG4gICAgICB9XG4gICAgfSA6IHt9KSk7XG4gIH1cbiAgcmVnaXN0ZXJGdW5jdGlvbihmbiwgbWV0YSkge1xuICAgIHZhciBfYTtcbiAgICByZWdpc3RlckZ1bmN0aW9uKGZuLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhKSwge1xuICAgICAgaW1wb3J0UGF0aDogKF9hID0gbWV0YS5pbXBvcnRQYXRoKSAhPSBudWxsID8gX2EgOiBcIlwiXG4gICAgfSkpO1xuICAgIGludGVybmFsU2V0UmVnaXN0ZXJlZEZ1bmN0aW9uKGZuLCBtZXRhKTtcbiAgfVxuICByZWdpc3Rlckdsb2JhbENvbnRleHQoY29udGV4dCwgbWV0YSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLnN1YnN0aXR1dGVDb21wb25lbnQoY29udGV4dCwgeyBuYW1lOiBtZXRhLm5hbWUsIGlzQ29kZTogdHJ1ZSB9KTtcbiAgICByZWdpc3Rlckdsb2JhbENvbnRleHQoY29udGV4dCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWV0YSksIHtcbiAgICAgIGltcG9ydFBhdGg6IChfYSA9IG1ldGEuaW1wb3J0UGF0aCkgIT0gbnVsbCA/IF9hIDogXCJcIlxuICAgIH0pKTtcbiAgfVxuICByZWdpc3RlclRyYWl0KHRyYWl0LCBtZXRhKSB7XG4gICAgcmVnaXN0ZXJUcmFpdCh0cmFpdCwgbWV0YSk7XG4gIH1cbiAgcmVnaXN0ZXJUb2tlbih0b2tlbikge1xuICAgIHJlZ2lzdGVyVG9rZW4odG9rZW4pO1xuICB9XG4gIHN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXIpIHtcbiAgICB0aGlzLnJvb3RzLnB1c2god2F0Y2hlcik7XG4gIH1cbiAgdW5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJvb3RzLmluZGV4T2Yod2F0Y2hlcik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucm9vdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVmcmVzaFJlZ2lzdHJ5KCkge1xuICAgIGZvciAoY29uc3QgZ2xvYmFsR3JvdXAgb2YgdGhpcy5nZXRCdW5kbGUoKS5nbG9iYWxHcm91cHMpIHtcbiAgICAgIGlmIChnbG9iYWxHcm91cC50eXBlICE9PSBcImdsb2JhbC1zY3JlZW5cIikge1xuICAgICAgICBTVUJTVElUVVRFRF9HTE9CQUxfVkFSSUFOVF9IT09LU1tnbG9iYWxHcm91cC5pZF0gPSBjcmVhdGVVc2VHbG9iYWxWYXJpYW50KGdsb2JhbEdyb3VwLm5hbWUsIGdsb2JhbEdyb3VwLnByb2plY3RJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlZnJlc2hSZWdpc3RyeSgpO1xuICB9XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIERhdGFDdHhSZWFkZXIsXG4gIERhdGFQcm92aWRlcixcbiAgR2xvYmFsQWN0aW9uc0NvbnRleHQsXG4gIEdsb2JhbEFjdGlvbnNQcm92aWRlcixcbiAgUGFnZVBhcmFtc1Byb3ZpZGVyIGFzIFBhZ2VQYXJhbXNQcm92aWRlcjIsXG4gIFBsYXNtaWNDYW52YXNDb250ZXh0LFxuICBQbGFzbWljQ2FudmFzSG9zdCxcbiAgUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0LFxuICByZXBlYXRlZEVsZW1lbnQsXG4gIHVzZURhdGFFbnYsXG4gIHVzZVBsYXNtaWNDYW52YXNDb21wb25lbnRJbmZvLFxuICB1c2VQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVNlbGVjdG9yc1xufSBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuaW1wb3J0IHsgdXNlUGxhc21pY1F1ZXJ5RGF0YSB9IGZyb20gXCJAcGxhc21pY2FwcC9xdWVyeVwiO1xuXG4vLyBzcmMvUGxhc21pY0NvbXBvbmVudC50c3hcbmltcG9ydCAqIGFzIFJlYWN0NSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZVBsYXNtaWNDb21wb25lbnQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQbGFzbWljQ29tcG9uZW50KHNwZWMsIG9wdHMgPSB7fSkge1xuICBjb25zdCByb290Q29udGV4dCA9IHVzZVBsYXNtaWNSb290Q29udGV4dCgpO1xuICBpZiAoIXJvb3RDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBjYW4gb25seSB1c2UgdXNlUGxhc21pY0NvbXBvbmVudCBpZiB3cmFwcGVkIGluIDxQbGFzbWljUm9vdFByb3ZpZGVyIC8+YFxuICAgICk7XG4gIH1cbiAgY29uc3QgbG9hZGVyID0gcm9vdENvbnRleHQubG9hZGVyO1xuICBjb25zdCBsb29rdXAgPSBsb2FkZXIuZ2V0TG9va3VwKCk7XG4gIGNvbnN0IGNvbXBvbmVudCA9IGxvb2t1cC5oYXNDb21wb25lbnQoc3BlYykgPyBsb29rdXAuZ2V0Q29tcG9uZW50KHNwZWMsIG9wdHMpIDogdm9pZCAwO1xuICBjb25zdCBzdGFibGVTcGVjID0gdXNlU3RhYmxlTG9va3VwU3BlYyhzcGVjKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICgoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkIGxvYWRlci5mZXRjaENvbXBvbmVudERhdGEoc3RhYmxlU3BlYyk7XG4gICAgICAgIGlmIChpc01vdW50ZWQoKSkge1xuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKSgpO1xuICAgIH1cbiAgfSwgW2NvbXBvbmVudCwgc3RhYmxlU3BlY10pO1xuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG4vLyBzcmMvUGxhc21pY0NvbXBvbmVudC50c3hcbnZhciBQbGFzbWljQ29tcG9uZW50Q29udGV4dCA9IFJlYWN0NS5jcmVhdGVDb250ZXh0KGZhbHNlKTtcbmZ1bmN0aW9uIFBsYXNtaWNDb21wb25lbnQocHJvcHMpIHtcbiAgY29uc3QgeyBjb21wb25lbnQsIHByb2plY3RJZCwgY29tcG9uZW50UHJvcHMsIGZvcmNlT3JpZ2luYWwgfSA9IHByb3BzO1xuICBjb25zdCByb290Q29udGV4dCA9IHVzZVBsYXNtaWNSb290Q29udGV4dCgpO1xuICBjb25zdCBpc1Jvb3RMb2FkZXIgPSAhUmVhY3Q1LnVzZUNvbnRleHQoUGxhc21pY0NvbXBvbmVudENvbnRleHQpO1xuICBpZiAoIXJvb3RDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBtdXN0IHVzZSA8UGxhc21pY1Jvb3RQcm92aWRlci8+IGF0IHRoZSByb290IG9mIHlvdXIgYXBwYFxuICAgICk7XG4gIH1cbiAgY29uc3QgX2EgPSByb290Q29udGV4dCwge1xuICAgIGxvYWRlcixcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIHZhcmlhdGlvbixcbiAgICB1c2VyQXV0aFRva2VuLFxuICAgIGlzVXNlckxvYWRpbmcsXG4gICAgYXV0aFJlZGlyZWN0VXJpLFxuICAgIHRyYW5zbGF0b3JcbiAgfSA9IF9hLCByZXN0ID0gX19vYmpSZXN0KF9hLCBbXG4gICAgXCJsb2FkZXJcIixcbiAgICBcImdsb2JhbENvbnRleHRzUHJvcHNcIixcbiAgICBcInZhcmlhdGlvblwiLFxuICAgIFwidXNlckF1dGhUb2tlblwiLFxuICAgIFwiaXNVc2VyTG9hZGluZ1wiLFxuICAgIFwiYXV0aFJlZGlyZWN0VXJpXCIsXG4gICAgXCJ0cmFuc2xhdG9yXCJcbiAgXSk7XG4gIGNvbnN0IENvbXBvbmVudCA9IHVzZVBsYXNtaWNDb21wb25lbnQoXG4gICAgeyBuYW1lOiBjb21wb25lbnQsIHByb2plY3RJZCwgaXNDb2RlOiBmYWxzZSB9LFxuICAgIHsgZm9yY2VPcmlnaW5hbCB9XG4gICk7XG4gIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1Jvb3RMb2FkZXIpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBsb2FkZXIuZ2V0TG9va3VwKCkuZ2V0Q29tcG9uZW50TWV0YSh7IG5hbWU6IGNvbXBvbmVudCwgcHJvamVjdElkIH0pO1xuICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgbG9hZGVyLnRyYWNrUmVuZGVyKHtcbiAgICAgICAgICByZW5kZXJDdHg6IHtcbiAgICAgICAgICAgIHJvb3RQcm9qZWN0SWQ6IG1ldGEucHJvamVjdElkLFxuICAgICAgICAgICAgcm9vdENvbXBvbmVudElkOiBtZXRhLmlkLFxuICAgICAgICAgICAgcm9vdENvbXBvbmVudE5hbWU6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHRlYW1JZHM6IGxvYWRlci5nZXRUZWFtSWRzKCksXG4gICAgICAgICAgICBwcm9qZWN0SWRzOiBsb2FkZXIuZ2V0UHJvamVjdElkcygpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YXJpYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbY29tcG9uZW50LCBwcm9qZWN0SWQsIGxvYWRlciwgdmFyaWF0aW9uXSk7XG4gIGNvbnN0IGVsZW1lbnQgPSBSZWFjdDUudXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIUNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBlbHQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfX3NwcmVhZFZhbHVlcyh7fSwgY29tcG9uZW50UHJvcHMpKTtcbiAgICBpZiAoaXNSb290TG9hZGVyKSB7XG4gICAgICBjb25zdCBsb29rdXAgPSBsb2FkZXIuZ2V0TG9va3VwKCk7XG4gICAgICBjb25zdCBSZWFjdFdlYlJvb3RQcm92aWRlciA9IGxvb2t1cC5nZXRSb290UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IEdsb2JhbENvbnRleHRzUHJvdmlkZXIgPSBsb29rdXAuZ2V0R2xvYmFsQ29udGV4dHNQcm92aWRlcih7XG4gICAgICAgIG5hbWU6IGNvbXBvbmVudCxcbiAgICAgICAgcHJvamVjdElkXG4gICAgICB9KTtcbiAgICAgIGVsdCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVhY3RXZWJSb290UHJvdmlkZXIsXG4gICAgICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3QpLCB7XG4gICAgICAgICAgdXNlckF1dGhUb2tlbixcbiAgICAgICAgICBpc1VzZXJMb2FkaW5nLFxuICAgICAgICAgIGF1dGhSZWRpcmVjdFVyaSxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICB0cmFuc2xhdG9yLFxuICAgICAgICAgICAgdGFnUHJlZml4OiAoX2EyID0gbG9hZGVyLm9wdHMuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50YWdQcmVmaXhcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgTWF5YmVXcmFwLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbmQ6ICEhR2xvYmFsQ29udGV4dHNQcm92aWRlcixcbiAgICAgICAgICAgIHdyYXBwZXI6IChjaGlsZHJlbikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KEdsb2JhbENvbnRleHRzUHJvdmlkZXIsIF9fc3ByZWFkVmFsdWVzKHt9LCBnbG9iYWxDb250ZXh0c1Byb3BzKSwgY2hpbGRyZW4pXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoUGxhc21pY0NvbXBvbmVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRydWUgfSwgZWx0KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9LCBbXG4gICAgQ29tcG9uZW50LFxuICAgIGNvbXBvbmVudFByb3BzLFxuICAgIGxvYWRlcixcbiAgICBpc1Jvb3RMb2FkZXIsXG4gICAgY29tcG9uZW50LFxuICAgIHByb2plY3RJZCxcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIHVzZXJBdXRoVG9rZW4sXG4gICAgLy8gSnVzdCB1c2UgdGhlIHRva2VuIHRvIG1lbW8sIGB1c2VyYCBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIGl0XG4gICAgaXNVc2VyTG9hZGluZyxcbiAgICBhdXRoUmVkaXJlY3RVcmlcbiAgXSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vLyBzcmMvcHJlcGFzcy1jbGllbnQudHNcbmltcG9ydCB7XG4gIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhIGFzIGludGVybmFsRXh0cmFjdFF1ZXJ5RGF0YSxcbiAgcGxhc21pY1ByZXBhc3MgYXMgaW50ZXJuYWxQbGFzbWljUHJlcGFzc1xufSBmcm9tIFwiQHBsYXNtaWNhcHAvcHJlcGFzc1wiO1xuZnVuY3Rpb24gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoZWxlbWVudCkge1xuICByZXR1cm4gaW50ZXJuYWxFeHRyYWN0UXVlcnlEYXRhKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gcGxhc21pY1ByZXBhc3MoZWxlbWVudCkge1xuICByZXR1cm4gaW50ZXJuYWxQbGFzbWljUHJlcGFzcyhlbGVtZW50KTtcbn1cblxuLy8gc3JjL3JlbmRlci50c3hcbmltcG9ydCB7IGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhIGFzIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhMiB9IGZyb20gXCJAcGxhc21pY2FwcC9wcmVwYXNzXCI7XG5pbXBvcnQgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NMiBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyByZW5kZXJUb1N0cmluZyBhcyByZWFjdFJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcbmZ1bmN0aW9uIHJlbmRlclRvRWxlbWVudChfMCwgXzEsIF8yKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChsb2FkZXIsIHRhcmdldCwgbG9va3VwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyk7XG4gICAgICBSZWFjdERPTTIucmVuZGVyKGVsZW1lbnQsIHRhcmdldCwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhsb2FkZXIsIGxvb2t1cCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyk7XG4gIHJldHVybiByZWFjdFJlbmRlclRvU3RyaW5nKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGFGcm9tRWxlbWVudChfMCwgXzEpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKGxvYWRlciwgbG9va3VwLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gbWFrZUVsZW1lbnQobG9hZGVyLCBsb29rdXAsIG9wdHMpO1xuICAgIHJldHVybiBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YTIoZWxlbWVudCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUZyb21FbGVtZW50KF8wLCBfMSwgXzIpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKGxvYWRlciwgdGFyZ2V0LCBsb29rdXAsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG1ha2VFbGVtZW50KGxvYWRlciwgbG9va3VwLCBvcHRzKTtcbiAgICAgIFJlYWN0RE9NMi5oeWRyYXRlKGVsZW1lbnQsIHRhcmdldCwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgUGxhc21pY1Jvb3RQcm92aWRlcixcbiAgICB7XG4gICAgICBsb2FkZXIsXG4gICAgICBwcmVmZXRjaGVkRGF0YTogb3B0cy5wcmVmZXRjaGVkRGF0YSxcbiAgICAgIGdsb2JhbFZhcmlhbnRzOiBvcHRzLmdsb2JhbFZhcmlhbnRzLFxuICAgICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YTogb3B0cy5wcmVmZXRjaGVkUXVlcnlEYXRhLFxuICAgICAgcGFnZVBhcmFtczogb3B0cy5wYWdlUGFyYW1zLFxuICAgICAgcGFnZVF1ZXJ5OiBvcHRzLnBhZ2VRdWVyeVxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFxuICAgICAgUGxhc21pY0NvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50OiB0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gbG9va3VwIDogbG9va3VwLm5hbWUsXG4gICAgICAgIHByb2plY3RJZDogdHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGxvb2t1cC5wcm9qZWN0SWQsXG4gICAgICAgIGNvbXBvbmVudFByb3BzOiBvcHRzLmNvbXBvbmVudFByb3BzXG4gICAgICB9XG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGluaXRQbGFzbWljTG9hZGVyKG9wdHMpIHtcbiAgY29uc3QgaW50ZXJuYWwgPSBuZXcgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyKG9wdHMpO1xuICByZXR1cm4gbmV3IFBsYXNtaWNDb21wb25lbnRMb2FkZXIoaW50ZXJuYWwpO1xufVxuZXhwb3J0IHtcbiAgRGF0YUN0eFJlYWRlcixcbiAgRGF0YVByb3ZpZGVyLFxuICBHbG9iYWxBY3Rpb25zQ29udGV4dCxcbiAgR2xvYmFsQWN0aW9uc1Byb3ZpZGVyLFxuICBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIFBhZ2VQYXJhbXNQcm92aWRlcjIgYXMgUGFnZVBhcmFtc1Byb3ZpZGVyLFxuICBQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgUGxhc21pY0NhbnZhc0hvc3QsXG4gIFBsYXNtaWNDb21wb25lbnQsXG4gIFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIFBsYXNtaWNSb290UHJvdmlkZXIsXG4gIFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCxcbiAgY29udmVydEJ1bmRsZXNUb0NvbXBvbmVudFJlbmRlckRhdGEsXG4gIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhLFxuICBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YUZyb21FbGVtZW50LFxuICBoeWRyYXRlRnJvbUVsZW1lbnQsXG4gIGluaXRQbGFzbWljTG9hZGVyLFxuICBtYXRjaGVzUGFnZVBhdGgsXG4gIHBsYXNtaWNQcmVwYXNzLFxuICByZW5kZXJUb0VsZW1lbnQsXG4gIHJlbmRlclRvU3RyaW5nLFxuICByZXBlYXRlZEVsZW1lbnQsXG4gIHVzZURhdGFFbnYsXG4gIHVzZVBsYXNtaWNDYW52YXNDb21wb25lbnRJbmZvLFxuICB1c2VQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgdXNlUGxhc21pY0NvbXBvbmVudCxcbiAgdXNlUGxhc21pY1F1ZXJ5RGF0YSxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVNlbGVjdG9yc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-splits/dist/index.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   describeVariation: () => (/* binding */ describeVariation),\n/* harmony export */   describeVariationForKey: () => (/* binding */ describeVariationForKey),\n/* harmony export */   getActiveVariation: () => (/* binding */ getActiveVariation),\n/* harmony export */   getExternalIds: () => (/* binding */ getExternalIds),\n/* harmony export */   getSeededRandomFunction: () => (/* binding */ getSeededRandomFunction),\n/* harmony export */   getSplitKey: () => (/* binding */ getSplitKey)\n/* harmony export */ });\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-logic-js */ \"(pages-dir-browser)/./node_modules/json-logic-js/logic.js\");\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_logic_js__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/random.ts\nvar getSeededRandomFunction = (strSeed) => {\n  function cyrb128(str) {\n    let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;\n    for (let i = 0, k; i < str.length; i++) {\n      k = str.charCodeAt(i);\n      h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n      h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n      h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n      h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n    }\n    h1 = Math.imul(h3 ^ h1 >>> 18, 597399067);\n    h2 = Math.imul(h4 ^ h2 >>> 22, 2869860233);\n    h3 = Math.imul(h1 ^ h3 >>> 17, 951274213);\n    h4 = Math.imul(h2 ^ h4 >>> 19, 2716044179);\n    return [\n      (h1 ^ h2 ^ h3 ^ h4) >>> 0,\n      (h2 ^ h1) >>> 0,\n      (h3 ^ h1) >>> 0,\n      (h4 ^ h1) >>> 0\n    ];\n  }\n  function sfc32(a, b, c, d) {\n    return function() {\n      a >>>= 0;\n      b >>>= 0;\n      c >>>= 0;\n      d >>>= 0;\n      let t = a + b | 0;\n      a = b ^ b >>> 9;\n      b = c + (c << 3) | 0;\n      c = c << 21 | c >>> 11;\n      d = d + 1 | 0;\n      t = t + d | 0;\n      c = c + t | 0;\n      return (t >>> 0) / 4294967296;\n    };\n  }\n  const seed = cyrb128(strSeed);\n  const rand = sfc32(seed[0], seed[1], seed[2], seed[3]);\n  return rand;\n};\n\n// src/variation.ts\n\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nvar PLASMIC_SEED = \"plasmic_seed\";\nvar BUILTIN_TRAITS_UNKNOWN = {\n  pageUrl: \"unknown\"\n};\nvar getBrowserBuiltinTraits = () => {\n  if (!isBrowser) {\n    return {};\n  }\n  return {\n    pageUrl: document.location.href\n  };\n};\nvar getSplitKey = (split) => {\n  return `${split.type === \"experiment\" ? \"exp.\" : \"seg.\"}${split.id}`;\n};\nfunction getActiveVariation(opts) {\n  const { splits, getKnownValue, updateKnownValue } = opts;\n  const getRandomValue = (key) => {\n    var _a;\n    if (opts.getRandomValue) {\n      return opts.getRandomValue(key);\n    }\n    if (opts.traits[PLASMIC_SEED]) {\n      const rand = getSeededRandomFunction(\n        ((_a = opts.traits[PLASMIC_SEED]) != null ? _a : \"\") + key\n      );\n      return rand();\n    }\n    if (!opts.enableUnseededExperiments) {\n      return 0;\n    }\n    return Math.random();\n  };\n  const variation = {};\n  splits.forEach((split) => {\n    var _a;\n    const key = getSplitKey(split);\n    const knownVal = split.type === \"experiment\" ? getKnownValue == null ? void 0 : getKnownValue(key) : void 0;\n    if (knownVal) {\n      variation[key] = knownVal;\n      return;\n    }\n    const numSlices = split.slices.length;\n    let chosenSlice = void 0;\n    if (split.type === \"experiment\") {\n      if (opts.useSeedBucketing) {\n        const seed = opts.traits[PLASMIC_SEED];\n        const buckets = [];\n        const totalBuckets = (_a = opts.seedRange) != null ? _a : 1;\n        let avaiableBuckets = totalBuckets;\n        for (let i = 0; i < numSlices; i++) {\n          const slice = split.slices[i];\n          const numBuckets = Math.min(\n            Math.floor(slice.prob * totalBuckets),\n            avaiableBuckets\n          );\n          for (let j = 0; j < numBuckets; j++) {\n            buckets.push(slice.id);\n          }\n          avaiableBuckets -= numBuckets;\n        }\n        if (buckets.length > 0) {\n          const shuffleRand = getSeededRandomFunction(split.id);\n          for (let i = 0; i < buckets.length; i++) {\n            const j = Math.floor(shuffleRand() * (i + 1));\n            [buckets[i], buckets[j]] = [buckets[j], buckets[i]];\n          }\n          const sliceIdx = +(seed != null ? seed : \"0\") % buckets.length;\n          chosenSlice = split.slices.find((s) => s.id === buckets[sliceIdx]);\n        } else {\n          chosenSlice = split.slices[numSlices - 1];\n        }\n      } else {\n        let p = getRandomValue(split.id);\n        chosenSlice = split.slices[numSlices - 1];\n        for (let i = 0; i < numSlices; i++) {\n          if (p - split.slices[i].prob <= 0) {\n            chosenSlice = split.slices[i];\n            break;\n          }\n          p -= split.slices[i].prob;\n        }\n      }\n    } else if (split.type === \"segment\") {\n      for (let i = 0; i < numSlices; i++) {\n        if (json_logic_js__WEBPACK_IMPORTED_MODULE_0___default().apply(split.slices[i].cond, __spreadValues(__spreadValues(__spreadValues({\n          time: (/* @__PURE__ */ new Date()).toISOString()\n        }, BUILTIN_TRAITS_UNKNOWN), getBrowserBuiltinTraits()), opts.traits))) {\n          chosenSlice = split.slices[i];\n        }\n      }\n    }\n    if (chosenSlice) {\n      variation[key] = chosenSlice.id;\n      if (split.externalId && chosenSlice.externalId) {\n        variation[`ext.${split.externalId}`] = chosenSlice.externalId;\n      }\n      if (split.type === \"experiment\") {\n        updateKnownValue == null ? void 0 : updateKnownValue(key, chosenSlice.id);\n      }\n    }\n  });\n  return variation;\n}\nfunction getExternalIds(splits, variation, filters) {\n  const externalVariation = {};\n  function shouldIncludeSplit(split) {\n    if (!filters) {\n      return true;\n    }\n    if (filters.projectIds && !filters.projectIds.includes(split.projectId)) {\n      return false;\n    }\n    if (filters.customFilter && !filters.customFilter(split)) {\n      return false;\n    }\n    return true;\n  }\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split && split.externalId && shouldIncludeSplit(split)) {\n      const slice = split.slices.find((s) => s.id === sliceId || s.externalId === sliceId);\n      if (slice == null ? void 0 : slice.externalId) {\n        externalVariation[`${split.externalId}`] = slice.externalId;\n      }\n    }\n  });\n  return externalVariation;\n}\nfunction describeVariationForKey(splits, key, value) {\n  const [, splitId] = key.split(\".\");\n  const split = splits.find(\n    (s) => s.id === splitId || s.externalId === splitId\n  );\n  if (!split) {\n    throw new Error(`Split not found for key \"${key}\"`);\n  }\n  const sliceIndex = split.slices.findIndex(\n    (s) => s.id === value || s.externalId === value\n  );\n  if (sliceIndex === -1) {\n    throw new Error(`Invalid split value \"${value}\" for key \"${key}\"`);\n  }\n  return {\n    name: split.name,\n    description: split.description,\n    pagesPaths: split.pagesPaths,\n    type: sliceIndex === 0 ? \"original\" : \"override\",\n    chosenValue: value,\n    externalIdGroup: split.externalId,\n    externalIdValue: sliceIndex >= 0 && split.slices[sliceIndex].externalId ? split.slices[sliceIndex].externalId : void 0\n  };\n}\nfunction describeVariation(splits, variation) {\n  return Object.fromEntries(\n    Object.entries(variation).map(([key, value]) => {\n      return [key, describeVariationForKey(splits, key, value)];\n    })\n  );\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItc3BsaXRzL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDLEVBQUUsU0FBUztBQUNyRTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixlQUFlO0FBQ3JDLFlBQVksMERBQWU7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxhQUFhLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXEBwbGFzbWljYXBwXFxsb2FkZXItc3BsaXRzXFxkaXN0XFxpbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vLyBzcmMvcmFuZG9tLnRzXG52YXIgZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24gPSAoc3RyU2VlZCkgPT4ge1xuICBmdW5jdGlvbiBjeXJiMTI4KHN0cikge1xuICAgIGxldCBoMSA9IDE3NzkwMzM3MDMsIGgyID0gMzE0NDEzNDI3NywgaDMgPSAxMDEzOTA0MjQyLCBoNCA9IDI3NzM0ODA3NjI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGs7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGsgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGgxID0gaDIgXiBNYXRoLmltdWwoaDEgXiBrLCA1OTczOTkwNjcpO1xuICAgICAgaDIgPSBoMyBeIE1hdGguaW11bChoMiBeIGssIDI4Njk4NjAyMzMpO1xuICAgICAgaDMgPSBoNCBeIE1hdGguaW11bChoMyBeIGssIDk1MTI3NDIxMyk7XG4gICAgICBoNCA9IGgxIF4gTWF0aC5pbXVsKGg0IF4gaywgMjcxNjA0NDE3OSk7XG4gICAgfVxuICAgIGgxID0gTWF0aC5pbXVsKGgzIF4gaDEgPj4+IDE4LCA1OTczOTkwNjcpO1xuICAgIGgyID0gTWF0aC5pbXVsKGg0IF4gaDIgPj4+IDIyLCAyODY5ODYwMjMzKTtcbiAgICBoMyA9IE1hdGguaW11bChoMSBeIGgzID4+PiAxNywgOTUxMjc0MjEzKTtcbiAgICBoNCA9IE1hdGguaW11bChoMiBeIGg0ID4+PiAxOSwgMjcxNjA0NDE3OSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIChoMSBeIGgyIF4gaDMgXiBoNCkgPj4+IDAsXG4gICAgICAoaDIgXiBoMSkgPj4+IDAsXG4gICAgICAoaDMgXiBoMSkgPj4+IDAsXG4gICAgICAoaDQgXiBoMSkgPj4+IDBcbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIHNmYzMyKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBhID4+Pj0gMDtcbiAgICAgIGIgPj4+PSAwO1xuICAgICAgYyA+Pj49IDA7XG4gICAgICBkID4+Pj0gMDtcbiAgICAgIGxldCB0ID0gYSArIGIgfCAwO1xuICAgICAgYSA9IGIgXiBiID4+PiA5O1xuICAgICAgYiA9IGMgKyAoYyA8PCAzKSB8IDA7XG4gICAgICBjID0gYyA8PCAyMSB8IGMgPj4+IDExO1xuICAgICAgZCA9IGQgKyAxIHwgMDtcbiAgICAgIHQgPSB0ICsgZCB8IDA7XG4gICAgICBjID0gYyArIHQgfCAwO1xuICAgICAgcmV0dXJuICh0ID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG4gICAgfTtcbiAgfVxuICBjb25zdCBzZWVkID0gY3lyYjEyOChzdHJTZWVkKTtcbiAgY29uc3QgcmFuZCA9IHNmYzMyKHNlZWRbMF0sIHNlZWRbMV0sIHNlZWRbMl0sIHNlZWRbM10pO1xuICByZXR1cm4gcmFuZDtcbn07XG5cbi8vIHNyYy92YXJpYXRpb24udHNcbmltcG9ydCBqc29uTG9naWMgZnJvbSBcImpzb24tbG9naWMtanNcIjtcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgUExBU01JQ19TRUVEID0gXCJwbGFzbWljX3NlZWRcIjtcbnZhciBCVUlMVElOX1RSQUlUU19VTktOT1dOID0ge1xuICBwYWdlVXJsOiBcInVua25vd25cIlxufTtcbnZhciBnZXRCcm93c2VyQnVpbHRpblRyYWl0cyA9ICgpID0+IHtcbiAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYWdlVXJsOiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmXG4gIH07XG59O1xudmFyIGdldFNwbGl0S2V5ID0gKHNwbGl0KSA9PiB7XG4gIHJldHVybiBgJHtzcGxpdC50eXBlID09PSBcImV4cGVyaW1lbnRcIiA/IFwiZXhwLlwiIDogXCJzZWcuXCJ9JHtzcGxpdC5pZH1gO1xufTtcbmZ1bmN0aW9uIGdldEFjdGl2ZVZhcmlhdGlvbihvcHRzKSB7XG4gIGNvbnN0IHsgc3BsaXRzLCBnZXRLbm93blZhbHVlLCB1cGRhdGVLbm93blZhbHVlIH0gPSBvcHRzO1xuICBjb25zdCBnZXRSYW5kb21WYWx1ZSA9IChrZXkpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdHMuZ2V0UmFuZG9tVmFsdWUpIHtcbiAgICAgIHJldHVybiBvcHRzLmdldFJhbmRvbVZhbHVlKGtleSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnRyYWl0c1tQTEFTTUlDX1NFRURdKSB7XG4gICAgICBjb25zdCByYW5kID0gZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24oXG4gICAgICAgICgoX2EgPSBvcHRzLnRyYWl0c1tQTEFTTUlDX1NFRURdKSAhPSBudWxsID8gX2EgOiBcIlwiKSArIGtleVxuICAgICAgKTtcbiAgICAgIHJldHVybiByYW5kKCk7XG4gICAgfVxuICAgIGlmICghb3B0cy5lbmFibGVVbnNlZWRlZEV4cGVyaW1lbnRzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGNvbnN0IHZhcmlhdGlvbiA9IHt9O1xuICBzcGxpdHMuZm9yRWFjaCgoc3BsaXQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qga2V5ID0gZ2V0U3BsaXRLZXkoc3BsaXQpO1xuICAgIGNvbnN0IGtub3duVmFsID0gc3BsaXQudHlwZSA9PT0gXCJleHBlcmltZW50XCIgPyBnZXRLbm93blZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBnZXRLbm93blZhbHVlKGtleSkgOiB2b2lkIDA7XG4gICAgaWYgKGtub3duVmFsKSB7XG4gICAgICB2YXJpYXRpb25ba2V5XSA9IGtub3duVmFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBudW1TbGljZXMgPSBzcGxpdC5zbGljZXMubGVuZ3RoO1xuICAgIGxldCBjaG9zZW5TbGljZSA9IHZvaWQgMDtcbiAgICBpZiAoc3BsaXQudHlwZSA9PT0gXCJleHBlcmltZW50XCIpIHtcbiAgICAgIGlmIChvcHRzLnVzZVNlZWRCdWNrZXRpbmcpIHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IG9wdHMudHJhaXRzW1BMQVNNSUNfU0VFRF07XG4gICAgICAgIGNvbnN0IGJ1Y2tldHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG90YWxCdWNrZXRzID0gKF9hID0gb3B0cy5zZWVkUmFuZ2UpICE9IG51bGwgPyBfYSA6IDE7XG4gICAgICAgIGxldCBhdmFpYWJsZUJ1Y2tldHMgPSB0b3RhbEJ1Y2tldHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2xpY2VzOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzbGljZSA9IHNwbGl0LnNsaWNlc1tpXTtcbiAgICAgICAgICBjb25zdCBudW1CdWNrZXRzID0gTWF0aC5taW4oXG4gICAgICAgICAgICBNYXRoLmZsb29yKHNsaWNlLnByb2IgKiB0b3RhbEJ1Y2tldHMpLFxuICAgICAgICAgICAgYXZhaWFibGVCdWNrZXRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUJ1Y2tldHM7IGorKykge1xuICAgICAgICAgICAgYnVja2V0cy5wdXNoKHNsaWNlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZhaWFibGVCdWNrZXRzIC09IG51bUJ1Y2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1Y2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNodWZmbGVSYW5kID0gZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24oc3BsaXQuaWQpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3Ioc2h1ZmZsZVJhbmQoKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgW2J1Y2tldHNbaV0sIGJ1Y2tldHNbal1dID0gW2J1Y2tldHNbal0sIGJ1Y2tldHNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzbGljZUlkeCA9ICsoc2VlZCAhPSBudWxsID8gc2VlZCA6IFwiMFwiKSAlIGJ1Y2tldHMubGVuZ3RoO1xuICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzLmZpbmQoKHMpID0+IHMuaWQgPT09IGJ1Y2tldHNbc2xpY2VJZHhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaG9zZW5TbGljZSA9IHNwbGl0LnNsaWNlc1tudW1TbGljZXMgLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHAgPSBnZXRSYW5kb21WYWx1ZShzcGxpdC5pZCk7XG4gICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW251bVNsaWNlcyAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNsaWNlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKHAgLSBzcGxpdC5zbGljZXNbaV0ucHJvYiA8PSAwKSB7XG4gICAgICAgICAgICBjaG9zZW5TbGljZSA9IHNwbGl0LnNsaWNlc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwIC09IHNwbGl0LnNsaWNlc1tpXS5wcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzcGxpdC50eXBlID09PSBcInNlZ21lbnRcIikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGljZXM7IGkrKykge1xuICAgICAgICBpZiAoanNvbkxvZ2ljLmFwcGx5KHNwbGl0LnNsaWNlc1tpXS5jb25kLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgdGltZTogKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0sIEJVSUxUSU5fVFJBSVRTX1VOS05PV04pLCBnZXRCcm93c2VyQnVpbHRpblRyYWl0cygpKSwgb3B0cy50cmFpdHMpKSkge1xuICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaG9zZW5TbGljZSkge1xuICAgICAgdmFyaWF0aW9uW2tleV0gPSBjaG9zZW5TbGljZS5pZDtcbiAgICAgIGlmIChzcGxpdC5leHRlcm5hbElkICYmIGNob3NlblNsaWNlLmV4dGVybmFsSWQpIHtcbiAgICAgICAgdmFyaWF0aW9uW2BleHQuJHtzcGxpdC5leHRlcm5hbElkfWBdID0gY2hvc2VuU2xpY2UuZXh0ZXJuYWxJZDtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdC50eXBlID09PSBcImV4cGVyaW1lbnRcIikge1xuICAgICAgICB1cGRhdGVLbm93blZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB1cGRhdGVLbm93blZhbHVlKGtleSwgY2hvc2VuU2xpY2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5mdW5jdGlvbiBnZXRFeHRlcm5hbElkcyhzcGxpdHMsIHZhcmlhdGlvbiwgZmlsdGVycykge1xuICBjb25zdCBleHRlcm5hbFZhcmlhdGlvbiA9IHt9O1xuICBmdW5jdGlvbiBzaG91bGRJbmNsdWRlU3BsaXQoc3BsaXQpIHtcbiAgICBpZiAoIWZpbHRlcnMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5wcm9qZWN0SWRzICYmICFmaWx0ZXJzLnByb2plY3RJZHMuaW5jbHVkZXMoc3BsaXQucHJvamVjdElkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5jdXN0b21GaWx0ZXIgJiYgIWZpbHRlcnMuY3VzdG9tRmlsdGVyKHNwbGl0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBPYmplY3Qua2V5cyh2YXJpYXRpb24pLmZvckVhY2goKHZhcmlhdGlvbktleSkgPT4ge1xuICAgIGNvbnN0IFssIHNwbGl0SWRdID0gdmFyaWF0aW9uS2V5LnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBzbGljZUlkID0gdmFyaWF0aW9uW3ZhcmlhdGlvbktleV07XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdHMuZmluZChcbiAgICAgIChzKSA9PiBzLmlkID09PSBzcGxpdElkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc3BsaXRJZFxuICAgICk7XG4gICAgaWYgKHNwbGl0ICYmIHNwbGl0LmV4dGVybmFsSWQgJiYgc2hvdWxkSW5jbHVkZVNwbGl0KHNwbGl0KSkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBzcGxpdC5zbGljZXMuZmluZCgocykgPT4gcy5pZCA9PT0gc2xpY2VJZCB8fCBzLmV4dGVybmFsSWQgPT09IHNsaWNlSWQpO1xuICAgICAgaWYgKHNsaWNlID09IG51bGwgPyB2b2lkIDAgOiBzbGljZS5leHRlcm5hbElkKSB7XG4gICAgICAgIGV4dGVybmFsVmFyaWF0aW9uW2Ake3NwbGl0LmV4dGVybmFsSWR9YF0gPSBzbGljZS5leHRlcm5hbElkO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBleHRlcm5hbFZhcmlhdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlVmFyaWF0aW9uRm9yS2V5KHNwbGl0cywga2V5LCB2YWx1ZSkge1xuICBjb25zdCBbLCBzcGxpdElkXSA9IGtleS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IHNwbGl0ID0gc3BsaXRzLmZpbmQoXG4gICAgKHMpID0+IHMuaWQgPT09IHNwbGl0SWQgfHwgcy5leHRlcm5hbElkID09PSBzcGxpdElkXG4gICk7XG4gIGlmICghc3BsaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNwbGl0IG5vdCBmb3VuZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgfVxuICBjb25zdCBzbGljZUluZGV4ID0gc3BsaXQuc2xpY2VzLmZpbmRJbmRleChcbiAgICAocykgPT4gcy5pZCA9PT0gdmFsdWUgfHwgcy5leHRlcm5hbElkID09PSB2YWx1ZVxuICApO1xuICBpZiAoc2xpY2VJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3BsaXQgdmFsdWUgXCIke3ZhbHVlfVwiIGZvciBrZXkgXCIke2tleX1cImApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogc3BsaXQubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc3BsaXQuZGVzY3JpcHRpb24sXG4gICAgcGFnZXNQYXRoczogc3BsaXQucGFnZXNQYXRocyxcbiAgICB0eXBlOiBzbGljZUluZGV4ID09PSAwID8gXCJvcmlnaW5hbFwiIDogXCJvdmVycmlkZVwiLFxuICAgIGNob3NlblZhbHVlOiB2YWx1ZSxcbiAgICBleHRlcm5hbElkR3JvdXA6IHNwbGl0LmV4dGVybmFsSWQsXG4gICAgZXh0ZXJuYWxJZFZhbHVlOiBzbGljZUluZGV4ID49IDAgJiYgc3BsaXQuc2xpY2VzW3NsaWNlSW5kZXhdLmV4dGVybmFsSWQgPyBzcGxpdC5zbGljZXNbc2xpY2VJbmRleF0uZXh0ZXJuYWxJZCA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gZGVzY3JpYmVWYXJpYXRpb24oc3BsaXRzLCB2YXJpYXRpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh2YXJpYXRpb24pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2tleSwgZGVzY3JpYmVWYXJpYXRpb25Gb3JLZXkoc3BsaXRzLCBrZXksIHZhbHVlKV07XG4gICAgfSlcbiAgKTtcbn1cbmV4cG9ydCB7XG4gIGRlc2NyaWJlVmFyaWF0aW9uLFxuICBkZXNjcmliZVZhcmlhdGlvbkZvcktleSxcbiAgZ2V0QWN0aXZlVmFyaWF0aW9uLFxuICBnZXRFeHRlcm5hbElkcyxcbiAgZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24sXG4gIGdldFNwbGl0S2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/nextjs-app-router/dist/index.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@plasmicapp/nextjs-app-router/dist/index.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtractPlasmicQueryData: () => (/* binding */ ExtractPlasmicQueryData)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/prepass */ \"(pages-dir-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\"use client\";\n\n// src/ExtractPlasmicQueryData.tsx\n\n\nfunction ExtractPlasmicQueryData(props) {\n  const { children } = props;\n  if (!(\"useId\" in react__WEBPACK_IMPORTED_MODULE_1__) || !(\"use\" in react__WEBPACK_IMPORTED_MODULE_1__)) {\n    throw new Error(\n      `You can only use <ExtractPlasmicQueryData /> from server components.`\n    );\n  }\n  const scriptId = `plasmic-prefetch-${react__WEBPACK_IMPORTED_MODULE_1__.useId()}`;\n  if (typeof window === \"undefined\") {\n    const {\n      queryData,\n      headMetadata\n    } = react__WEBPACK_IMPORTED_MODULE_1__.use((0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_0__.plasmicPrepassExtract)(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children)));\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      \"script\",\n      {\n        type: \"application/json\",\n        dangerouslySetInnerHTML: { __html: JSON.stringify(queryData) },\n        \"data-plasmic-prefetch-id\": scriptId,\n        suppressHydrationWarning: true\n      }\n    ), headMetadata && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      \"script\",\n      {\n        type: \"application/json\",\n        dangerouslySetInnerHTML: {\n          __html: JSON.stringify(headMetadata)\n        },\n        \"data-plasmic-head-metadata-id\": scriptId,\n        suppressHydrationWarning: true\n      }\n    ));\n  } else {\n    return null;\n  }\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9uZXh0anMtYXBwLXJvdXRlci9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7QUFDNEQ7QUFDN0I7QUFDL0I7QUFDQSxVQUFVLFdBQVc7QUFDckIsUUFBUSw2Q0FBZ0IsT0FBTywyQ0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBYyxHQUFHO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLHNDQUFZLENBQUMsMEVBQXFCLGlCQUFpQixnREFBbUIsQ0FBQywyQ0FBYztBQUM3RiwyQkFBMkIsZ0RBQW1CLENBQUMsMkNBQWMsd0JBQXdCLGdEQUFtQjtBQUN4RztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnREFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXEBwbGFzbWljYXBwXFxuZXh0anMtYXBwLXJvdXRlclxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG4vLyBzcmMvRXh0cmFjdFBsYXNtaWNRdWVyeURhdGEudHN4XG5pbXBvcnQgeyBwbGFzbWljUHJlcGFzc0V4dHJhY3QgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcHJlcGFzc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBFeHRyYWN0UGxhc21pY1F1ZXJ5RGF0YShwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgaWYgKCEoXCJ1c2VJZFwiIGluIFJlYWN0KSB8fCAhKFwidXNlXCIgaW4gUmVhY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBjYW4gb25seSB1c2UgPEV4dHJhY3RQbGFzbWljUXVlcnlEYXRhIC8+IGZyb20gc2VydmVyIGNvbXBvbmVudHMuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2NyaXB0SWQgPSBgcGxhc21pYy1wcmVmZXRjaC0ke1JlYWN0W1widXNlSWRcIl0oKX1gO1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5RGF0YSxcbiAgICAgIGhlYWRNZXRhZGF0YVxuICAgIH0gPSBSZWFjdFtcInVzZVwiXShwbGFzbWljUHJlcGFzc0V4dHJhY3QoLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBKU09OLnN0cmluZ2lmeShxdWVyeURhdGEpIH0sXG4gICAgICAgIFwiZGF0YS1wbGFzbWljLXByZWZldGNoLWlkXCI6IHNjcmlwdElkLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWVcbiAgICAgIH1cbiAgICApLCBoZWFkTWV0YWRhdGEgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IEpTT04uc3RyaW5naWZ5KGhlYWRNZXRhZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLXBsYXNtaWMtaGVhZC1tZXRhZGF0YS1pZFwiOiBzY3JpcHRJZCxcbiAgICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlXG4gICAgICB9XG4gICAgKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEV4dHJhY3RQbGFzbWljUXVlcnlEYXRhXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/nextjs-app-router/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@plasmicapp/prepass/dist/index.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   plasmicPrepassExtract: () => (/* binding */ plasmicPrepassExtract)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(pages-dir-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/react-ssr-prepass */ \"(pages-dir-browser)/./node_modules/@plasmicapp/prepass/node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nasync function plasmicPrepassExtract(element, onClientComponentRef) {\n  const cache = /* @__PURE__ */ new Map();\n  const headMetadata = {};\n  try {\n    await plasmicPrepass(\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.PlasmicPrepassContext, { cache }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.HeadMetadataContext.Provider, { value: headMetadata }, element)),\n      onClientComponentRef\n    );\n  } catch (err) {\n    console.warn(`PLASMIC: Error encountered while pre-rendering`, err);\n  }\n  const filteredCache = Object.fromEntries(\n    Array.from(cache.entries()).filter(\n      ([key, val]) => !key.startsWith(\"$swr$\") && !key.startsWith(\"$csq$\") && val !== void 0\n    )\n  );\n  const queryData = (() => {\n    try {\n      return JSON.parse(\n        JSON.stringify(\n          filteredCache,\n          (_key, value) => value !== void 0 ? value : null\n        )\n      );\n    } catch {\n      return filteredCache;\n    }\n  })();\n  return {\n    queryData,\n    headMetadata\n  };\n}\nasync function extractPlasmicQueryData(element, onClientComponentRef) {\n  return (await plasmicPrepassExtract(element, onClientComponentRef)).queryData;\n}\nasync function plasmicPrepass(element, onClientComponentRef) {\n  await (0,_plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, void 0, onClientComponentRef);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9wcmVwYXNzL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHMkI7QUFDeUI7QUFDMUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBbUIsQ0FBQyxvRUFBcUIsSUFBSSxPQUFPLGtCQUFrQiwwREFBbUIsQ0FBQyxrRUFBbUIsYUFBYSxxQkFBcUI7QUFDcks7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFPO0FBQ2Y7QUFLRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxccHJlcGFzc1xcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEhlYWRNZXRhZGF0YUNvbnRleHQsXG4gIFBsYXNtaWNQcmVwYXNzQ29udGV4dFxufSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCBwcmVwYXNzIGZyb20gXCJAcGxhc21pY2FwcC9yZWFjdC1zc3ItcHJlcGFzc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuYXN5bmMgZnVuY3Rpb24gcGxhc21pY1ByZXBhc3NFeHRyYWN0KGVsZW1lbnQsIG9uQ2xpZW50Q29tcG9uZW50UmVmKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgaGVhZE1ldGFkYXRhID0ge307XG4gIHRyeSB7XG4gICAgYXdhaXQgcGxhc21pY1ByZXBhc3MoXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQbGFzbWljUHJlcGFzc0NvbnRleHQsIHsgY2FjaGUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZE1ldGFkYXRhQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogaGVhZE1ldGFkYXRhIH0sIGVsZW1lbnQpKSxcbiAgICAgIG9uQ2xpZW50Q29tcG9uZW50UmVmXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS53YXJuKGBQTEFTTUlDOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBwcmUtcmVuZGVyaW5nYCwgZXJyKTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZENhY2hlID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIEFycmF5LmZyb20oY2FjaGUuZW50cmllcygpKS5maWx0ZXIoXG4gICAgICAoW2tleSwgdmFsXSkgPT4gIWtleS5zdGFydHNXaXRoKFwiJHN3ciRcIikgJiYgIWtleS5zdGFydHNXaXRoKFwiJGNzcSRcIikgJiYgdmFsICE9PSB2b2lkIDBcbiAgICApXG4gICk7XG4gIGNvbnN0IHF1ZXJ5RGF0YSA9ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKFxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBmaWx0ZXJlZENhY2hlLFxuICAgICAgICAgIChfa2V5LCB2YWx1ZSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogbnVsbFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZpbHRlcmVkQ2FjaGU7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4ge1xuICAgIHF1ZXJ5RGF0YSxcbiAgICBoZWFkTWV0YWRhdGFcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhKGVsZW1lbnQsIG9uQ2xpZW50Q29tcG9uZW50UmVmKSB7XG4gIHJldHVybiAoYXdhaXQgcGxhc21pY1ByZXBhc3NFeHRyYWN0KGVsZW1lbnQsIG9uQ2xpZW50Q29tcG9uZW50UmVmKSkucXVlcnlEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gcGxhc21pY1ByZXBhc3MoZWxlbWVudCwgb25DbGllbnRDb21wb25lbnRSZWYpIHtcbiAgYXdhaXQgcHJlcGFzcyhlbGVtZW50LCB2b2lkIDAsIG9uQ2xpZW50Q29tcG9uZW50UmVmKTtcbn1cbmV4cG9ydCB7XG4gIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhLFxuICBwbGFzbWljUHJlcGFzcyxcbiAgcGxhc21pY1ByZXBhc3NFeHRyYWN0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/prepass/node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@plasmicapp/prepass/node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ renderPrepass)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function(n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) {\n        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nvar Element = 60103;\n\nvar TransitionalElement = 60103;\n\nvar Portal = 60106;\n\nvar Fragment = 60107;\n\nvar StrictMode = 60108;\n\nvar Profiler = 60114;\n\nvar ContextProvider = 60109;\n\nvar ContextConsumer = undefined;\n\nvar Context = 60110;\n\nvar ConcurrentMode = 60111;\n\nvar ForwardRef = 60112;\n\nvar Suspense = 60113;\n\nvar Memo = 60115;\n\nvar Lazy = 60116;\n\nvar ClientReferenceTag = undefined;\n\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var symbolFor = Symbol.for;\n  Element = symbolFor(\"react.element\");\n  TransitionalElement = symbolFor(\"react.transitional.element\");\n  Portal = symbolFor(\"react.portal\");\n  Fragment = symbolFor(\"react.fragment\");\n  StrictMode = symbolFor(\"react.strict_mode\");\n  Profiler = symbolFor(\"react.profiler\");\n  ContextProvider = symbolFor(\"react.provider\");\n  ContextConsumer = symbolFor(\"react.consumer\");\n  Context = symbolFor(\"react.context\");\n  ConcurrentMode = symbolFor(\"react.concurrent_mode\");\n  ForwardRef = symbolFor(\"react.forward_ref\");\n  Suspense = symbolFor(\"react.suspense\");\n  Memo = symbolFor(\"react.memo\");\n  Lazy = symbolFor(\"react.lazy\");\n  ClientReferenceTag = symbolFor(\"react.client.reference\");\n}\n\nvar REACT_ELEMENT_TYPE = Element;\n\nvar REACT_TRANSITIONAL_ELEMENT_TYPE = TransitionalElement;\n\nvar REACT_PORTAL_TYPE = Portal;\n\nvar REACT_FRAGMENT_TYPE = Fragment;\n\nvar REACT_STRICT_MODE_TYPE = StrictMode;\n\nvar REACT_PROFILER_TYPE = Profiler;\n\nvar REACT_PROVIDER_TYPE = ContextProvider;\n\nvar REACT_CONSUMER_TYPE = ContextConsumer;\n\nvar REACT_CONTEXT_TYPE = Context;\n\nvar REACT_CONCURRENT_MODE_TYPE = ConcurrentMode;\n\nvar REACT_FORWARD_REF_TYPE = ForwardRef;\n\nvar REACT_SUSPENSE_TYPE = Suspense;\n\nvar REACT_MEMO_TYPE = Memo;\n\nvar REACT_LAZY_TYPE = Lazy;\n\nvar CLIENT_REFERENCE_TAG = ClientReferenceTag;\n\nfunction isClientReference(reference) {\n  return reference.$$typeof === CLIENT_REFERENCE_TAG;\n}\n\nvar getComponentName = function(type) {\n  if (isClientReference(type)) {\n    return undefined;\n  }\n  if (type.displayName) {\n    return type.displayName;\n  }\n  if (shouldConstruct(type)) {\n    return type.constructor.name;\n  } else {\n    return type.name;\n  }\n};\n\nfunction isReact19() {\n  return !(react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n}\n\nvar shouldConstruct = function(Comp) {\n  return Comp.prototype && Comp.prototype.isReactComponent;\n};\n\nvar typeOf = function(x) {\n  switch (x.$$typeof) {\n   case REACT_PORTAL_TYPE:\n    return REACT_PORTAL_TYPE;\n\n   case REACT_ELEMENT_TYPE:\n   case REACT_TRANSITIONAL_ELEMENT_TYPE:\n    switch (x.type) {\n     case REACT_CONCURRENT_MODE_TYPE:\n      return REACT_CONCURRENT_MODE_TYPE;\n\n     case REACT_FRAGMENT_TYPE:\n      return REACT_FRAGMENT_TYPE;\n\n     case REACT_PROFILER_TYPE:\n      return REACT_PROFILER_TYPE;\n\n     case REACT_STRICT_MODE_TYPE:\n      return REACT_STRICT_MODE_TYPE;\n\n     case REACT_SUSPENSE_TYPE:\n      return REACT_SUSPENSE_TYPE;\n\n     default:\n      {\n        switch (x.type && x.type.$$typeof) {\n         case REACT_LAZY_TYPE:\n          return REACT_LAZY_TYPE;\n\n         case REACT_MEMO_TYPE:\n          return REACT_MEMO_TYPE;\n\n         case REACT_CONSUMER_TYPE:\n          return REACT_CONSUMER_TYPE;\n\n         case REACT_CONTEXT_TYPE:\n          return isReact19() ? REACT_PROVIDER_TYPE : REACT_CONSUMER_TYPE;\n\n         case REACT_PROVIDER_TYPE:\n          return REACT_PROVIDER_TYPE;\n\n         case REACT_FORWARD_REF_TYPE:\n          return REACT_FORWARD_REF_TYPE;\n\n         default:\n          return REACT_ELEMENT_TYPE;\n        }\n      }\n    }\n\n   default:\n    return undefined;\n  }\n};\n\nvar toArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray;\n\nvar isAbstractElement = function(node) {\n  return node !== null && typeof node === \"object\";\n};\n\nvar getChildrenArray = function(node) {\n  return toArray(node).filter(isAbstractElement);\n};\n\nvar computeProps = function(props, defaultProps) {\n  return typeof defaultProps === \"object\" ? _extends({}, defaultProps, props) : props;\n};\n\nvar currentContextStore = new Map;\n\nvar currentContextMap = {};\n\nvar prevContextMap = undefined;\n\nvar prevContextEntry = undefined;\n\nvar getCurrentContextMap = function() {\n  return _extends({}, currentContextMap);\n};\n\nvar getCurrentContextStore = function() {\n  return new Map(currentContextStore);\n};\n\nvar flushPrevContextMap = function() {\n  var prev = prevContextMap;\n  prevContextMap = undefined;\n  return prev;\n};\n\nvar flushPrevContextStore = function() {\n  var prev = prevContextEntry;\n  prevContextEntry = undefined;\n  return prev;\n};\n\nvar restoreContextMap = function(prev) {\n  if (prev !== undefined) {\n    _extends(currentContextMap, prev);\n  }\n};\n\nvar restoreContextStore = function(prev) {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1]);\n  }\n};\n\nvar setCurrentContextMap = function(map) {\n  prevContextMap = undefined;\n  currentContextMap = map;\n};\n\nvar setCurrentContextStore = function(store) {\n  prevContextEntry = undefined;\n  currentContextStore = store;\n};\n\nvar assignContextMap = function(map) {\n  prevContextMap = {};\n  for (var name in map) {\n    prevContextMap[name] = currentContextMap[name];\n    currentContextMap[name] = map[name];\n  }\n};\n\nvar setContextValue = function(context, value) {\n  prevContextEntry = [ context, currentContextStore.get(context) ];\n  currentContextStore.set(context, value);\n};\n\nvar readContextValue = function(context) {\n  var value = currentContextStore.get(context);\n  if (value !== undefined) {\n    return value;\n  }\n  return context._currentValue;\n};\n\nvar emptyContext = {};\n\nvar maskContext = function(type) {\n  var contextType = type.contextType;\n  var contextTypes = type.contextTypes;\n  if (contextType) {\n    return readContextValue(contextType);\n  } else if (!contextTypes) {\n    return emptyContext;\n  }\n  var maskedContext = {};\n  for (var name in contextTypes) {\n    maskedContext[name] = currentContextMap[name];\n  }\n  return maskedContext;\n};\n\nvar currentErrorFrame = null;\n\nvar getCurrentErrorFrame = function() {\n  return currentErrorFrame;\n};\n\nvar setCurrentErrorFrame = function(frame) {\n  currentErrorFrame = frame || null;\n};\n\nvar rendererStateRef = {\n  current: {\n    uniqueID: 0\n  }\n};\n\nvar initRendererState = function() {\n  return rendererStateRef.current = {\n    uniqueID: 0\n  };\n};\n\nvar setCurrentRendererState = function(state) {\n  return rendererStateRef.current = state;\n};\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\n\nvar objectIs = typeof Object.is === \"function\" ? Object.is : is;\n\nvar is$1 = objectIs;\n\nvar currentIdentity = null;\n\nvar makeIdentity = function() {\n  return {};\n};\n\nvar setCurrentIdentity = function(id) {\n  currentIdentity = id;\n};\n\nvar getCurrentIdentity = function() {\n  if (currentIdentity === null) {\n    throw new Error(\"[react-ssr-prepass] Hooks can only be called inside the body of a function component. \" + \"(https://fb.me/react-invalid-hook-call)\");\n  }\n  return currentIdentity;\n};\n\nvar firstWorkInProgressHook = null;\n\nvar workInProgressHook = null;\n\nvar didScheduleRenderPhaseUpdate = false;\n\nvar renderPhaseUpdates = null;\n\nvar numberOfReRenders = 0;\n\nvar RE_RENDER_LIMIT$1 = 25;\n\nvar getFirstHook = function() {\n  return firstWorkInProgressHook;\n};\n\nvar setFirstHook = function(hook) {\n  firstWorkInProgressHook = hook;\n};\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (prevDeps === null) {\n    return false;\n  }\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is$1(nextDeps[i], prevDeps[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createHook() {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  };\n}\n\nfunction createWorkInProgressHook() {\n  if (workInProgressHook === null) {\n    if (firstWorkInProgressHook === null) {\n      return firstWorkInProgressHook = workInProgressHook = createHook();\n    } else {\n      return workInProgressHook = firstWorkInProgressHook;\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      return workInProgressHook = workInProgressHook.next = createHook();\n    } else {\n      return workInProgressHook = workInProgressHook.next;\n    }\n  }\n}\n\nfunction renderWithHooks(Component, props, refOrContext) {\n  workInProgressHook = null;\n  var children = Component(props, refOrContext);\n  while (numberOfReRenders < RE_RENDER_LIMIT$1 && didScheduleRenderPhaseUpdate) {\n    didScheduleRenderPhaseUpdate = false;\n    numberOfReRenders += 1;\n    workInProgressHook = null;\n    children = Component(props, refOrContext);\n  }\n  numberOfReRenders = 0;\n  renderPhaseUpdates = null;\n  workInProgressHook = null;\n  return children;\n}\n\nfunction readContext(context, _) {\n  return readContextValue(context);\n}\n\nfunction useContext(context, _) {\n  getCurrentIdentity();\n  return readContextValue(context);\n}\n\nfunction basicStateReducer(state, action) {\n  return typeof action === \"function\" ? action(state) : action;\n}\n\nfunction useState(initialState) {\n  return useReducer(basicStateReducer, initialState);\n}\n\nfunction useReducer(reducer, initialArg, init) {\n  var id = getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (workInProgressHook.queue === null) {\n    var initialState;\n    if (reducer === basicStateReducer) {\n      initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n    } else {\n      initialState = init !== undefined ? init(initialArg) : initialArg;\n    }\n    workInProgressHook.memoizedState = initialState;\n  }\n  var queue = workInProgressHook.queue || (workInProgressHook.queue = {\n    last: null,\n    dispatch: null\n  });\n  var dispatch = queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue));\n  if (renderPhaseUpdates !== null) {\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate !== undefined) {\n      renderPhaseUpdates.delete(queue);\n      var newState = workInProgressHook.memoizedState;\n      var update = firstRenderPhaseUpdate;\n      do {\n        var action = update.action;\n        newState = reducer(newState, action);\n        update = update.next;\n      } while (update !== null);\n      workInProgressHook.memoizedState = newState;\n    }\n  }\n  return [ workInProgressHook.memoizedState, dispatch ];\n}\n\nfunction useMemo(nextCreate, deps) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = workInProgressHook.memoizedState;\n  if (prevState !== null && nextDeps !== null) {\n    var prevDeps = prevState[1];\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0];\n    }\n  }\n  var nextValue = nextCreate();\n  workInProgressHook.memoizedState = [ nextValue, nextDeps ];\n  return nextValue;\n}\n\nfunction useRef(initialValue) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var previousRef = workInProgressHook.memoizedState;\n  if (previousRef === null) {\n    var ref = {\n      current: initialValue\n    };\n    workInProgressHook.memoizedState = ref;\n    return ref;\n  } else {\n    return previousRef;\n  }\n}\n\nfunction useOpaqueIdentifier() {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (!workInProgressHook.memoizedState) {\n    workInProgressHook.memoizedState = \"R:\" + (rendererStateRef.current.uniqueID++).toString(36);\n  }\n  return workInProgressHook.memoizedState;\n}\n\nfunction dispatchAction(componentIdentity, queue, action) {\n  if (componentIdentity === currentIdentity) {\n    didScheduleRenderPhaseUpdate = true;\n    var update = {\n      action: action,\n      next: null\n    };\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map;\n    }\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  }\n}\n\nfunction useCallback(callback, deps) {\n  return useMemo((function() {\n    return callback;\n  }), deps);\n}\n\nfunction useMutableSource(source, getSnapshot, _subscribe) {\n  getCurrentIdentity();\n  return getSnapshot(source._source);\n}\n\nfunction noop() {}\n\nfunction _ref$3(callback) {\n  callback();\n}\n\nfunction useTransition() {\n  var startTransition = _ref$3;\n  return [ startTransition, false ];\n}\n\nfunction useDeferredValue(input) {\n  return input;\n}\n\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  return getSnapshot();\n}\n\nvar Dispatcher = {\n  readContext: readContext,\n  useSyncExternalStore: useSyncExternalStore,\n  useContext: useContext,\n  useMemo: useMemo,\n  useReducer: useReducer,\n  useRef: useRef,\n  useState: useState,\n  useCallback: useCallback,\n  useMutableSource: useMutableSource,\n  useTransition: useTransition,\n  useDeferredValue: useDeferredValue,\n  useOpaqueIdentifier: useOpaqueIdentifier,\n  useId: useOpaqueIdentifier,\n  unstable_useId: useOpaqueIdentifier,\n  unstable_useOpaqueIdentifier: useOpaqueIdentifier,\n  useLayoutEffect: noop,\n  useImperativeHandle: noop,\n  useEffect: noop,\n  useDebugValue: noop,\n  useInsertionEffect: noop,\n  isPlasmicPrepass: true\n};\n\nvar resolve = function(type) {\n  var payload = type._payload || type;\n  if (payload._status === 0) {\n    return payload._result;\n  } else if (payload._status === 1) {\n    return Promise.resolve(payload._result);\n  } else if (payload._status === 2) {\n    return Promise.reject(payload._result);\n  }\n  payload._status = 0;\n  return payload._result = (payload._ctor || payload._result)().then((function(Component) {\n    payload._result = Component;\n    if (typeof Component === \"function\") {\n      payload._status = 1;\n    } else if (Component !== null && typeof Component === \"object\" && typeof Component.default === \"function\") {\n      payload._result = Component.default;\n      payload._status = 1;\n    } else {\n      payload._status = 2;\n    }\n  })).catch((function(error) {\n    payload._status = 2;\n    payload._result = error;\n    return Promise.reject(error);\n  }));\n};\n\nvar makeFrame$2 = function(type, props, thenable) {\n  return {\n    kind: \"frame.lazy\",\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$4 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status === 1 && payload._result) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(payload._result, props);\n  }\n  try {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type._init(type._payload), props);\n  } catch (err) {\n    if (!!err && typeof err.then === \"function\") {\n      queue.push(makeFrame$2(type, props, err));\n    }\n    return null;\n  }\n};\n\nvar mount$3 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status != null && payload._status <= 0) {\n    queue.push(makeFrame$2(type, props, resolve(type)));\n    return null;\n  }\n  return render$4(type, props, queue);\n};\n\nvar update$4 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$4(frame.type, frame.props, queue);\n};\n\nvar makeFrame$1 = function(type, props, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    id: getCurrentIdentity(),\n    hook: getFirstHook(),\n    kind: \"frame.hooks\",\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$3 = function(type, props, queue) {\n  try {\n    return renderWithHooks(type, computeProps(props, type.defaultProps), maskContext(type));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering \" + getComponentName(type) + \": \" + error);\n      return null;\n    }\n    queue.push(makeFrame$1(type, props, error));\n    return null;\n  }\n};\n\nvar mount$2 = function(type, props, queue, visitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  var promise = visitor(element);\n  if (promise) {\n    queue.push(makeFrame$1(type, props, promise));\n    return null;\n  }\n  return render$3(type, props, queue);\n};\n\nvar update$3 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$3(frame.type, frame.props, queue);\n};\n\nvar RE_RENDER_LIMIT = 25;\n\nfunction _ref$2() {\n  return false;\n}\n\nfunction _ref2$1() {\n  return null;\n}\n\nvar createUpdater = function() {\n  var queue = [];\n  return {\n    _thrown: 0,\n    queue: queue,\n    isMounted: _ref$2,\n    enqueueForceUpdate: _ref2$1,\n    enqueueReplaceState: function(instance, completeState) {\n      if (instance._isMounted) {\n        queue.length = 0;\n        queue.push(completeState);\n      }\n    },\n    enqueueSetState: function(instance, currentPartialState) {\n      if (instance._isMounted) {\n        queue.push(currentPartialState);\n      }\n    }\n  };\n};\n\nvar flushEnqueuedState = function(instance) {\n  var queue = instance.updater.queue;\n  if (queue.length > 0) {\n    var nextState = _extends({}, instance.state);\n    for (var i = 0, l = queue.length; i < l; i++) {\n      var partial = queue[i];\n      var partialState = typeof partial === \"function\" ? partial.call(instance, nextState, instance.props, instance.context) : partial;\n      if (partialState !== null) {\n        _extends(nextState, partialState);\n      }\n    }\n    instance.state = nextState;\n    queue.length = 0;\n  }\n};\n\nvar createInstance = function(type, props) {\n  var updater = createUpdater();\n  var computedProps = computeProps(props, type.defaultProps);\n  var context = maskContext(type);\n  var instance = new type(computedProps, context, updater);\n  instance.props = computedProps;\n  instance.context = context;\n  instance.updater = updater;\n  instance._isMounted = true;\n  if (instance.state === undefined) {\n    instance.state = null;\n  }\n  if (typeof instance.componentDidCatch === \"function\" || typeof type.getDerivedStateFromError === \"function\") {\n    var frame = makeFrame(type, instance, null);\n    frame.errorFrame = frame;\n    setCurrentErrorFrame(frame);\n  }\n  if (typeof type.getDerivedStateFromProps === \"function\") {\n    var getDerivedStateFromProps = type.getDerivedStateFromProps;\n    var state = getDerivedStateFromProps(instance.props, instance.state);\n    if (state !== null && state !== undefined) {\n      instance.state = _extends({}, instance.state, state);\n    }\n  } else if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n  return instance;\n};\n\nvar makeFrame = function(type, instance, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    kind: \"frame.class\",\n    error: null,\n    instance: instance,\n    type: type\n  };\n};\n\nvar render$2 = function(type, instance, queue) {\n  flushEnqueuedState(instance);\n  var child = null;\n  try {\n    child = instance.render();\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering component \" + getComponentName(type) + \". This is fine as long as you are not fetching data with @plasmicapp/query inside this component.  Error: \" + error);\n      return null;\n    }\n    queue.push(makeFrame(type, instance, error));\n    return null;\n  }\n  if (type.childContextTypes !== undefined && typeof instance.getChildContext === \"function\") {\n    var childContext = instance.getChildContext();\n    if (childContext !== null && typeof childContext === \"object\") {\n      assignContextMap(childContext);\n    }\n  }\n  if (typeof instance.getDerivedStateFromProps !== \"function\" && (typeof instance.componentWillMount === \"function\" || typeof instance.UNSAFE_componentWillMount === \"function\") && typeof instance.componentWillUnmount === \"function\") {\n    try {\n      instance.componentWillUnmount();\n    } catch (_err) {}\n  }\n  instance._isMounted = false;\n  return child;\n};\n\nvar mount$1 = function(type, props, queue, visitor, element) {\n  setCurrentIdentity(null);\n  var instance = createInstance(type, props);\n  var promise = visitor(element, instance);\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise));\n    return null;\n  }\n  return render$2(type, instance, queue);\n};\n\nvar update$2 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  if (frame.error) {\n    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) {\n      return null;\n    }\n    frame.instance._isMounted = true;\n    if (typeof frame.instance.componentDidCatch === \"function\") {\n      frame.instance.componentDidCatch(frame.error);\n    }\n    if (typeof frame.type.getDerivedStateFromError === \"function\") {\n      frame.instance.updater.enqueueSetState(frame.instance, frame.type.getDerivedStateFromError(frame.error));\n    }\n  }\n  return render$2(frame.type, frame.instance, queue);\n};\n\nfunction _ref$1(elt) {\n  return elt && typeof elt === \"object\" && typeOf(elt);\n}\n\nvar render$1 = function(type, props, queue, clientRefVisitor, element) {\n  try {\n    var node = clientRefVisitor(element);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), {}, [].concat(node ? getChildrenArray(node) : Object.values(props).flat(Infinity).filter(_ref$1)));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering client reference: \" + error);\n      return null;\n    }\n    queue.push({\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      errorFrame: getCurrentErrorFrame(),\n      id: getCurrentIdentity(),\n      hook: getFirstHook(),\n      thenable: error,\n      kind: \"client-ref\",\n      type: type,\n      props: props,\n      element: element,\n      clientRefVisitor: clientRefVisitor\n    });\n    return null;\n  }\n};\n\nvar mount = function(type, props, queue, clientRefVisitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  return render$1(type, props, queue, clientRefVisitor, element);\n};\n\nvar update$1 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$1(frame.type, frame.props, queue, frame.clientRefVisitor, frame.element);\n};\n\nvar REACT_INTERNALS = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) || (react__WEBPACK_IMPORTED_MODULE_0___default().__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) || (react__WEBPACK_IMPORTED_MODULE_0___default().__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE);\n\nvar ReactCurrentDispatcher = REACT_INTERNALS.ReactCurrentDispatcher || REACT_INTERNALS;\n\nvar getReactCurrentDispatcher = function() {\n  return ReactCurrentDispatcher.current || ReactCurrentDispatcher.H;\n};\n\nvar injectReactCurrentDispatcher = function(newDispatcher) {\n  if (!isReact19()) {\n    ReactCurrentDispatcher.current = newDispatcher;\n  } else {\n    ReactCurrentDispatcher.H = newDispatcher;\n  }\n};\n\nvar SHOULD_YIELD = typeof setImmediate === \"function\";\n\nvar YIELD_AFTER_MS = 5;\n\nvar render = function(type, props, queue, visitor, clientRefVisitor, element) {\n  if (isClientReference(type)) {\n    return mount(type, props, queue, clientRefVisitor, element);\n  }\n  return shouldConstruct(type) ? mount$1(type, props, queue, visitor, element) : mount$2(type, props, queue, visitor, element);\n};\n\nvar visitElement = function(element, queue, visitor, clientRefVisitor) {\n  switch (typeOf(element)) {\n   case REACT_SUSPENSE_TYPE:\n   case REACT_STRICT_MODE_TYPE:\n   case REACT_CONCURRENT_MODE_TYPE:\n   case REACT_PROFILER_TYPE:\n   case REACT_FRAGMENT_TYPE:\n    {\n      var fragmentElement = element;\n      return getChildrenArray(fragmentElement.props.children);\n    }\n\n   case REACT_PROVIDER_TYPE:\n    {\n      var providerElement = element;\n      var ref = providerElement.props;\n      var value = ref.value;\n      var children = ref.children;\n      var type = providerElement.type;\n      var context = typeof type._context === \"object\" ? type._context : type;\n      setContextValue(context, value);\n      return getChildrenArray(children);\n    }\n\n   case REACT_CONSUMER_TYPE:\n    {\n      var consumerElement = element;\n      var ref$1 = consumerElement.props;\n      var children$1 = ref$1.children;\n      if (typeof children$1 === \"function\") {\n        var type$1 = consumerElement.type;\n        var context$1 = typeof type$1._context === \"object\" ? type$1._context : type$1;\n        var value$1 = readContextValue(context$1);\n        return getChildrenArray(children$1(value$1));\n      } else {\n        return [];\n      }\n    }\n\n   case REACT_LAZY_TYPE:\n    {\n      var lazyElement = element;\n      var type$2 = lazyElement.type;\n      var child = mount$3(type$2, lazyElement.props, queue);\n      return getChildrenArray(child);\n    }\n\n   case REACT_MEMO_TYPE:\n    {\n      var memoElement = element;\n      var ref$2 = memoElement.type;\n      var type$3 = ref$2.type;\n      var child$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$3, memoElement.props);\n      return getChildrenArray(child$1);\n    }\n\n   case REACT_FORWARD_REF_TYPE:\n    {\n      var refElement = element;\n      var ref$3 = refElement.type;\n      var type$4 = ref$3.render;\n      var defaultProps = ref$3.defaultProps;\n      var props = computeProps(refElement.props, defaultProps);\n      var child$2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$4, props);\n      return getChildrenArray(child$2);\n    }\n\n   case REACT_ELEMENT_TYPE:\n    {\n      var el = element;\n      if (typeof el.type === \"string\") {\n        return getChildrenArray(el.props.children);\n      } else {\n        var userElement = element;\n        var type$5 = userElement.type;\n        var props$1 = userElement.props;\n        var child$3 = render(type$5, props$1, queue, visitor, clientRefVisitor, userElement);\n        return getChildrenArray(child$3);\n      }\n    }\n\n   case REACT_PORTAL_TYPE:\n   default:\n    return [];\n  }\n};\n\nvar visitLoop = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor) {\n  var prevDispatcher = getReactCurrentDispatcher();\n  var start = Date.now();\n  try {\n    injectReactCurrentDispatcher(Dispatcher);\n    while (traversalChildren.length > 0) {\n      var element = traversalChildren[traversalChildren.length - 1].shift();\n      if (element !== undefined) {\n        var children = visitElement(element, queue, visitor, clientRefVisitor);\n        traversalChildren.push(children);\n        traversalMap.push(flushPrevContextMap());\n        traversalStore.push(flushPrevContextStore());\n        traversalErrorFrame.push(getCurrentErrorFrame());\n      } else {\n        traversalChildren.pop();\n        restoreContextMap(traversalMap.pop());\n        restoreContextStore(traversalStore.pop());\n        setCurrentErrorFrame(traversalErrorFrame.pop());\n      }\n      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {\n        return true;\n      }\n    }\n    return false;\n  } catch (error) {\n    var errorFrame = getCurrentErrorFrame();\n    if (!errorFrame) {\n      throw error;\n    }\n    errorFrame.error = error;\n    queue.unshift(errorFrame);\n    return false;\n  } finally {\n    injectReactCurrentDispatcher(prevDispatcher);\n  }\n};\n\nvar makeYieldFrame = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: null,\n    kind: \"frame.yield\",\n    traversalChildren: traversalChildren,\n    traversalMap: traversalMap,\n    traversalStore: traversalStore,\n    traversalErrorFrame: traversalErrorFrame\n  };\n};\n\nvar visit = function(init, queue, visitor, clientRefVisitor) {\n  var traversalChildren = [ init ];\n  var traversalMap = [ flushPrevContextMap() ];\n  var traversalStore = [ flushPrevContextStore() ];\n  var traversalErrorFrame = [ getCurrentErrorFrame() ];\n  var hasYielded = visitLoop(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor);\n  if (hasYielded) {\n    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore, traversalErrorFrame));\n  }\n};\n\nvar update = function(frame, queue, visitor, clientRefVisitor) {\n  if (frame.kind === \"frame.yield\") {\n    setCurrentIdentity(null);\n    setCurrentContextMap(frame.contextMap);\n    setCurrentContextStore(frame.contextStore);\n    setCurrentErrorFrame(frame.errorFrame);\n    var hasYielded = visitLoop(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame, queue, visitor, clientRefVisitor);\n    if (hasYielded) {\n      queue.unshift(makeYieldFrame(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame));\n    }\n  } else {\n    var prevDispatcher = getReactCurrentDispatcher();\n    var children = null;\n    injectReactCurrentDispatcher(Dispatcher);\n    try {\n      if (frame.kind === \"frame.class\") {\n        children = update$2(queue, frame);\n      } else if (frame.kind === \"frame.hooks\") {\n        children = update$3(queue, frame);\n      } else if (frame.kind === \"frame.lazy\") {\n        children = update$4(queue, frame);\n      } else if (frame.kind === \"client-ref\") {\n        children = update$1(queue, frame);\n      }\n    } catch (error) {\n      var errorFrame = getCurrentErrorFrame();\n      if (!errorFrame) {\n        throw error;\n      }\n      errorFrame.error = error;\n      queue.unshift(errorFrame);\n      children = null;\n    } finally {\n      injectReactCurrentDispatcher(prevDispatcher);\n    }\n    visit(getChildrenArray(children), queue, visitor, clientRefVisitor);\n  }\n};\n\nfunction _ref(resolve, reject) {\n  setImmediate(resolve);\n}\n\nvar flushFrames = function(queue, visitor, clientRefVisitor, state) {\n  var frame = queue.shift();\n  if (!frame) {\n    return Promise.resolve();\n  }\n  if (SHOULD_YIELD && frame.kind === \"frame.yield\") {\n    frame.thenable = new Promise(_ref);\n  }\n  return Promise.resolve(frame.thenable).then((function() {\n    setCurrentRendererState(state);\n    update(frame, queue, visitor, clientRefVisitor);\n    return flushFrames(queue, visitor, clientRefVisitor, state);\n  }), (function(error) {\n    if (!frame.errorFrame) {\n      throw error;\n    }\n    frame.errorFrame.error = error;\n    update(frame.errorFrame, queue, visitor, clientRefVisitor);\n  }));\n};\n\nvar defaultVisitor = function() {\n  return undefined;\n};\n\nvar runningPrepassCount = 0;\n\nfunction _ref2() {\n  runningPrepassCount--;\n  if (!runningPrepassCount) {\n    delete globalThis.__ssrPrepassEnv;\n  }\n}\n\nvar renderPrepass = function(element, visitor, clientRefVisitor) {\n  if (!visitor) {\n    visitor = defaultVisitor;\n  }\n  if (!clientRefVisitor) {\n    clientRefVisitor = defaultVisitor;\n  }\n  var queue = [];\n  var state = initRendererState();\n  setCurrentContextMap({});\n  setCurrentContextStore(new Map);\n  setCurrentErrorFrame(null);\n  try {\n    runningPrepassCount++;\n    globalThis.__ssrPrepassEnv = {\n      readContextValue: readContextValue,\n      setContextValue: setContextValue\n    };\n    visit(getChildrenArray(element), queue, visitor, clientRefVisitor);\n  } catch (error) {\n    runningPrepassCount--;\n    if (!runningPrepassCount) {\n      delete globalThis.__ssrPrepassEnv;\n    }\n    return Promise.reject(error);\n  }\n  return flushFrames(queue, visitor, clientRefVisitor, state).finally(_ref2);\n};\n\n\n//# sourceMappingURL=react-ssr-prepass.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9wcmVwYXNzL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9yZWFjdC1zc3ItcHJlcGFzcy9kaXN0L3JlYWN0LXNzci1wcmVwYXNzLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpR0FBd0Q7QUFDbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsMkNBQVE7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBNEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBYTtBQUN4QjtBQUNBO0FBQ0EsV0FBVyxvREFBYTtBQUN4QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFhLENBQUMsdURBQWMsSUFBSTtBQUMzQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUdBQXdELElBQUksOEdBQXFFLElBQUksOEdBQXFFOztBQUVoTzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFhO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxccHJlcGFzc1xcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxccmVhY3Qtc3NyLXByZXBhc3NcXGRpc3RcXHJlYWN0LXNzci1wcmVwYXNzLmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24obikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkge1xuICAgICAgICAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBFbGVtZW50ID0gNjAxMDM7XG5cbnZhciBUcmFuc2l0aW9uYWxFbGVtZW50ID0gNjAxMDM7XG5cbnZhciBQb3J0YWwgPSA2MDEwNjtcblxudmFyIEZyYWdtZW50ID0gNjAxMDc7XG5cbnZhciBTdHJpY3RNb2RlID0gNjAxMDg7XG5cbnZhciBQcm9maWxlciA9IDYwMTE0O1xuXG52YXIgQ29udGV4dFByb3ZpZGVyID0gNjAxMDk7XG5cbnZhciBDb250ZXh0Q29uc3VtZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBDb250ZXh0ID0gNjAxMTA7XG5cbnZhciBDb25jdXJyZW50TW9kZSA9IDYwMTExO1xuXG52YXIgRm9yd2FyZFJlZiA9IDYwMTEyO1xuXG52YXIgU3VzcGVuc2UgPSA2MDExMztcblxudmFyIE1lbW8gPSA2MDExNTtcblxudmFyIExhenkgPSA2MDExNjtcblxudmFyIENsaWVudFJlZmVyZW5jZVRhZyA9IHVuZGVmaW5lZDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBFbGVtZW50ID0gc3ltYm9sRm9yKFwicmVhY3QuZWxlbWVudFwiKTtcbiAgVHJhbnNpdGlvbmFsRWxlbWVudCA9IHN5bWJvbEZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpO1xuICBQb3J0YWwgPSBzeW1ib2xGb3IoXCJyZWFjdC5wb3J0YWxcIik7XG4gIEZyYWdtZW50ID0gc3ltYm9sRm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG4gIFN0cmljdE1vZGUgPSBzeW1ib2xGb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbiAgUHJvZmlsZXIgPSBzeW1ib2xGb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgQ29udGV4dFByb3ZpZGVyID0gc3ltYm9sRm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gIENvbnRleHRDb25zdW1lciA9IHN5bWJvbEZvcihcInJlYWN0LmNvbnN1bWVyXCIpO1xuICBDb250ZXh0ID0gc3ltYm9sRm9yKFwicmVhY3QuY29udGV4dFwiKTtcbiAgQ29uY3VycmVudE1vZGUgPSBzeW1ib2xGb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik7XG4gIEZvcndhcmRSZWYgPSBzeW1ib2xGb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcbiAgU3VzcGVuc2UgPSBzeW1ib2xGb3IoXCJyZWFjdC5zdXNwZW5zZVwiKTtcbiAgTWVtbyA9IHN5bWJvbEZvcihcInJlYWN0Lm1lbW9cIik7XG4gIExhenkgPSBzeW1ib2xGb3IoXCJyZWFjdC5sYXp5XCIpO1xuICBDbGllbnRSZWZlcmVuY2VUYWcgPSBzeW1ib2xGb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xufVxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gRWxlbWVudDtcblxudmFyIFJFQUNUX1RSQU5TSVRJT05BTF9FTEVNRU5UX1RZUEUgPSBUcmFuc2l0aW9uYWxFbGVtZW50O1xuXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBQb3J0YWw7XG5cbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gRnJhZ21lbnQ7XG5cbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3RyaWN0TW9kZTtcblxudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBQcm9maWxlcjtcblxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBDb250ZXh0UHJvdmlkZXI7XG5cbnZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gQ29udGV4dENvbnN1bWVyO1xuXG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gQ29udGV4dDtcblxudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gQ29uY3VycmVudE1vZGU7XG5cbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gRm9yd2FyZFJlZjtcblxudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTdXNwZW5zZTtcblxudmFyIFJFQUNUX01FTU9fVFlQRSA9IE1lbW87XG5cbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBMYXp5O1xuXG52YXIgQ0xJRU5UX1JFRkVSRU5DRV9UQUcgPSBDbGllbnRSZWZlcmVuY2VUYWc7XG5cbmZ1bmN0aW9uIGlzQ2xpZW50UmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRztcbn1cblxudmFyIGdldENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChpc0NsaWVudFJlZmVyZW5jZSh0eXBlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZTtcbiAgfVxuICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZS5uYW1lO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc1JlYWN0MTkoKSB7XG4gIHJldHVybiAhUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG59XG5cbnZhciBzaG91bGRDb25zdHJ1Y3QgPSBmdW5jdGlvbihDb21wKSB7XG4gIHJldHVybiBDb21wLnByb3RvdHlwZSAmJiBDb21wLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufTtcblxudmFyIHR5cGVPZiA9IGZ1bmN0aW9uKHgpIHtcbiAgc3dpdGNoICh4LiQkdHlwZW9mKSB7XG4gICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgIHJldHVybiBSRUFDVF9QT1JUQUxfVFlQRTtcblxuICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICBjYXNlIFJFQUNUX1RSQU5TSVRJT05BTF9FTEVNRU5UX1RZUEU6XG4gICAgc3dpdGNoICh4LnR5cGUpIHtcbiAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgIHJldHVybiBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcblxuICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gUkVBQ1RfRlJBR01FTlRfVFlQRTtcblxuICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gUkVBQ1RfUFJPRklMRVJfVFlQRTtcblxuICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcblxuICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblxuICAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBzd2l0Y2ggKHgudHlwZSAmJiB4LnR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBSRUFDVF9MQVpZX1RZUEU7XG5cbiAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgIHJldHVybiBSRUFDVF9NRU1PX1RZUEU7XG5cbiAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfQ09OU1VNRVJfVFlQRTtcblxuICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGlzUmVhY3QxOSgpID8gUkVBQ1RfUFJPVklERVJfVFlQRSA6IFJFQUNUX0NPTlNVTUVSX1RZUEU7XG5cbiAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfUFJPVklERVJfVFlQRTtcblxuICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgIHJldHVybiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuXG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxudmFyIHRvQXJyYXkgPSBDaGlsZHJlbi50b0FycmF5O1xuXG52YXIgaXNBYnN0cmFjdEVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiBub2RlICE9PSBudWxsICYmIHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiO1xufTtcblxudmFyIGdldENoaWxkcmVuQXJyYXkgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiB0b0FycmF5KG5vZGUpLmZpbHRlcihpc0Fic3RyYWN0RWxlbWVudCk7XG59O1xuXG52YXIgY29tcHV0ZVByb3BzID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRQcm9wcykge1xuICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm9wcyA9PT0gXCJvYmplY3RcIiA/IF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKSA6IHByb3BzO1xufTtcblxudmFyIGN1cnJlbnRDb250ZXh0U3RvcmUgPSBuZXcgTWFwO1xuXG52YXIgY3VycmVudENvbnRleHRNYXAgPSB7fTtcblxudmFyIHByZXZDb250ZXh0TWFwID0gdW5kZWZpbmVkO1xuXG52YXIgcHJldkNvbnRleHRFbnRyeSA9IHVuZGVmaW5lZDtcblxudmFyIGdldEN1cnJlbnRDb250ZXh0TWFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgY3VycmVudENvbnRleHRNYXApO1xufTtcblxudmFyIGdldEN1cnJlbnRDb250ZXh0U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBNYXAoY3VycmVudENvbnRleHRTdG9yZSk7XG59O1xuXG52YXIgZmx1c2hQcmV2Q29udGV4dE1hcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHJldiA9IHByZXZDb250ZXh0TWFwO1xuICBwcmV2Q29udGV4dE1hcCA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHByZXY7XG59O1xuXG52YXIgZmx1c2hQcmV2Q29udGV4dFN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcmV2ID0gcHJldkNvbnRleHRFbnRyeTtcbiAgcHJldkNvbnRleHRFbnRyeSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHByZXY7XG59O1xuXG52YXIgcmVzdG9yZUNvbnRleHRNYXAgPSBmdW5jdGlvbihwcmV2KSB7XG4gIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICBfZXh0ZW5kcyhjdXJyZW50Q29udGV4dE1hcCwgcHJldik7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlQ29udGV4dFN0b3JlID0gZnVuY3Rpb24ocHJldikge1xuICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3VycmVudENvbnRleHRTdG9yZS5zZXQocHJldlswXSwgcHJldlsxXSk7XG4gIH1cbn07XG5cbnZhciBzZXRDdXJyZW50Q29udGV4dE1hcCA9IGZ1bmN0aW9uKG1hcCkge1xuICBwcmV2Q29udGV4dE1hcCA9IHVuZGVmaW5lZDtcbiAgY3VycmVudENvbnRleHRNYXAgPSBtYXA7XG59O1xuXG52YXIgc2V0Q3VycmVudENvbnRleHRTdG9yZSA9IGZ1bmN0aW9uKHN0b3JlKSB7XG4gIHByZXZDb250ZXh0RW50cnkgPSB1bmRlZmluZWQ7XG4gIGN1cnJlbnRDb250ZXh0U3RvcmUgPSBzdG9yZTtcbn07XG5cbnZhciBhc3NpZ25Db250ZXh0TWFwID0gZnVuY3Rpb24obWFwKSB7XG4gIHByZXZDb250ZXh0TWFwID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgcHJldkNvbnRleHRNYXBbbmFtZV0gPSBjdXJyZW50Q29udGV4dE1hcFtuYW1lXTtcbiAgICBjdXJyZW50Q29udGV4dE1hcFtuYW1lXSA9IG1hcFtuYW1lXTtcbiAgfVxufTtcblxudmFyIHNldENvbnRleHRWYWx1ZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHZhbHVlKSB7XG4gIHByZXZDb250ZXh0RW50cnkgPSBbIGNvbnRleHQsIGN1cnJlbnRDb250ZXh0U3RvcmUuZ2V0KGNvbnRleHQpIF07XG4gIGN1cnJlbnRDb250ZXh0U3RvcmUuc2V0KGNvbnRleHQsIHZhbHVlKTtcbn07XG5cbnZhciByZWFkQ29udGV4dFZhbHVlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjdXJyZW50Q29udGV4dFN0b3JlLmdldChjb250ZXh0KTtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbn07XG5cbnZhciBlbXB0eUNvbnRleHQgPSB7fTtcblxudmFyIG1hc2tDb250ZXh0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gIGlmIChjb250ZXh0VHlwZSkge1xuICAgIHJldHVybiByZWFkQ29udGV4dFZhbHVlKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dDtcbiAgfVxuICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgIG1hc2tlZENvbnRleHRbbmFtZV0gPSBjdXJyZW50Q29udGV4dE1hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gbWFza2VkQ29udGV4dDtcbn07XG5cbnZhciBjdXJyZW50RXJyb3JGcmFtZSA9IG51bGw7XG5cbnZhciBnZXRDdXJyZW50RXJyb3JGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY3VycmVudEVycm9yRnJhbWU7XG59O1xuXG52YXIgc2V0Q3VycmVudEVycm9yRnJhbWUgPSBmdW5jdGlvbihmcmFtZSkge1xuICBjdXJyZW50RXJyb3JGcmFtZSA9IGZyYW1lIHx8IG51bGw7XG59O1xuXG52YXIgcmVuZGVyZXJTdGF0ZVJlZiA9IHtcbiAgY3VycmVudDoge1xuICAgIHVuaXF1ZUlEOiAwXG4gIH1cbn07XG5cbnZhciBpbml0UmVuZGVyZXJTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVuZGVyZXJTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgIHVuaXF1ZUlEOiAwXG4gIH07XG59O1xuXG52YXIgc2V0Q3VycmVudFJlbmRlcmVyU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gcmVuZGVyZXJTdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XG59O1xuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5O1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGlzJDEgPSBvYmplY3RJcztcblxudmFyIGN1cnJlbnRJZGVudGl0eSA9IG51bGw7XG5cbnZhciBtYWtlSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHt9O1xufTtcblxudmFyIHNldEN1cnJlbnRJZGVudGl0eSA9IGZ1bmN0aW9uKGlkKSB7XG4gIGN1cnJlbnRJZGVudGl0eSA9IGlkO1xufTtcblxudmFyIGdldEN1cnJlbnRJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoY3VycmVudElkZW50aXR5ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW3JlYWN0LXNzci1wcmVwYXNzXSBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBcIiArIFwiKGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwpXCIpO1xuICB9XG4gIHJldHVybiBjdXJyZW50SWRlbnRpdHk7XG59O1xuXG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG5cbnZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG5cbnZhciBSRV9SRU5ERVJfTElNSVQkMSA9IDI1O1xuXG52YXIgZ2V0Rmlyc3RIb29rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbn07XG5cbnZhciBzZXRGaXJzdEhvb2sgPSBmdW5jdGlvbihob29rKSB7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbn07XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXMkMShuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgcmVmT3JDb250ZXh0KSB7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgd2hpbGUgKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUJDEgJiYgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIF8pIHtcbiAgcmV0dXJuIHJlYWRDb250ZXh0VmFsdWUoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCwgXykge1xuICBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgcmV0dXJuIHJlYWRDb250ZXh0VmFsdWUoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBpZCA9IGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9PT0gbnVsbCkge1xuICAgIHZhciBpbml0aWFsU3RhdGU7XG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gXCJmdW5jdGlvblwiID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB9XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSB8fCAod29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0ge1xuICAgIGxhc3Q6IG51bGwsXG4gICAgZGlzcGF0Y2g6IG51bGxcbiAgfSk7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoIHx8IChxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgaWQsIHF1ZXVlKSk7XG4gIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpO1xuICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoIF07XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwgJiYgbmV4dERlcHMgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG4gICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgIH1cbiAgfVxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFsgbmV4dFZhbHVlLCBuZXh0RGVwcyBdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICAgIHJldHVybiByZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKCF3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gXCJSOlwiICsgKHJlbmRlcmVyU3RhdGVSZWYuY3VycmVudC51bmlxdWVJRCsrKS50b1N0cmluZygzNik7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRJZGVudGl0eSkge1xuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXA7XG4gICAgfVxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSksIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIF9zdWJzY3JpYmUpIHtcbiAgZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHJldHVybiBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBfcmVmJDMoY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IF9yZWYkMztcbiAgcmV0dXJuIFsgc3RhcnRUcmFuc2l0aW9uLCBmYWxzZSBdO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG59XG5cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICB1c2VNdXRhYmxlU291cmNlOiB1c2VNdXRhYmxlU291cmNlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VPcGFxdWVJZGVudGlmaWVyOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICB1c2VJZDogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgdW5zdGFibGVfdXNlSWQ6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIHVuc3RhYmxlX3VzZU9wYXF1ZUlkZW50aWZpZXI6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIHVzZUxheW91dEVmZmVjdDogbm9vcCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgdXNlRWZmZWN0OiBub29wLFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AsXG4gIGlzUGxhc21pY1ByZXBhc3M6IHRydWVcbn07XG5cbnZhciByZXNvbHZlID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQgfHwgdHlwZTtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gMCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5fc3RhdHVzID09PSAxKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXlsb2FkLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gMikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXlsb2FkLl9yZXN1bHQpO1xuICB9XG4gIHBheWxvYWQuX3N0YXR1cyA9IDA7XG4gIHJldHVybiBwYXlsb2FkLl9yZXN1bHQgPSAocGF5bG9hZC5fY3RvciB8fCBwYXlsb2FkLl9yZXN1bHQpKCkudGhlbigoZnVuY3Rpb24oQ29tcG9uZW50KSB7XG4gICAgcGF5bG9hZC5fcmVzdWx0ID0gQ29tcG9uZW50O1xuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHBheWxvYWQuX3N0YXR1cyA9IDE7XG4gICAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgQ29tcG9uZW50LmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcGF5bG9hZC5fcmVzdWx0ID0gQ29tcG9uZW50LmRlZmF1bHQ7XG4gICAgICBwYXlsb2FkLl9zdGF0dXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXlsb2FkLl9zdGF0dXMgPSAyO1xuICAgIH1cbiAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnJvcikge1xuICAgIHBheWxvYWQuX3N0YXR1cyA9IDI7XG4gICAgcGF5bG9hZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSkpO1xufTtcblxudmFyIG1ha2VGcmFtZSQyID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHRoZW5hYmxlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJmcmFtZS5sYXp5XCIsXG4gICAgY29udGV4dE1hcDogZ2V0Q3VycmVudENvbnRleHRNYXAoKSxcbiAgICBjb250ZXh0U3RvcmU6IGdldEN1cnJlbnRDb250ZXh0U3RvcmUoKSxcbiAgICBlcnJvckZyYW1lOiBnZXRDdXJyZW50RXJyb3JGcmFtZSgpLFxuICAgIHRoZW5hYmxlOiB0aGVuYWJsZSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgdHlwZTogdHlwZVxuICB9O1xufTtcblxudmFyIHJlbmRlciQ0ID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlKSB7XG4gIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZCB8fCB0eXBlO1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSAxICYmIHBheWxvYWQuX3Jlc3VsdCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHBheWxvYWQuX3Jlc3VsdCwgcHJvcHMpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZS5faW5pdCh0eXBlLl9wYXlsb2FkKSwgcHJvcHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoISFlcnIgJiYgdHlwZW9mIGVyci50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lJDIodHlwZSwgcHJvcHMsIGVycikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIG1vdW50JDMgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUpIHtcbiAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkIHx8IHR5cGU7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgIT0gbnVsbCAmJiBwYXlsb2FkLl9zdGF0dXMgPD0gMCkge1xuICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lJDIodHlwZSwgcHJvcHMsIHJlc29sdmUodHlwZSkpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyJDQodHlwZSwgcHJvcHMsIHF1ZXVlKTtcbn07XG5cbnZhciB1cGRhdGUkNCA9IGZ1bmN0aW9uKHF1ZXVlLCBmcmFtZSkge1xuICBzZXRDdXJyZW50SWRlbnRpdHkobnVsbCk7XG4gIHNldEN1cnJlbnRDb250ZXh0TWFwKGZyYW1lLmNvbnRleHRNYXApO1xuICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKGZyYW1lLmNvbnRleHRTdG9yZSk7XG4gIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lLmVycm9yRnJhbWUpO1xuICByZXR1cm4gcmVuZGVyJDQoZnJhbWUudHlwZSwgZnJhbWUucHJvcHMsIHF1ZXVlKTtcbn07XG5cbnZhciBtYWtlRnJhbWUkMSA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCB0aGVuYWJsZSkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRNYXA6IGdldEN1cnJlbnRDb250ZXh0TWFwKCksXG4gICAgY29udGV4dFN0b3JlOiBnZXRDdXJyZW50Q29udGV4dFN0b3JlKCksXG4gICAgaWQ6IGdldEN1cnJlbnRJZGVudGl0eSgpLFxuICAgIGhvb2s6IGdldEZpcnN0SG9vaygpLFxuICAgIGtpbmQ6IFwiZnJhbWUuaG9va3NcIixcbiAgICBlcnJvckZyYW1lOiBnZXRDdXJyZW50RXJyb3JGcmFtZSgpLFxuICAgIHRoZW5hYmxlOiB0aGVuYWJsZSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgdHlwZTogdHlwZVxuICB9O1xufTtcblxudmFyIHJlbmRlciQzID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlbmRlcldpdGhIb29rcyh0eXBlLCBjb21wdXRlUHJvcHMocHJvcHMsIHR5cGUuZGVmYXVsdFByb3BzKSwgbWFza0NvbnRleHQodHlwZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IudGhlbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQTEFTTUlDOiBFbmNvdW50ZXJlZCBlcnJvciB3aGVuIHByZS1yZW5kZXJpbmcgXCIgKyBnZXRDb21wb25lbnROYW1lKHR5cGUpICsgXCI6IFwiICsgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lJDEodHlwZSwgcHJvcHMsIGVycm9yKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBtb3VudCQyID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlLCB2aXNpdG9yLCBlbGVtZW50KSB7XG4gIHNldEZpcnN0SG9vayhudWxsKTtcbiAgc2V0Q3VycmVudElkZW50aXR5KG1ha2VJZGVudGl0eSgpKTtcbiAgdmFyIHByb21pc2UgPSB2aXNpdG9yKGVsZW1lbnQpO1xuICBpZiAocHJvbWlzZSkge1xuICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lJDEodHlwZSwgcHJvcHMsIHByb21pc2UpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyJDModHlwZSwgcHJvcHMsIHF1ZXVlKTtcbn07XG5cbnZhciB1cGRhdGUkMyA9IGZ1bmN0aW9uKHF1ZXVlLCBmcmFtZSkge1xuICBzZXRGaXJzdEhvb2soZnJhbWUuaG9vayk7XG4gIHNldEN1cnJlbnRJZGVudGl0eShmcmFtZS5pZCk7XG4gIHNldEN1cnJlbnRDb250ZXh0TWFwKGZyYW1lLmNvbnRleHRNYXApO1xuICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKGZyYW1lLmNvbnRleHRTdG9yZSk7XG4gIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lLmVycm9yRnJhbWUpO1xuICByZXR1cm4gcmVuZGVyJDMoZnJhbWUudHlwZSwgZnJhbWUucHJvcHMsIHF1ZXVlKTtcbn07XG5cbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcblxuZnVuY3Rpb24gX3JlZiQyKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9yZWYyJDEoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgY3JlYXRlVXBkYXRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcXVldWUgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBfdGhyb3duOiAwLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBpc01vdW50ZWQ6IF9yZWYkMixcbiAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IF9yZWYyJDEsXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oaW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHF1ZXVlLnB1c2goY29tcGxldGVTdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uKGluc3RhbmNlLCBjdXJyZW50UGFydGlhbFN0YXRlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnRQYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBmbHVzaEVucXVldWVkU3RhdGUgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICB2YXIgcXVldWUgPSBpbnN0YW5jZS51cGRhdGVyLnF1ZXVlO1xuICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBuZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgaW5zdGFuY2Uuc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsLmNhbGwoaW5zdGFuY2UsIG5leHRTdGF0ZSwgaW5zdGFuY2UucHJvcHMsIGluc3RhbmNlLmNvbnRleHQpIDogcGFydGlhbDtcbiAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgX2V4dGVuZHMobmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbih0eXBlLCBwcm9wcykge1xuICB2YXIgdXBkYXRlciA9IGNyZWF0ZVVwZGF0ZXIoKTtcbiAgdmFyIGNvbXB1dGVkUHJvcHMgPSBjb21wdXRlUHJvcHMocHJvcHMsIHR5cGUuZGVmYXVsdFByb3BzKTtcbiAgdmFyIGNvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlKTtcbiAgdmFyIGluc3RhbmNlID0gbmV3IHR5cGUoY29tcHV0ZWRQcm9wcywgY29udGV4dCwgdXBkYXRlcik7XG4gIGluc3RhbmNlLnByb3BzID0gY29tcHV0ZWRQcm9wcztcbiAgaW5zdGFuY2UuY29udGV4dCA9IGNvbnRleHQ7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICBpbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgaWYgKGluc3RhbmNlLnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGZyYW1lID0gbWFrZUZyYW1lKHR5cGUsIGluc3RhbmNlLCBudWxsKTtcbiAgICBmcmFtZS5lcnJvckZyYW1lID0gZnJhbWU7XG4gICAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUpO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICB2YXIgc3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoaW5zdGFuY2UucHJvcHMsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBpZiAoc3RhdGUgIT09IG51bGwgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBfZXh0ZW5kcyh7fSwgaW5zdGFuY2Uuc3RhdGUsIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG52YXIgbWFrZUZyYW1lID0gZnVuY3Rpb24odHlwZSwgaW5zdGFuY2UsIHRoZW5hYmxlKSB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dE1hcDogZ2V0Q3VycmVudENvbnRleHRNYXAoKSxcbiAgICBjb250ZXh0U3RvcmU6IGdldEN1cnJlbnRDb250ZXh0U3RvcmUoKSxcbiAgICBlcnJvckZyYW1lOiBnZXRDdXJyZW50RXJyb3JGcmFtZSgpLFxuICAgIHRoZW5hYmxlOiB0aGVuYWJsZSxcbiAgICBraW5kOiBcImZyYW1lLmNsYXNzXCIsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn07XG5cbnZhciByZW5kZXIkMiA9IGZ1bmN0aW9uKHR5cGUsIGluc3RhbmNlLCBxdWV1ZSkge1xuICBmbHVzaEVucXVldWVkU3RhdGUoaW5zdGFuY2UpO1xuICB2YXIgY2hpbGQgPSBudWxsO1xuICB0cnkge1xuICAgIGNoaWxkID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvci50aGVuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBMQVNNSUM6IEVuY291bnRlcmVkIGVycm9yIHdoZW4gcHJlLXJlbmRlcmluZyBjb21wb25lbnQgXCIgKyBnZXRDb21wb25lbnROYW1lKHR5cGUpICsgXCIuIFRoaXMgaXMgZmluZSBhcyBsb25nIGFzIHlvdSBhcmUgbm90IGZldGNoaW5nIGRhdGEgd2l0aCBAcGxhc21pY2FwcC9xdWVyeSBpbnNpZGUgdGhpcyBjb21wb25lbnQuICBFcnJvcjogXCIgKyBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcXVldWUucHVzaChtYWtlRnJhbWUodHlwZSwgaW5zdGFuY2UsIGVycm9yKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKGNoaWxkQ29udGV4dCAhPT0gbnVsbCAmJiB0eXBlb2YgY2hpbGRDb250ZXh0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBhc3NpZ25Db250ZXh0TWFwKGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyeSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHt9XG4gIH1cbiAgaW5zdGFuY2UuX2lzTW91bnRlZCA9IGZhbHNlO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuXG52YXIgbW91bnQkMSA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSwgdmlzaXRvciwgZWxlbWVudCkge1xuICBzZXRDdXJyZW50SWRlbnRpdHkobnVsbCk7XG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzKTtcbiAgdmFyIHByb21pc2UgPSB2aXNpdG9yKGVsZW1lbnQsIGluc3RhbmNlKTtcbiAgaWYgKHByb21pc2UpIHtcbiAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSh0eXBlLCBpbnN0YW5jZSwgcHJvbWlzZSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXIkMih0eXBlLCBpbnN0YW5jZSwgcXVldWUpO1xufTtcblxudmFyIHVwZGF0ZSQyID0gZnVuY3Rpb24ocXVldWUsIGZyYW1lKSB7XG4gIHNldEN1cnJlbnRJZGVudGl0eShudWxsKTtcbiAgc2V0Q3VycmVudENvbnRleHRNYXAoZnJhbWUuY29udGV4dE1hcCk7XG4gIHNldEN1cnJlbnRDb250ZXh0U3RvcmUoZnJhbWUuY29udGV4dFN0b3JlKTtcbiAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUuZXJyb3JGcmFtZSk7XG4gIGlmIChmcmFtZS5lcnJvcikge1xuICAgIGlmICgrK2ZyYW1lLmluc3RhbmNlLnVwZGF0ZXIuX3Rocm93biA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmcmFtZS5pbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGZyYW1lLmluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZyYW1lLmluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGZyYW1lLmVycm9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcmFtZS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmcmFtZS5pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShmcmFtZS5pbnN0YW5jZSwgZnJhbWUudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZnJhbWUuZXJyb3IpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlciQyKGZyYW1lLnR5cGUsIGZyYW1lLmluc3RhbmNlLCBxdWV1ZSk7XG59O1xuXG5mdW5jdGlvbiBfcmVmJDEoZWx0KSB7XG4gIHJldHVybiBlbHQgJiYgdHlwZW9mIGVsdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlT2YoZWx0KTtcbn1cblxudmFyIHJlbmRlciQxID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlLCBjbGllbnRSZWZWaXNpdG9yLCBlbGVtZW50KSB7XG4gIHRyeSB7XG4gICAgdmFyIG5vZGUgPSBjbGllbnRSZWZWaXNpdG9yKGVsZW1lbnQpO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7fSwgW10uY29uY2F0KG5vZGUgPyBnZXRDaGlsZHJlbkFycmF5KG5vZGUpIDogT2JqZWN0LnZhbHVlcyhwcm9wcykuZmxhdChJbmZpbml0eSkuZmlsdGVyKF9yZWYkMSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiUExBU01JQzogRW5jb3VudGVyZWQgZXJyb3Igd2hlbiBwcmUtcmVuZGVyaW5nIGNsaWVudCByZWZlcmVuY2U6IFwiICsgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgY29udGV4dE1hcDogZ2V0Q3VycmVudENvbnRleHRNYXAoKSxcbiAgICAgIGNvbnRleHRTdG9yZTogZ2V0Q3VycmVudENvbnRleHRTdG9yZSgpLFxuICAgICAgZXJyb3JGcmFtZTogZ2V0Q3VycmVudEVycm9yRnJhbWUoKSxcbiAgICAgIGlkOiBnZXRDdXJyZW50SWRlbnRpdHkoKSxcbiAgICAgIGhvb2s6IGdldEZpcnN0SG9vaygpLFxuICAgICAgdGhlbmFibGU6IGVycm9yLFxuICAgICAga2luZDogXCJjbGllbnQtcmVmXCIsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGNsaWVudFJlZlZpc2l0b3I6IGNsaWVudFJlZlZpc2l0b3JcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIG1vdW50ID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlLCBjbGllbnRSZWZWaXNpdG9yLCBlbGVtZW50KSB7XG4gIHNldEZpcnN0SG9vayhudWxsKTtcbiAgc2V0Q3VycmVudElkZW50aXR5KG1ha2VJZGVudGl0eSgpKTtcbiAgcmV0dXJuIHJlbmRlciQxKHR5cGUsIHByb3BzLCBxdWV1ZSwgY2xpZW50UmVmVmlzaXRvciwgZWxlbWVudCk7XG59O1xuXG52YXIgdXBkYXRlJDEgPSBmdW5jdGlvbihxdWV1ZSwgZnJhbWUpIHtcbiAgc2V0Rmlyc3RIb29rKGZyYW1lLmhvb2spO1xuICBzZXRDdXJyZW50SWRlbnRpdHkoZnJhbWUuaWQpO1xuICBzZXRDdXJyZW50Q29udGV4dE1hcChmcmFtZS5jb250ZXh0TWFwKTtcbiAgc2V0Q3VycmVudENvbnRleHRTdG9yZShmcmFtZS5jb250ZXh0U3RvcmUpO1xuICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZS5lcnJvckZyYW1lKTtcbiAgcmV0dXJuIHJlbmRlciQxKGZyYW1lLnR5cGUsIGZyYW1lLnByb3BzLCBxdWV1ZSwgZnJhbWUuY2xpZW50UmVmVmlzaXRvciwgZnJhbWUuZWxlbWVudCk7XG59O1xuXG52YXIgUkVBQ1RfSU5URVJOQUxTID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgfHwgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIHx8IFJlYWN0Ll9fU0VSVkVSX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSRUFDVF9JTlRFUk5BTFMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciB8fCBSRUFDVF9JTlRFUk5BTFM7XG5cbnZhciBnZXRSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgfHwgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5IO1xufTtcblxudmFyIGluamVjdFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbihuZXdEaXNwYXRjaGVyKSB7XG4gIGlmICghaXNSZWFjdDE5KCkpIHtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBuZXdEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuSCA9IG5ld0Rpc3BhdGNoZXI7XG4gIH1cbn07XG5cbnZhciBTSE9VTERfWUlFTEQgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCI7XG5cbnZhciBZSUVMRF9BRlRFUl9NUyA9IDU7XG5cbnZhciByZW5kZXIgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IsIGVsZW1lbnQpIHtcbiAgaWYgKGlzQ2xpZW50UmVmZXJlbmNlKHR5cGUpKSB7XG4gICAgcmV0dXJuIG1vdW50KHR5cGUsIHByb3BzLCBxdWV1ZSwgY2xpZW50UmVmVmlzaXRvciwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IG1vdW50JDEodHlwZSwgcHJvcHMsIHF1ZXVlLCB2aXNpdG9yLCBlbGVtZW50KSA6IG1vdW50JDIodHlwZSwgcHJvcHMsIHF1ZXVlLCB2aXNpdG9yLCBlbGVtZW50KTtcbn07XG5cbnZhciB2aXNpdEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcikge1xuICBzd2l0Y2ggKHR5cGVPZihlbGVtZW50KSkge1xuICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgZnJhZ21lbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGZyYWdtZW50RWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAge1xuICAgICAgdmFyIHByb3ZpZGVyRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB2YXIgcmVmID0gcHJvdmlkZXJFbGVtZW50LnByb3BzO1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgICAgdmFyIHR5cGUgPSBwcm92aWRlckVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBjb250ZXh0ID0gdHlwZW9mIHR5cGUuX2NvbnRleHQgPT09IFwib2JqZWN0XCIgPyB0eXBlLl9jb250ZXh0IDogdHlwZTtcbiAgICAgIHNldENvbnRleHRWYWx1ZShjb250ZXh0LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZHJlbik7XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAge1xuICAgICAgdmFyIGNvbnN1bWVyRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB2YXIgcmVmJDEgPSBjb25zdW1lckVsZW1lbnQucHJvcHM7XG4gICAgICB2YXIgY2hpbGRyZW4kMSA9IHJlZiQxLmNoaWxkcmVuO1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiQxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHR5cGUkMSA9IGNvbnN1bWVyRWxlbWVudC50eXBlO1xuICAgICAgICB2YXIgY29udGV4dCQxID0gdHlwZW9mIHR5cGUkMS5fY29udGV4dCA9PT0gXCJvYmplY3RcIiA/IHR5cGUkMS5fY29udGV4dCA6IHR5cGUkMTtcbiAgICAgICAgdmFyIHZhbHVlJDEgPSByZWFkQ29udGV4dFZhbHVlKGNvbnRleHQkMSk7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkcmVuJDEodmFsdWUkMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAge1xuICAgICAgdmFyIGxhenlFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHZhciB0eXBlJDIgPSBsYXp5RWxlbWVudC50eXBlO1xuICAgICAgdmFyIGNoaWxkID0gbW91bnQkMyh0eXBlJDIsIGxhenlFbGVtZW50LnByb3BzLCBxdWV1ZSk7XG4gICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZCk7XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICB7XG4gICAgICB2YXIgbWVtb0VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIHJlZiQyID0gbWVtb0VsZW1lbnQudHlwZTtcbiAgICAgIHZhciB0eXBlJDMgPSByZWYkMi50eXBlO1xuICAgICAgdmFyIGNoaWxkJDEgPSBjcmVhdGVFbGVtZW50KHR5cGUkMywgbWVtb0VsZW1lbnQucHJvcHMpO1xuICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGQkMSk7XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAge1xuICAgICAgdmFyIHJlZkVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIHJlZiQzID0gcmVmRWxlbWVudC50eXBlO1xuICAgICAgdmFyIHR5cGUkNCA9IHJlZiQzLnJlbmRlcjtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSByZWYkMy5kZWZhdWx0UHJvcHM7XG4gICAgICB2YXIgcHJvcHMgPSBjb21wdXRlUHJvcHMocmVmRWxlbWVudC5wcm9wcywgZGVmYXVsdFByb3BzKTtcbiAgICAgIHZhciBjaGlsZCQyID0gY3JlYXRlRWxlbWVudCh0eXBlJDQsIHByb3BzKTtcbiAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkJDIpO1xuICAgIH1cblxuICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAge1xuICAgICAgdmFyIGVsID0gZWxlbWVudDtcbiAgICAgIGlmICh0eXBlb2YgZWwudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShlbC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdXNlckVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB2YXIgdHlwZSQ1ID0gdXNlckVsZW1lbnQudHlwZTtcbiAgICAgICAgdmFyIHByb3BzJDEgPSB1c2VyRWxlbWVudC5wcm9wcztcbiAgICAgICAgdmFyIGNoaWxkJDMgPSByZW5kZXIodHlwZSQ1LCBwcm9wcyQxLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvciwgdXNlckVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZCQzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICBkZWZhdWx0OlxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxudmFyIHZpc2l0TG9vcCA9IGZ1bmN0aW9uKHRyYXZlcnNhbENoaWxkcmVuLCB0cmF2ZXJzYWxNYXAsIHRyYXZlcnNhbFN0b3JlLCB0cmF2ZXJzYWxFcnJvckZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcikge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBnZXRSZWFjdEN1cnJlbnREaXNwYXRjaGVyKCk7XG4gIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gIHRyeSB7XG4gICAgaW5qZWN0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcihEaXNwYXRjaGVyKTtcbiAgICB3aGlsZSAodHJhdmVyc2FsQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0cmF2ZXJzYWxDaGlsZHJlblt0cmF2ZXJzYWxDaGlsZHJlbi5sZW5ndGggLSAxXS5zaGlmdCgpO1xuICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEVsZW1lbnQoZWxlbWVudCwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICAgICAgICB0cmF2ZXJzYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgdHJhdmVyc2FsTWFwLnB1c2goZmx1c2hQcmV2Q29udGV4dE1hcCgpKTtcbiAgICAgICAgdHJhdmVyc2FsU3RvcmUucHVzaChmbHVzaFByZXZDb250ZXh0U3RvcmUoKSk7XG4gICAgICAgIHRyYXZlcnNhbEVycm9yRnJhbWUucHVzaChnZXRDdXJyZW50RXJyb3JGcmFtZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYXZlcnNhbENoaWxkcmVuLnBvcCgpO1xuICAgICAgICByZXN0b3JlQ29udGV4dE1hcCh0cmF2ZXJzYWxNYXAucG9wKCkpO1xuICAgICAgICByZXN0b3JlQ29udGV4dFN0b3JlKHRyYXZlcnNhbFN0b3JlLnBvcCgpKTtcbiAgICAgICAgc2V0Q3VycmVudEVycm9yRnJhbWUodHJhdmVyc2FsRXJyb3JGcmFtZS5wb3AoKSk7XG4gICAgICB9XG4gICAgICBpZiAoU0hPVUxEX1lJRUxEICYmIERhdGUubm93KCkgLSBzdGFydCA+IFlJRUxEX0FGVEVSX01TKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIGVycm9yRnJhbWUgPSBnZXRDdXJyZW50RXJyb3JGcmFtZSgpO1xuICAgIGlmICghZXJyb3JGcmFtZSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGVycm9yRnJhbWUuZXJyb3IgPSBlcnJvcjtcbiAgICBxdWV1ZS51bnNoaWZ0KGVycm9yRnJhbWUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpbmplY3RSZWFjdEN1cnJlbnREaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgfVxufTtcblxudmFyIG1ha2VZaWVsZEZyYW1lID0gZnVuY3Rpb24odHJhdmVyc2FsQ2hpbGRyZW4sIHRyYXZlcnNhbE1hcCwgdHJhdmVyc2FsU3RvcmUsIHRyYXZlcnNhbEVycm9yRnJhbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0TWFwOiBnZXRDdXJyZW50Q29udGV4dE1hcCgpLFxuICAgIGNvbnRleHRTdG9yZTogZ2V0Q3VycmVudENvbnRleHRTdG9yZSgpLFxuICAgIGVycm9yRnJhbWU6IGdldEN1cnJlbnRFcnJvckZyYW1lKCksXG4gICAgdGhlbmFibGU6IG51bGwsXG4gICAga2luZDogXCJmcmFtZS55aWVsZFwiLFxuICAgIHRyYXZlcnNhbENoaWxkcmVuOiB0cmF2ZXJzYWxDaGlsZHJlbixcbiAgICB0cmF2ZXJzYWxNYXA6IHRyYXZlcnNhbE1hcCxcbiAgICB0cmF2ZXJzYWxTdG9yZTogdHJhdmVyc2FsU3RvcmUsXG4gICAgdHJhdmVyc2FsRXJyb3JGcmFtZTogdHJhdmVyc2FsRXJyb3JGcmFtZVxuICB9O1xufTtcblxudmFyIHZpc2l0ID0gZnVuY3Rpb24oaW5pdCwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpIHtcbiAgdmFyIHRyYXZlcnNhbENoaWxkcmVuID0gWyBpbml0IF07XG4gIHZhciB0cmF2ZXJzYWxNYXAgPSBbIGZsdXNoUHJldkNvbnRleHRNYXAoKSBdO1xuICB2YXIgdHJhdmVyc2FsU3RvcmUgPSBbIGZsdXNoUHJldkNvbnRleHRTdG9yZSgpIF07XG4gIHZhciB0cmF2ZXJzYWxFcnJvckZyYW1lID0gWyBnZXRDdXJyZW50RXJyb3JGcmFtZSgpIF07XG4gIHZhciBoYXNZaWVsZGVkID0gdmlzaXRMb29wKHRyYXZlcnNhbENoaWxkcmVuLCB0cmF2ZXJzYWxNYXAsIHRyYXZlcnNhbFN0b3JlLCB0cmF2ZXJzYWxFcnJvckZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gIGlmIChoYXNZaWVsZGVkKSB7XG4gICAgcXVldWUudW5zaGlmdChtYWtlWWllbGRGcmFtZSh0cmF2ZXJzYWxDaGlsZHJlbiwgdHJhdmVyc2FsTWFwLCB0cmF2ZXJzYWxTdG9yZSwgdHJhdmVyc2FsRXJyb3JGcmFtZSkpO1xuICB9XG59O1xuXG52YXIgdXBkYXRlID0gZnVuY3Rpb24oZnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKSB7XG4gIGlmIChmcmFtZS5raW5kID09PSBcImZyYW1lLnlpZWxkXCIpIHtcbiAgICBzZXRDdXJyZW50SWRlbnRpdHkobnVsbCk7XG4gICAgc2V0Q3VycmVudENvbnRleHRNYXAoZnJhbWUuY29udGV4dE1hcCk7XG4gICAgc2V0Q3VycmVudENvbnRleHRTdG9yZShmcmFtZS5jb250ZXh0U3RvcmUpO1xuICAgIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lLmVycm9yRnJhbWUpO1xuICAgIHZhciBoYXNZaWVsZGVkID0gdmlzaXRMb29wKGZyYW1lLnRyYXZlcnNhbENoaWxkcmVuLCBmcmFtZS50cmF2ZXJzYWxNYXAsIGZyYW1lLnRyYXZlcnNhbFN0b3JlLCBmcmFtZS50cmF2ZXJzYWxFcnJvckZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gICAgaWYgKGhhc1lpZWxkZWQpIHtcbiAgICAgIHF1ZXVlLnVuc2hpZnQobWFrZVlpZWxkRnJhbWUoZnJhbWUudHJhdmVyc2FsQ2hpbGRyZW4sIGZyYW1lLnRyYXZlcnNhbE1hcCwgZnJhbWUudHJhdmVyc2FsU3RvcmUsIGZyYW1lLnRyYXZlcnNhbEVycm9yRnJhbWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZXZEaXNwYXRjaGVyID0gZ2V0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcigpO1xuICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gICAgaW5qZWN0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcihEaXNwYXRjaGVyKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGZyYW1lLmtpbmQgPT09IFwiZnJhbWUuY2xhc3NcIikge1xuICAgICAgICBjaGlsZHJlbiA9IHVwZGF0ZSQyKHF1ZXVlLCBmcmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGZyYW1lLmtpbmQgPT09IFwiZnJhbWUuaG9va3NcIikge1xuICAgICAgICBjaGlsZHJlbiA9IHVwZGF0ZSQzKHF1ZXVlLCBmcmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGZyYW1lLmtpbmQgPT09IFwiZnJhbWUubGF6eVwiKSB7XG4gICAgICAgIGNoaWxkcmVuID0gdXBkYXRlJDQocXVldWUsIGZyYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWUua2luZCA9PT0gXCJjbGllbnQtcmVmXCIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB1cGRhdGUkMShxdWV1ZSwgZnJhbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2YXIgZXJyb3JGcmFtZSA9IGdldEN1cnJlbnRFcnJvckZyYW1lKCk7XG4gICAgICBpZiAoIWVycm9yRnJhbWUpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBlcnJvckZyYW1lLmVycm9yID0gZXJyb3I7XG4gICAgICBxdWV1ZS51bnNoaWZ0KGVycm9yRnJhbWUpO1xuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpbmplY3RSZWFjdEN1cnJlbnREaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgICB9XG4gICAgdmlzaXQoZ2V0Q2hpbGRyZW5BcnJheShjaGlsZHJlbiksIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3JlZihyZXNvbHZlLCByZWplY3QpIHtcbiAgc2V0SW1tZWRpYXRlKHJlc29sdmUpO1xufVxuXG52YXIgZmx1c2hGcmFtZXMgPSBmdW5jdGlvbihxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvciwgc3RhdGUpIHtcbiAgdmFyIGZyYW1lID0gcXVldWUuc2hpZnQoKTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoU0hPVUxEX1lJRUxEICYmIGZyYW1lLmtpbmQgPT09IFwiZnJhbWUueWllbGRcIikge1xuICAgIGZyYW1lLnRoZW5hYmxlID0gbmV3IFByb21pc2UoX3JlZik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmcmFtZS50aGVuYWJsZSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgc2V0Q3VycmVudFJlbmRlcmVyU3RhdGUoc3RhdGUpO1xuICAgIHVwZGF0ZShmcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICAgIHJldHVybiBmbHVzaEZyYW1lcyhxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvciwgc3RhdGUpO1xuICB9KSwgKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKCFmcmFtZS5lcnJvckZyYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZnJhbWUuZXJyb3JGcmFtZS5lcnJvciA9IGVycm9yO1xuICAgIHVwZGF0ZShmcmFtZS5lcnJvckZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gIH0pKTtcbn07XG5cbnZhciBkZWZhdWx0VmlzaXRvciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxudmFyIHJ1bm5pbmdQcmVwYXNzQ291bnQgPSAwO1xuXG5mdW5jdGlvbiBfcmVmMigpIHtcbiAgcnVubmluZ1ByZXBhc3NDb3VudC0tO1xuICBpZiAoIXJ1bm5pbmdQcmVwYXNzQ291bnQpIHtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5fX3NzclByZXBhc3NFbnY7XG4gIH1cbn1cblxudmFyIHJlbmRlclByZXBhc3MgPSBmdW5jdGlvbihlbGVtZW50LCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKSB7XG4gIGlmICghdmlzaXRvcikge1xuICAgIHZpc2l0b3IgPSBkZWZhdWx0VmlzaXRvcjtcbiAgfVxuICBpZiAoIWNsaWVudFJlZlZpc2l0b3IpIHtcbiAgICBjbGllbnRSZWZWaXNpdG9yID0gZGVmYXVsdFZpc2l0b3I7XG4gIH1cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGF0ZSA9IGluaXRSZW5kZXJlclN0YXRlKCk7XG4gIHNldEN1cnJlbnRDb250ZXh0TWFwKHt9KTtcbiAgc2V0Q3VycmVudENvbnRleHRTdG9yZShuZXcgTWFwKTtcbiAgc2V0Q3VycmVudEVycm9yRnJhbWUobnVsbCk7XG4gIHRyeSB7XG4gICAgcnVubmluZ1ByZXBhc3NDb3VudCsrO1xuICAgIGdsb2JhbFRoaXMuX19zc3JQcmVwYXNzRW52ID0ge1xuICAgICAgcmVhZENvbnRleHRWYWx1ZTogcmVhZENvbnRleHRWYWx1ZSxcbiAgICAgIHNldENvbnRleHRWYWx1ZTogc2V0Q29udGV4dFZhbHVlXG4gICAgfTtcbiAgICB2aXNpdChnZXRDaGlsZHJlbkFycmF5KGVsZW1lbnQpLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcnVubmluZ1ByZXBhc3NDb3VudC0tO1xuICAgIGlmICghcnVubmluZ1ByZXBhc3NDb3VudCkge1xuICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuX19zc3JQcmVwYXNzRW52O1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG4gIHJldHVybiBmbHVzaEZyYW1lcyhxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvciwgc3RhdGUpLmZpbmFsbHkoX3JlZjIpO1xufTtcblxuZXhwb3J0IHsgcmVuZGVyUHJlcGFzcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1zc3ItcHJlcGFzcy5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/prepass/node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@plasmicapp/query/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeadMetadataContext: () => (/* binding */ HeadMetadataContext),\n/* harmony export */   PlasmicPrepassContext: () => (/* binding */ PlasmicPrepassContext),\n/* harmony export */   PlasmicQueryDataProvider: () => (/* binding */ PlasmicQueryDataProvider),\n/* harmony export */   addLoadingStateListener: () => (/* binding */ addLoadingStateListener),\n/* harmony export */   isPlasmicPrepass: () => (/* binding */ isPlasmicPrepass),\n/* harmony export */   useMutablePlasmicQueryData: () => (/* binding */ useMutablePlasmicQueryData),\n/* harmony export */   usePlasmicDataConfig: () => (/* binding */ usePlasmicDataConfig),\n/* harmony export */   usePlasmicQueryData: () => (/* binding */ usePlasmicQueryData),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig),\n/* harmony export */   wrapLoadingFetcher: () => (/* binding */ wrapLoadingFetcher)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(pages-dir-browser)/./node_modules/@plasmicapp/query/node_modules/swr/dist/index.mjs\");\n\"use client\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/query-data.tsx\n\n\nvar __SWRConfig = void 0;\nvar mutateKeys = (invalidateKey) => {\n  if (__SWRConfig) {\n    const { cache, mutate } = __SWRConfig;\n    (invalidateKey != null ? [invalidateKey] : Array.from(cache.keys())).forEach((key) => {\n      mutate(key);\n    });\n  }\n};\nfunction getPlasmicDefaultSWROptions(opts) {\n  return {\n    revalidateIfStale: !!(opts == null ? void 0 : opts.isMutable),\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false\n  };\n}\nfunction usePlasmicQueryData(key, fetcher) {\n  const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const wrappedFetcher = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(\n    () => wrapLoadingFetcher(fetcher),\n    [fetcher]\n  );\n  const resp = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, wrappedFetcher, opts);\n  if (resp.data !== void 0) {\n    return { data: resp.data };\n  } else if (resp.error) {\n    return { error: resp.error };\n  } else {\n    return { isLoading: true };\n  }\n}\nfunction useMutablePlasmicQueryData(key, fetcher, options) {\n  const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n  const opts = __spreadValues(__spreadValues({}, getPlasmicDefaultSWROptions({ isMutable: true })), options);\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n  const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n  const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n  const fetcherWrapper = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(\n    (...args) => __async(this, null, function* () {\n      setIsLoading(true);\n      try {\n        return yield wrapLoadingFetcher(fetcher)(...args);\n      } finally {\n        setIsLoading(false);\n      }\n    }),\n    [fetcher]\n  );\n  const laggyDataRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n  const { isValidating, mutate, data, error } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n    key,\n    fetcherWrapper,\n    opts\n  );\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    if (data !== void 0) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(\n    () => __spreadValues(__spreadValues({\n      isValidating,\n      mutate,\n      isLoading: data === void 0 && error === void 0 || isLoading\n    }, data !== void 0 ? { data } : error === void 0 && laggyDataRef.current ? (\n      // Show previous data if available\n      { data: laggyDataRef.current, isLagging: true }\n    ) : {}), error !== void 0 ? { error } : {}),\n    [isValidating, mutate, data, error, isLoading]\n  );\n}\nfunction PlasmicQueryDataProvider(props) {\n  const { children, suspense, prefetchedCache } = props;\n  const prepass = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n  if (prepass) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children);\n  } else {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\n      swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig,\n      {\n        value: {\n          fallback: prefetchedCache != null ? prefetchedCache : {},\n          suspense\n        }\n      },\n      children\n    );\n  }\n}\nvar PrepassContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(false);\nfunction PlasmicPrepassContext(props) {\n  const { cache, children } = props;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrepassContext.Provider, { value: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\n    swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig,\n    {\n      value: {\n        provider: () => cache,\n        suspense: true,\n        fallback: {}\n      }\n    },\n    children\n  ));\n}\nvar usePlasmicDataConfig = swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig;\nvar loadingCount = 0;\nvar listeners = [];\nfunction addLoadingStateListener(listener, opts) {\n  listeners.push(listener);\n  if (opts == null ? void 0 : opts.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\nfunction wrapLoadingFetcher(fetcher) {\n  return (...args) => __async(this, null, function* () {\n    if (loadingCount === 0) {\n      listeners.forEach((listener) => listener(true));\n    }\n    loadingCount += 1;\n    try {\n      const res = fetcher(...args);\n      return isPromiseLike(res) ? yield res : res;\n    } finally {\n      loadingCount -= 1;\n      if (loadingCount === 0) {\n        listeners.forEach((listener) => listener(false));\n      }\n    }\n  });\n}\nfunction isPromiseLike(x) {\n  return !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\";\n}\nfunction isPlasmicPrepass() {\n  var _a, _b, _c;\n  return !!((_c = (_b = (_a = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) == null ? void 0 : _a.ReactCurrentDispatcher) == null ? void 0 : _b.current) == null ? void 0 : _c.isPlasmicPrepass);\n}\nvar HeadMetadataContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({});\n\n// src/index.tsx\n\nif (typeof window !== \"undefined\") {\n  const root = window;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = (invalidateKey) => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9xdWVyeS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUMwQjtBQUliO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaURBQVk7QUFDN0IsRUFBRSxzREFBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsb0RBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFnQjtBQUNyQywrQ0FBK0MsZ0NBQWdDLGlCQUFpQjtBQUNoRztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaURBQVk7QUFDN0IsRUFBRSxzREFBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MscURBQWM7QUFDbEQseUJBQXlCLHdEQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVk7QUFDbkMsVUFBVSxvQ0FBb0MsRUFBRSwrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsb0RBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQixPQUFPO0FBQ2xDO0FBQ0EsUUFBUTtBQUNSLFVBQVUsd0JBQXdCLFFBQVEsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hELGtCQUFrQix1REFBZ0I7QUFDbEM7QUFDQSwyQkFBMkIsMERBQW1CLENBQUMsdURBQWM7QUFDN0QsSUFBSTtBQUNKLDJCQUEyQiwwREFBbUI7QUFDOUMsTUFBTSwwQ0FBUztBQUNmO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBbUI7QUFDeEM7QUFDQSxVQUFVLGtCQUFrQjtBQUM1Qix5QkFBeUIsMERBQW1CLDRCQUE0QixhQUFhLGtCQUFrQiwwREFBbUI7QUFDMUgsSUFBSSwwQ0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpR0FBd0Q7QUFDdEY7QUFDQSwwQkFBMEIsMERBQW1CLEdBQUc7O0FBRWhEO0FBQ29EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxAcGxhc21pY2FwcFxccXVlcnlcXGRpc3RcXGluZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9xdWVyeS1kYXRhLnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiwge1xuICBTV1JDb25maWcsXG4gIHVzZVNXUkNvbmZpZ1xufSBmcm9tIFwic3dyXCI7XG52YXIgX19TV1JDb25maWcgPSB2b2lkIDA7XG52YXIgbXV0YXRlS2V5cyA9IChpbnZhbGlkYXRlS2V5KSA9PiB7XG4gIGlmIChfX1NXUkNvbmZpZykge1xuICAgIGNvbnN0IHsgY2FjaGUsIG11dGF0ZSB9ID0gX19TV1JDb25maWc7XG4gICAgKGludmFsaWRhdGVLZXkgIT0gbnVsbCA/IFtpbnZhbGlkYXRlS2V5XSA6IEFycmF5LmZyb20oY2FjaGUua2V5cygpKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBtdXRhdGUoa2V5KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFBsYXNtaWNEZWZhdWx0U1dST3B0aW9ucyhvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6ICEhKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaXNNdXRhYmxlKSxcbiAgICByZXZhbGlkYXRlT25Gb2N1czogZmFsc2UsXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlUGxhc21pY1F1ZXJ5RGF0YShrZXksIGZldGNoZXIpIHtcbiAgY29uc3QgcHJlcGFzc0N0eCA9IFJlYWN0LnVzZUNvbnRleHQoUHJlcGFzc0NvbnRleHQpO1xuICBjb25zdCBvcHRzID0gZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKCk7XG4gIGlmIChwcmVwYXNzQ3R4KSB7XG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cbiAgY29uc3QgY29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgX19TV1JDb25maWcgPSBjb25maWc7XG4gIH0sIFtjb25maWddKTtcbiAgY29uc3Qgd3JhcHBlZEZldGNoZXIgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IHdyYXBMb2FkaW5nRmV0Y2hlcihmZXRjaGVyKSxcbiAgICBbZmV0Y2hlcl1cbiAgKTtcbiAgY29uc3QgcmVzcCA9IHVzZVNXUihrZXksIHdyYXBwZWRGZXRjaGVyLCBvcHRzKTtcbiAgaWYgKHJlc3AuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgZGF0YTogcmVzcC5kYXRhIH07XG4gIH0gZWxzZSBpZiAocmVzcC5lcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiByZXNwLmVycm9yIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhKGtleSwgZmV0Y2hlciwgb3B0aW9ucykge1xuICBjb25zdCBwcmVwYXNzQ3R4ID0gUmVhY3QudXNlQ29udGV4dChQcmVwYXNzQ29udGV4dCk7XG4gIGNvbnN0IG9wdHMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKHsgaXNNdXRhYmxlOiB0cnVlIH0pKSwgb3B0aW9ucyk7XG4gIGlmIChwcmVwYXNzQ3R4KSB7XG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cbiAgY29uc3QgY29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgX19TV1JDb25maWcgPSBjb25maWc7XG4gIH0sIFtjb25maWddKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgZmV0Y2hlcldyYXBwZXIgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoLi4uYXJncykgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHdyYXBMb2FkaW5nRmV0Y2hlcihmZXRjaGVyKSguLi5hcmdzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSksXG4gICAgW2ZldGNoZXJdXG4gICk7XG4gIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCB7IGlzVmFsaWRhdGluZywgbXV0YXRlLCBkYXRhLCBlcnJvciB9ID0gdXNlU1dSKFxuICAgIGtleSxcbiAgICBmZXRjaGVyV3JhcHBlcixcbiAgICBvcHRzXG4gICk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIH1cbiAgfSwgW2RhdGFdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaXNWYWxpZGF0aW5nLFxuICAgICAgbXV0YXRlLFxuICAgICAgaXNMb2FkaW5nOiBkYXRhID09PSB2b2lkIDAgJiYgZXJyb3IgPT09IHZvaWQgMCB8fCBpc0xvYWRpbmdcbiAgICB9LCBkYXRhICE9PSB2b2lkIDAgPyB7IGRhdGEgfSA6IGVycm9yID09PSB2b2lkIDAgJiYgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPyAoXG4gICAgICAvLyBTaG93IHByZXZpb3VzIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICB7IGRhdGE6IGxhZ2d5RGF0YVJlZi5jdXJyZW50LCBpc0xhZ2dpbmc6IHRydWUgfVxuICAgICkgOiB7fSksIGVycm9yICE9PSB2b2lkIDAgPyB7IGVycm9yIH0gOiB7fSksXG4gICAgW2lzVmFsaWRhdGluZywgbXV0YXRlLCBkYXRhLCBlcnJvciwgaXNMb2FkaW5nXVxuICApO1xufVxuZnVuY3Rpb24gUGxhc21pY1F1ZXJ5RGF0YVByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIHN1c3BlbnNlLCBwcmVmZXRjaGVkQ2FjaGUgfSA9IHByb3BzO1xuICBjb25zdCBwcmVwYXNzID0gUmVhY3QudXNlQ29udGV4dChQcmVwYXNzQ29udGV4dCk7XG4gIGlmIChwcmVwYXNzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU1dSQ29uZmlnLFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZhbGxiYWNrOiBwcmVmZXRjaGVkQ2FjaGUgIT0gbnVsbCA/IHByZWZldGNoZWRDYWNoZSA6IHt9LFxuICAgICAgICAgIHN1c3BlbnNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cbn1cbnZhciBQcmVwYXNzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuZnVuY3Rpb24gUGxhc21pY1ByZXBhc3NDb250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IHsgY2FjaGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFByZXBhc3NDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0cnVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFNXUkNvbmZpZyxcbiAgICB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBwcm92aWRlcjogKCkgPT4gY2FjaGUsXG4gICAgICAgIHN1c3BlbnNlOiB0cnVlLFxuICAgICAgICBmYWxsYmFjazoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICkpO1xufVxudmFyIHVzZVBsYXNtaWNEYXRhQ29uZmlnID0gdXNlU1dSQ29uZmlnO1xudmFyIGxvYWRpbmdDb3VudCA9IDA7XG52YXIgbGlzdGVuZXJzID0gW107XG5mdW5jdGlvbiBhZGRMb2FkaW5nU3RhdGVMaXN0ZW5lcihsaXN0ZW5lciwgb3B0cykge1xuICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmltbWVkaWF0ZSkge1xuICAgIGxpc3RlbmVyKGxvYWRpbmdDb3VudCA+IDApO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcExvYWRpbmdGZXRjaGVyKGZldGNoZXIpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKGxvYWRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0cnVlKSk7XG4gICAgfVxuICAgIGxvYWRpbmdDb3VudCArPSAxO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBmZXRjaGVyKC4uLmFyZ3MpO1xuICAgICAgcmV0dXJuIGlzUHJvbWlzZUxpa2UocmVzKSA/IHlpZWxkIHJlcyA6IHJlcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9hZGluZ0NvdW50IC09IDE7XG4gICAgICBpZiAobG9hZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh4KSB7XG4gIHJldHVybiAhIXggJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4geCAmJiB0eXBlb2YgeC50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc1BsYXNtaWNQcmVwYXNzKCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgcmV0dXJuICEhKChfYyA9IChfYiA9IChfYSA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEKSA9PSBudWxsID8gdm9pZCAwIDogX2EuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pc1BsYXNtaWNQcmVwYXNzKTtcbn1cbnZhciBIZWFkTWV0YWRhdGFDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5cbi8vIHNyYy9pbmRleC50c3hcbmltcG9ydCB7IHVzZVNXUkNvbmZpZyBhcyB1c2VTV1JDb25maWcyIH0gZnJvbSBcInN3clwiO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29uc3Qgcm9vdCA9IHdpbmRvdztcbiAgY29uc3QgbWF5YmVFeGlzdGluZ011dGF0ZUFsbEtleXMgPSByb290Ll9fU1dSTXV0YXRlQWxsS2V5cztcbiAgcm9vdC5fX1NXUk11dGF0ZUFsbEtleXMgPSAoaW52YWxpZGF0ZUtleSkgPT4ge1xuICAgIG11dGF0ZUtleXMoaW52YWxpZGF0ZUtleSk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUV4aXN0aW5nTXV0YXRlQWxsS2V5cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBtYXliZUV4aXN0aW5nTXV0YXRlQWxsS2V5cyhpbnZhbGlkYXRlS2V5KTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBIZWFkTWV0YWRhdGFDb250ZXh0LFxuICBQbGFzbWljUHJlcGFzc0NvbnRleHQsXG4gIFBsYXNtaWNRdWVyeURhdGFQcm92aWRlcixcbiAgYWRkTG9hZGluZ1N0YXRlTGlzdGVuZXIsXG4gIGlzUGxhc21pY1ByZXBhc3MsXG4gIHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhLFxuICB1c2VQbGFzbWljRGF0YUNvbmZpZyxcbiAgdXNlUGxhc21pY1F1ZXJ5RGF0YSxcbiAgdXNlU1dSQ29uZmlnMiBhcyB1c2VTV1JDb25maWcsXG4gIHdyYXBMb2FkaW5nRmV0Y2hlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@plasmicapp/query/node_modules/swr/dist/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@plasmicapp/query/node_modules/swr/dist/index.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar noop = function () { };\n// Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nvar UNDEFINED = ( /*#__NOINLINE__*/noop());\nvar OBJECT = Object;\nvar isUndefined = function (v) { return v === UNDEFINED; };\nvar isFunction = function (v) { return typeof v == 'function'; };\nvar mergeObjects = function (a, b) { return OBJECT.assign({}, a, b); };\nvar STR_UNDEFINED = 'undefined';\n// NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nvar hasWindow = function () { return typeof window != STR_UNDEFINED; };\nvar hasDocument = function () { return typeof document != STR_UNDEFINED; };\nvar hasRequestAnimationFrame = function () {\n    return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n};\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\nvar stableHash = function (arg) {\n    var type = typeof arg;\n    var constructor = arg && arg.constructor;\n    var isDate = constructor == Date;\n    var result;\n    var index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result)\n            return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for (index = 0; index < arg.length; index++) {\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            var keys = OBJECT.keys(arg).sort();\n            while (!isUndefined((index = keys.pop()))) {\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    }\n    else {\n        result = isDate\n            ? arg.toJSON()\n            : type == 'symbol'\n                ? arg.toString()\n                : type == 'string'\n                    ? JSON.stringify(arg)\n                    : '' + arg;\n    }\n    return result;\n};\n\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */\nvar online = true;\nvar isOnline = function () { return online; };\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument();\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nvar onWindowEvent = hasWin && window.addEventListener\n    ? window.addEventListener.bind(window)\n    : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener\n    ? window.removeEventListener.bind(window)\n    : noop;\nvar offDocumentEvent = hasDoc\n    ? document.removeEventListener.bind(document)\n    : noop;\nvar isVisible = function () {\n    var visibilityState = hasDoc && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nvar initFocus = function (callback) {\n    // focus revalidate\n    onDocumentEvent('visibilitychange', callback);\n    onWindowEvent('focus', callback);\n    return function () {\n        offDocumentEvent('visibilitychange', callback);\n        offWindowEvent('focus', callback);\n    };\n};\nvar initReconnect = function (callback) {\n    // revalidate on reconnected\n    var onOnline = function () {\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    var onOffline = function () {\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return function () {\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nvar preset = {\n    isOnline: isOnline,\n    isVisible: isVisible\n};\nvar defaultConfigOptions = {\n    initFocus: initFocus,\n    initReconnect: initReconnect\n};\n\nvar IS_SERVER = !hasWindow() || 'Deno' in window;\n// Polyfill requestAnimationFrame\nvar rAF = function (f) {\n    return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n};\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nvar navigatorConnection = typeof navigator !== 'undefined' &&\n    navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nvar slowConnection = !IS_SERVER &&\n    navigatorConnection &&\n    (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) ||\n        navigatorConnection.saveData);\n\nvar serialize = function (key) {\n    if (isFunction(key)) {\n        try {\n            key = key();\n        }\n        catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    var args = [].concat(key);\n    // If key is not falsy, or not an empty array, hash it.\n    key =\n        typeof key == 'string'\n            ? key\n            : (Array.isArray(key) ? key.length : key)\n                ? stableHash(key)\n                : '';\n    var infoKey = key ? '$swr$' + key : '';\n    return [key, args, infoKey];\n};\n\n// Global state used to deduplicate requests and store listeners\nvar SWRGlobalState = new WeakMap();\n\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n    if (broadcast === void 0) { broadcast = true; }\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], FETCH = _a[3];\n    var revalidators = EVENT_REVALIDATORS[key];\n    var updaters = STATE_UPDATERS[key];\n    // Cache was populated, update states of all hooks.\n    if (broadcast && updaters) {\n        for (var i = 0; i < updaters.length; ++i) {\n            updaters[i](data, error, isValidating);\n        }\n    }\n    // If we also need to revalidate, only do it for the first hook.\n    if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n            return revalidators[0](MUTATE_EVENT).then(function () {\n                return cache.get(key);\n            });\n        }\n    }\n    return cache.get(key);\n};\n\n// Global timestamp.\nvar __timestamp = 0;\nvar getTimestamp = function () { return ++__timestamp; };\n\nvar internalMutate = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n                    options = typeof _opts === 'boolean' ? { revalidate: _opts } : _opts || {};\n                    populateCache = isUndefined(options.populateCache)\n                        ? true\n                        : options.populateCache;\n                    revalidate = options.revalidate !== false;\n                    rollbackOnError = options.rollbackOnError !== false;\n                    customOptimisticData = options.optimisticData;\n                    _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n                    if (!key)\n                        return [2 /*return*/];\n                    _b = SWRGlobalState.get(cache), MUTATION = _b[2];\n                    // If there is no new data provided, revalidate the key with current state.\n                    if (args.length < 3) {\n                        // Revalidate and broadcast state.\n                        return [2 /*return*/, broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n                    }\n                    data = _data;\n                    beforeMutationTs = getTimestamp();\n                    MUTATION[key] = [beforeMutationTs, 0];\n                    hasCustomOptimisticData = !isUndefined(customOptimisticData);\n                    rollbackData = cache.get(key);\n                    // Do optimistic data update.\n                    if (hasCustomOptimisticData) {\n                        optimisticData = isFunction(customOptimisticData)\n                            ? customOptimisticData(rollbackData)\n                            : customOptimisticData;\n                        cache.set(key, optimisticData);\n                        broadcastState(cache, key, optimisticData);\n                    }\n                    if (isFunction(data)) {\n                        // `data` is a function, call it passing current cache value.\n                        try {\n                            data = data(cache.get(key));\n                        }\n                        catch (err) {\n                            // If it throws an error synchronously, we shouldn't update the cache.\n                            error = err;\n                        }\n                    }\n                    if (!(data && isFunction(data.then))) return [3 /*break*/, 2];\n                    return [4 /*yield*/, data.catch(function (err) {\n                            error = err;\n                        })\n                        // Check if other mutations have occurred since we've started this mutation.\n                        // If there's a race we don't update cache or broadcast the change,\n                        // just return the data.\n                    ];\n                case 1:\n                    // This means that the mutation is async, we need to check timestamps to\n                    // avoid race conditions.\n                    data = _c.sent();\n                    // Check if other mutations have occurred since we've started this mutation.\n                    // If there's a race we don't update cache or broadcast the change,\n                    // just return the data.\n                    if (beforeMutationTs !== MUTATION[key][0]) {\n                        if (error)\n                            throw error;\n                        return [2 /*return*/, data];\n                    }\n                    else if (error && hasCustomOptimisticData && rollbackOnError) {\n                        // Rollback. Always populate the cache in this case but without\n                        // transforming the data.\n                        populateCache = true;\n                        data = rollbackData;\n                        cache.set(key, rollbackData);\n                    }\n                    _c.label = 2;\n                case 2:\n                    // If we should write back the cache after request.\n                    if (populateCache) {\n                        if (!error) {\n                            // Transform the result into data.\n                            if (isFunction(populateCache)) {\n                                data = populateCache(data, rollbackData);\n                            }\n                            // Only update cached data if there's no error. Data can be `undefined` here.\n                            cache.set(key, data);\n                        }\n                        // Always update or reset the error.\n                        cache.set(keyInfo, mergeObjects(cache.get(keyInfo), { error: error }));\n                    }\n                    // Reset the timestamp to mark the mutation has ended.\n                    MUTATION[key][1] = getTimestamp();\n                    return [4 /*yield*/, broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache)\n                        // Throw error or return data\n                    ];\n                case 3:\n                    res = _c.sent();\n                    // Throw error or return data\n                    if (error)\n                        throw error;\n                    return [2 /*return*/, populateCache ? res : data];\n            }\n        });\n    });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n    for (var key in revalidators) {\n        if (revalidators[key][0])\n            revalidators[key][0](type);\n    }\n};\nvar initCache = function (provider, options) {\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that bound to\n    // the cache.\n    // Provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        var opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        var EVENT_REVALIDATORS = {};\n        var mutate = internalMutate.bind(UNDEFINED, provider);\n        var unmount = noop;\n        // Update the state if it's new, or the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]);\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        if (!IS_SERVER) {\n            // When listening to the native events for auto revalidations,\n            // we intentionally put a delay (setTimeout) here to make sure they are\n            // fired after immediate JavaScript executions, which can possibly be\n            // React's state updates.\n            // This avoids some unnecessary revalidations such as\n            // https://github.com/vercel/swr/issues/1680.\n            var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n            var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n            unmount = function () {\n                releaseFocus_1 && releaseFocus_1();\n                releaseReconnect_1 && releaseReconnect_1();\n                // When un-mounting, we need to remove the cache provider from the state\n                // storage too because it's a side-effect. Otherwise when re-mounting we\n                // will not re-register those event listeners.\n                SWRGlobalState.delete(provider);\n            };\n        }\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [provider, mutate, unmount];\n    }\n    return [provider, SWRGlobalState.get(provider)[4]];\n};\n\n// error retry\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n    var maxRetryCount = config.errorRetryCount;\n    var currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    var timeout = ~~((Math.random() + 0.5) *\n        (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\n// Default cache provider\nvar _a = initCache(new Map()), cache = _a[0], mutate = _a[1];\n// Default config\nvar defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry: onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare: function (currentData, newData) {\n        return stableHash(currentData) == stableHash(newData);\n    },\n    isPaused: function () { return false; },\n    cache: cache,\n    mutate: mutate,\n    fallback: {}\n}, \n// use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n    // Need to create a new object to avoid mutating the original here.\n    var v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        var u1 = a.use, f1 = a.fallback;\n        var u2 = b.use, f2 = b.fallback;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar SWRConfig$1 = function (props) {\n    var value = props.value;\n    // Extend parent context values and middleware.\n    var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value);\n    // Should not use the inherited provider.\n    var provider = value && value.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n        return provider\n            ? initCache(provider(extendedConfig.cache || cache), value)\n            : UNDEFINED;\n    })[0];\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(function () { return (cacheContext ? cacheContext[2] : UNDEFINED); }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\n/**\n * An implementation of state with dependency-tracking.\n */\nvar useStateWithDeps = function (state, unmountedRef) {\n    var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n     * @param payload To change stateRef, pass the values explicitly to setState:\n     * @example\n     * ```js\n     * setState({\n     *   isValidating: false\n     *   data: newData // set data to newData\n     *   error: undefined // set error to undefined\n     * })\n     *\n     * setState({\n     *   isValidating: false\n     *   data: undefined // set data to undefined\n     *   error: err // set error to err\n     * })\n     * ```\n     */\n    var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n        var shouldRerender = false;\n        var currentState = stateRef.current;\n        for (var _ in payload) {\n            var k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, \n    // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update the state reference.\n    useIsomorphicLayoutEffect(function () {\n        stateRef.current = state;\n    });\n    return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n    return isFunction(args[1])\n        ? [args[0], args[1], args[2] || {}]\n        : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nvar withArgs = function (hook) {\n    return function useSWRArgs() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Get the default and inherited configuration.\n        var fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        var _a = normalize(args), key = _a[0], fn = _a[1], _config = _a[2];\n        // Merge configurations.\n        var config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        var next = hook;\n        var use = config.use;\n        if (use) {\n            for (var i = use.length; i-- > 0;) {\n                next = use[i](next);\n            }\n        }\n        return next(key, fn || config.fetcher, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nvar subscribeCallback = function (key, callbacks, callback) {\n    var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return function () {\n        var index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\nvar WITH_DEDUPE = { dedupe: true };\nvar useSWRHandler = function (_key, fetcher, config) {\n    var cache = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], MUTATION = _a[2], FETCH = _a[3];\n    // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n    // states such as `error` and `isValidating` inside,\n    // all of them are derived from `_key`.\n    // `fnArgs` is an array of arguments parsed from the key, which will be passed\n    // to the fetcher.\n    var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];\n    // If it's the initial render of this hook.\n    var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    var getConfig = function () { return configRef.current; };\n    var isActive = function () { return getConfig().isVisible() && getConfig().isOnline(); };\n    var patchFetchInfo = function (info) {\n        return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n    };\n    // Get the current state that SWR should return.\n    var cached = cache.get(key);\n    var fallback = isUndefined(fallbackData)\n        ? config.fallback[key]\n        : fallbackData;\n    var data = isUndefined(cached) ? fallback : cached;\n    var info = cache.get(keyInfo) || {};\n    var error = info.error;\n    var isInitialMount = !initialMountedRef.current;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    var shouldRevalidate = function () {\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !isUndefined(revalidateOnMount))\n            return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused())\n            return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately on mount again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense)\n            return isUndefined(data) ? false : config.revalidateIfStale;\n        // If there is no stale data, we need to revalidate on mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return isUndefined(data) || config.revalidateIfStale;\n    };\n    // Resolve the current validating state.\n    var resolveValidating = function () {\n        if (!key || !fetcher)\n            return false;\n        if (info.isValidating)\n            return true;\n        // If it's not mounted yet and it should revalidate on mount, revalidate.\n        return isInitialMount && shouldRevalidate();\n    };\n    var isValidating = resolveValidating();\n    var _c = useStateWithDeps({\n        data: data,\n        error: error,\n        isValidating: isValidating\n    }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) { return __awaiter(void 0, void 0, void 0, function () {\n        var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n        var _a;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    currentFetcher = fetcherRef.current;\n                    if (!key ||\n                        !currentFetcher ||\n                        unmountedRef.current ||\n                        getConfig().isPaused()) {\n                        return [2 /*return*/, false];\n                    }\n                    loading = true;\n                    opts = revalidateOpts || {};\n                    shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n                    isCurrentKeyMounted = function () {\n                        return !unmountedRef.current &&\n                            key === keyRef.current &&\n                            initialMountedRef.current;\n                    };\n                    cleanupState = function () {\n                        // Check if it's still the same request before deleting.\n                        var requestInfo = FETCH[key];\n                        if (requestInfo && requestInfo[1] === startAt) {\n                            delete FETCH[key];\n                        }\n                    };\n                    newState = { isValidating: false };\n                    finishRequestAndUpdateState = function () {\n                        patchFetchInfo({ isValidating: false });\n                        // We can only set state if it's safe (still mounted with the same key).\n                        if (isCurrentKeyMounted()) {\n                            setState(newState);\n                        }\n                    };\n                    // Start fetching. Change the `isValidating` state, update the cache.\n                    patchFetchInfo({\n                        isValidating: true\n                    });\n                    setState({ isValidating: true });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    if (shouldStartNewRequest) {\n                        // Tell all other hooks to change the `isValidating` state.\n                        broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true);\n                        // If no cache being rendered currently (it shows a blank page),\n                        // we trigger the loading slow event.\n                        if (config.loadingTimeout && !cache.get(key)) {\n                            setTimeout(function () {\n                                if (loading && isCurrentKeyMounted()) {\n                                    getConfig().onLoadingSlow(key, config);\n                                }\n                            }, config.loadingTimeout);\n                        }\n                        // Start the request and save the timestamp.\n                        FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n                    }\n                    _a = FETCH[key], newData = _a[0], startAt = _a[1];\n                    return [4 /*yield*/, newData];\n                case 2:\n                    newData = _b.sent();\n                    if (shouldStartNewRequest) {\n                        // If the request isn't interrupted, clean it up after the\n                        // deduplication interval.\n                        setTimeout(cleanupState, config.dedupingInterval);\n                    }\n                    // If there're other ongoing request(s), started after the current one,\n                    // we need to ignore the current one to avoid possible race conditions:\n                    //   req1------------------>res1        (current one)\n                    //        req2---------------->res2\n                    // the request that fired later will always be kept.\n                    // The timestamp maybe be `undefined` or a number\n                    if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onDiscarded(key);\n                            }\n                        }\n                        return [2 /*return*/, false];\n                    }\n                    // Clear error.\n                    patchFetchInfo({\n                        error: UNDEFINED\n                    });\n                    newState.error = UNDEFINED;\n                    mutationInfo = MUTATION[key];\n                    if (!isUndefined(mutationInfo) &&\n                        // case 1\n                        (startAt <= mutationInfo[0] ||\n                            // case 2\n                            startAt <= mutationInfo[1] ||\n                            // case 3\n                            mutationInfo[1] === 0)) {\n                        finishRequestAndUpdateState();\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onDiscarded(key);\n                            }\n                        }\n                        return [2 /*return*/, false];\n                    }\n                    // Deep compare with latest state to avoid extra re-renders.\n                    // For local state, compare and assign.\n                    if (!compare(stateRef.current.data, newData)) {\n                        newState.data = newData;\n                    }\n                    else {\n                        // data and newData are deeply equal\n                        // it should be safe to broadcast the stale data\n                        newState.data = stateRef.current.data;\n                        // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n                        // which takes care of avoiding the re-render\n                    }\n                    // For global state, it's possible that the key has changed.\n                    // https://github.com/vercel/swr/pull/1058\n                    if (!compare(cache.get(key), newData)) {\n                        cache.set(key, newData);\n                    }\n                    // Trigger the successful callback if it's the original request.\n                    if (shouldStartNewRequest) {\n                        if (isCurrentKeyMounted()) {\n                            getConfig().onSuccess(newData, key, config);\n                        }\n                    }\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _b.sent();\n                    cleanupState();\n                    // Not paused, we continue handling the error. Otherwise discard it.\n                    if (!getConfig().isPaused()) {\n                        // Get a new error, don't use deep comparison for errors.\n                        patchFetchInfo({ error: err_1 });\n                        newState.error = err_1;\n                        // Error event and retry logic. Only for the actual request, not\n                        // deduped ones.\n                        if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                            getConfig().onError(err_1, key, config);\n                            if ((typeof config.shouldRetryOnError === 'boolean' &&\n                                config.shouldRetryOnError) ||\n                                (isFunction(config.shouldRetryOnError) &&\n                                    config.shouldRetryOnError(err_1))) {\n                                // When retrying, dedupe is always enabled\n                                if (isActive()) {\n                                    // If it's active, stop. It will auto revalidate when refocusing\n                                    // or reconnecting.\n                                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                                        retryCount: (opts.retryCount || 0) + 1,\n                                        dedupe: true\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [3 /*break*/, 4];\n                case 4:\n                    // Mark loading as stopped.\n                    loading = false;\n                    // Update the current hook's state.\n                    finishRequestAndUpdateState();\n                    // Here is the source of the request, need to tell all other hooks to\n                    // update their states.\n                    if (isCurrentKeyMounted() && shouldStartNewRequest) {\n                        broadcastState(cache, key, newState.data, newState.error, false);\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    }); }, \n    // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n    // and `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [key]);\n    // Similar to the global mutate, but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // By using `bind` we don't need to modify the size of the rest arguments.\n    // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n    // cast it to any for now.\n    internalMutate.bind(UNDEFINED, cache, function () { return keyRef.current; }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update fetcher and config refs.\n    useIsomorphicLayoutEffect(function () {\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n    });\n    // After mounted or key changed.\n    useIsomorphicLayoutEffect(function () {\n        if (!key)\n            return;\n        var keyChanged = key !== keyRef.current;\n        var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);\n        // Expose state updater to global event listeners. So we can update hook's\n        // internal state from the outside.\n        var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n            setState(mergeObjects({\n                error: updatedError,\n                isValidating: updatedIsValidating\n            }, \n            // Since `setState` only shallowly compares states, we do a deep\n            // comparison here.\n            compare(stateRef.current.data, updatedData)\n                ? UNDEFINED\n                : {\n                    data: updatedData\n                }));\n        };\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        var nextFocusRevalidatedAt = 0;\n        var onRevalidate = function (type) {\n            if (type == FOCUS_EVENT) {\n                var now = Date.now();\n                if (getConfig().revalidateOnFocus &&\n                    now > nextFocusRevalidatedAt &&\n                    isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            }\n            else if (type == RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            }\n            else if (type == MUTATE_EVENT) {\n                return revalidate();\n            }\n            return;\n        };\n        var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n        var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // When `key` updates, reset the state to the initial value\n        // and trigger a rerender if necessary.\n        if (keyChanged) {\n            setState({\n                data: data,\n                error: error,\n                isValidating: isValidating\n            });\n        }\n        // Trigger a revalidation.\n        if (shouldRevalidate()) {\n            if (isUndefined(data) || IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            }\n            else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                rAF(softRevalidate);\n            }\n        }\n        return function () {\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubUpdate();\n            unsubEvents();\n        };\n    }, [key, revalidate]);\n    // Polling\n    useIsomorphicLayoutEffect(function () {\n        var timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            var interval = isFunction(refreshInterval)\n                ? refreshInterval(data)\n                : refreshInterval;\n            // We only start next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online and not errored.\n            if (!stateRef.current.error &&\n                (refreshWhenHidden || getConfig().isVisible()) &&\n                (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            }\n            else {\n                // Schedule next interval to check again.\n                next();\n            }\n        }\n        next();\n        return function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && isUndefined(data) && key) {\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n    }\n    return {\n        mutate: boundMutate,\n        get data() {\n            stateDependencies.data = true;\n            return data;\n        },\n        get error() {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating() {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        }\n    };\n};\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n    value: defaultConfig\n});\nvar unstable_serialize = function (key) { return serialize(key)[0]; };\nvar useSWR = withArgs(useSWRHandler);\n\n// useSWR\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9xdWVyeS9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEySTs7QUFFM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0Q0FBUyxHQUFHLGtEQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsY0FBYztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFhLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNEQUFzRDtBQUNsRyxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFRLEdBQUc7QUFDOUIsbUJBQW1CLDZDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBLHVDQUF1QyxpREFBVTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQU07QUFDbEM7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBTTtBQUM3QjtBQUNBLGlCQUFpQiw2Q0FBTTtBQUN2QixxQkFBcUIsNkNBQU07QUFDM0Isb0JBQW9CLDZDQUFNO0FBQzFCLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQVcsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdCQUF3QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLG9EQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFa0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcQHBsYXNtaWNhcHBcXHF1ZXJ5XFxub2RlX21vZHVsZXNcXHN3clxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLy8gVXNpbmcgbm9vcCgpIGFzIHRoZSB1bmRlZmluZWQgdmFsdWUgYXMgdW5kZWZpbmVkIGNhbiBwb3NzaWJseSBiZSByZXBsYWNlZFxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xudmFyIE9CSkVDVCA9IE9iamVjdDtcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBVTkRFRklORUQ7IH07XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xudmFyIG1lcmdlT2JqZWN0cyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBPQkpFQ1QuYXNzaWduKHt9LCBhLCBiKTsgfTtcbnZhciBTVFJfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG52YXIgaGFzV2luZG93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc0RvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7IH07XG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3coKSAmJiB0eXBlb2Ygd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSAhPSBTVFJfVU5ERUZJTkVEO1xufTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbnZhciB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbnZhciBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNpYmxlLlxudmFyIHN0YWJsZUhhc2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgdmFyIGlzRGF0ZSA9IGNvbnN0cnVjdG9yID09IERhdGU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiBjb25zdHJ1Y3RvciAhPSBSZWdFeHApIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBPQkpFQ1QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxuICAgICAgICAgICAgPyBhcmcudG9KU09OKClcbiAgICAgICAgICAgIDogdHlwZSA9PSAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IHR5cGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxuICogaXQncyBub3QgcmVsaWFibGUgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb2ZmbGluZVxuICogYmFzZWQgb24gYG5hdmlnYXRvci5vbkxpbmVgLlxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXG4gKiB0aGUgc3RhdHVzIHVwb24gYG9ubGluZWAgb3IgYG9mZmxpbmVgIGV2ZW50cy5cbiAqL1xudmFyIG9ubGluZSA9IHRydWU7XG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmxpbmU7IH07XG52YXIgaGFzV2luID0gaGFzV2luZG93KCk7XG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcbi8vIEZvciBub2RlIGFuZCBSZWFjdCBOYXRpdmUsIGBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZG9lc24ndCBleGlzdCBvbiB3aW5kb3cuXG52YXIgb25XaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9uRG9jdW1lbnRFdmVudCA9IGhhc0RvYyA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudCkgOiBub29wO1xudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbiAgICA6IG5vb3A7XG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xuICAgID8gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGRvY3VtZW50KVxuICAgIDogbm9vcDtcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc2liaWxpdHlTdGF0ZSA9IGhhc0RvYyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2liaWxpdHlTdGF0ZSkgfHwgdmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbn07XG52YXIgaW5pdEZvY3VzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZm9jdXMgcmV2YWxpZGF0ZVxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBvbldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG52YXIgaW5pdFJlY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHJldmFsaWRhdGUgb24gcmVjb25uZWN0ZWRcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvLyBub3RoaW5nIHRvIHJldmFsaWRhdGUsIGp1c3QgdXBkYXRlIHRoZSBzdGF0dXNcbiAgICB2YXIgb25PZmZsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIG9uV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgfTtcbn07XG52YXIgcHJlc2V0ID0ge1xuICAgIGlzT25saW5lOiBpc09ubGluZSxcbiAgICBpc1Zpc2libGU6IGlzVmlzaWJsZVxufTtcbnZhciBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXM6IGluaXRGb2N1cyxcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XG59O1xuXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbnZhciByQUYgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xufTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbnZhciBuYXZpZ2F0b3JDb25uZWN0aW9uID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG52YXIgc2xvd0Nvbm5lY3Rpb24gPSAhSVNfU0VSVkVSICYmXG4gICAgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJlxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XG4gICAgICAgIG5hdmlnYXRvckNvbm5lY3Rpb24uc2F2ZURhdGEpO1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdzID0gW10uY29uY2F0KGtleSk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9XG4gICAgICAgIHR5cGVvZiBrZXkgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxuICAgICAgICAgICAgICAgID8gc3RhYmxlSGFzaChrZXkpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcbiAgICByZXR1cm4gW2tleSwgYXJncywgaW5mb0tleV07XG59O1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG52YXIgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgRk9DVVNfRVZFTlQgPSAwO1xudmFyIFJFQ09OTkVDVF9FVkVOVCA9IDE7XG52YXIgTVVUQVRFX0VWRU5UID0gMjtcblxudmFyIGJyb2FkY2FzdFN0YXRlID0gZnVuY3Rpb24gKGNhY2hlLCBrZXksIGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcsIHJldmFsaWRhdGUsIGJyb2FkY2FzdCkge1xuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIEZFVENIID0gX2FbM107XG4gICAgdmFyIHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XG4gICAgLy8gQ2FjaGUgd2FzIHBvcHVsYXRlZCwgdXBkYXRlIHN0YXRlcyBvZiBhbGwgaG9va3MuXG4gICAgaWYgKGJyb2FkY2FzdCAmJiB1cGRhdGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB1cGRhdGVyc1tpXShkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBhbHNvIG5lZWQgdG8gcmV2YWxpZGF0ZSwgb25seSBkbyBpdCBmb3IgdGhlIGZpcnN0IGhvb2suXG4gICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcbiAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0b3JzWzBdKE1VVEFURV9FVkVOVCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbnZhciBfX3RpbWVzdGFtcCA9IDA7XG52YXIgZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKytfX3RpbWVzdGFtcDsgfTtcblxudmFyIGludGVybmFsTXV0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBfa2V5LCBfZGF0YSwgX29wdHMsIG9wdGlvbnMsIHBvcHVsYXRlQ2FjaGUsIHJldmFsaWRhdGUsIHJvbGxiYWNrT25FcnJvciwgY3VzdG9tT3B0aW1pc3RpY0RhdGEsIF9hLCBrZXksIGtleUluZm8sIF9iLCBNVVRBVElPTiwgZGF0YSwgZXJyb3IsIGJlZm9yZU11dGF0aW9uVHMsIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhLCByb2xsYmFja0RhdGEsIG9wdGltaXN0aWNEYXRhLCByZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gYXJnc1swXSwgX2tleSA9IGFyZ3NbMV0sIF9kYXRhID0gYXJnc1syXSwgX29wdHMgPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IGlzVW5kZWZpbmVkKG9wdGlvbnMucG9wdWxhdGVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByb2xsYmFja09uRXJyb3IgPSBvcHRpb25zLnJvbGxiYWNrT25FcnJvciAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9hWzBdLCBrZXlJbmZvID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICBfYiA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIE1VVEFUSU9OID0gX2JbMl07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5ldyBkYXRhIHByb3ZpZGVkLCByZXZhbGlkYXRlIHRoZSBrZXkgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGFuZCBicm9hZGNhc3Qgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgY2FjaGUuZ2V0KGtleSksIFVOREVGSU5FRCwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9kYXRhO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVNdXRhdGlvblRzID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XG4gICAgICAgICAgICAgICAgICAgIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhID0gIWlzVW5kZWZpbmVkKGN1c3RvbU9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tEYXRhID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21PcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKGN1c3RvbU9wdGltaXN0aWNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VzdG9tT3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEoY2FjaGUuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHRocm93cyBhbiBlcnJvciBzeW5jaHJvbm91c2x5LCB3ZSBzaG91bGRuJ3QgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkYXRhLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSAmJiByb2xsYmFja09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgd3JpdGUgYmFjayB0aGUgY2FjaGUgYWZ0ZXIgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3VsdCBpbnRvIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIHsgZXJyb3I6IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCAhIXBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvcHVsYXRlQ2FjaGUgPyByZXMgOiBkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgcmV2YWxpZGF0ZUFsbEtleXMgPSBmdW5jdGlvbiAocmV2YWxpZGF0b3JzLCB0eXBlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHJldmFsaWRhdG9ycykge1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XVswXSh0eXBlKTtcbiAgICB9XG59O1xudmFyIGluaXRDYWNoZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBnbG9iYWwgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgd2lsbCBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXG4gICAgLy8gdGhlIGNhY2hlLlxuICAgIC8vIFByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWdPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBtdXRhdGUgZnVuY3Rpb24uXG4gICAgICAgIHZhciBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XG4gICAgICAgIHZhciB1bm1vdW50ID0gbm9vcDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHByb3ZpZGVyLCB3ZSBuZWVkIHRvIGluaXRpYWxpemUgaXQgYW5kIHNldHVwIERPTSBldmVudHNcbiAgICAgICAgLy8gbGlzdGVuZXJzIGZvciBgZm9jdXNgIGFuZCBgcmVjb25uZWN0YCBhY3Rpb25zLlxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgLy8gV2hlbiBsaXN0ZW5pbmcgdG8gdGhlIG5hdGl2ZSBldmVudHMgZm9yIGF1dG8gcmV2YWxpZGF0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcbiAgICAgICAgICAgIC8vIFJlYWN0J3Mgc3RhdGUgdXBkYXRlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgIHZhciByZWxlYXNlRm9jdXNfMSA9IG9wdHMuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIEZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgdmFyIHJlbGVhc2VSZWNvbm5lY3RfMSA9IG9wdHMuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBSRUNPTk5FQ1RfRVZFTlQpKSk7XG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1c18xICYmIHJlbGVhc2VGb2N1c18xKCk7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVJlY29ubmVjdF8xICYmIHJlbGVhc2VSZWNvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgdG9vIGJlY2F1c2UgaXQncyBhIHNpZGUtZWZmZWN0LiBPdGhlcndpc2Ugd2hlbiByZS1tb3VudGluZyB3ZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IHJlLXJlZ2lzdGVyIHRob3NlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAvLyBzdWNoIGFzIGtleSBzZXJpYWxpemF0aW9uLCBhdXRvIEdDLCBldGMuXG4gICAgICAgIC8vIEZvciBub3csIGl0J3MganVzdCBhIGBNYXBgIGludGVyZmFjZSB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3ZpZGVyLCBTV1JHbG9iYWxTdGF0ZS5nZXQocHJvdmlkZXIpWzRdXTtcbn07XG5cbi8vIGVycm9yIHJldHJ5XG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcbiAgICB2YXIgbWF4UmV0cnlDb3VudCA9IGNvbmZpZy5lcnJvclJldHJ5Q291bnQ7XG4gICAgdmFyIGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICB2YXIgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqXG4gICAgICAgICgxIDw8IChjdXJyZW50UmV0cnlDb3VudCA8IDggPyBjdXJyZW50UmV0cnlDb3VudCA6IDgpKSkgKiBjb25maWcuZXJyb3JSZXRyeUludGVydmFsO1xuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn07XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XG4vLyBEZWZhdWx0IGNvbmZpZ1xudmFyIGRlZmF1bHRDb25maWcgPSBtZXJnZU9iamVjdHMoe1xuICAgIC8vIGV2ZW50c1xuICAgIG9uTG9hZGluZ1Nsb3c6IG5vb3AsXG4gICAgb25TdWNjZXNzOiBub29wLFxuICAgIG9uRXJyb3I6IG5vb3AsXG4gICAgb25FcnJvclJldHJ5OiBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcbiAgICB9LFxuICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICBjYWNoZTogY2FjaGUsXG4gICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCBcbi8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbnZhciBtZXJnZUNvbmZpZ3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcbiAgICAgICAgdmFyIHUyID0gYi51c2UsIGYyID0gYi5mYWxsYmFjaztcbiAgICAgICAgaWYgKHUxICYmIHUyKSB7XG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYxICYmIGYyKSB7XG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIFNXUkNvbmZpZyQxID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cbiAgICB2YXIgZXh0ZW5kZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSwgdmFsdWUpO1xuICAgIC8vIFNob3VsZCBub3QgdXNlIHRoZSBpbmhlcml0ZWQgcHJvdmlkZXIuXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XG4gICAgLy8gVXNlIGEgbGF6eSBpbml0aWFsaXplZCBzdGF0ZSB0byBjcmVhdGUgdGhlIGNhY2hlIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICB2YXIgY2FjaGVDb250ZXh0ID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgID8gaW5pdENhY2hlKHByb3ZpZGVyKGV4dGVuZGVkQ29uZmlnLmNhY2hlIHx8IGNhY2hlKSwgdmFsdWUpXG4gICAgICAgICAgICA6IFVOREVGSU5FRDtcbiAgICB9KVswXTtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGUgaWYgYSBuZXcgcHJvdmlkZXIgaXMgZ2l2ZW4uXG4gICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcubXV0YXRlID0gY2FjaGVDb250ZXh0WzFdO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiAoY2FjaGVDb250ZXh0ID8gY2FjaGVDb250ZXh0WzJdIDogVU5ERUZJTkVEKTsgfSwgW10pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIG1lcmdlT2JqZWN0cyhwcm9wcywge1xuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcbiAgICB9KSk7XG59O1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHN0YXRlIHdpdGggZGVwZW5kZW5jeS10cmFja2luZy5cbiAqL1xudmFyIHVzZVN0YXRlV2l0aERlcHMgPSBmdW5jdGlvbiAoc3RhdGUsIHVubW91bnRlZFJlZikge1xuICAgIHZhciByZXJlbmRlciA9IHVzZVN0YXRlKHt9KVsxXTtcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIC8vIElmIGEgc3RhdGUgcHJvcGVydHkgKGRhdGEsIGVycm9yIG9yIGlzVmFsaWRhdGluZykgaXMgYWNjZXNzZWQgYnkgdGhlIHJlbmRlclxuICAgIC8vIGZ1bmN0aW9uLCB3ZSBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBhIGRlcGVuZGVuY3kgc28gaWYgaXQgaXMgdXBkYXRlZCBhZ2FpblxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGFsc28ga25vd24gYXMgZGVwZW5kZW5jeS10cmFja2luZy5cbiAgICB2YXIgc3RhdGVEZXBlbmRlbmNpZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBheWxvYWQgVG8gY2hhbmdlIHN0YXRlUmVmLCBwYXNzIHRoZSB2YWx1ZXMgZXhwbGljaXRseSB0byBzZXRTdGF0ZTpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogbmV3RGF0YSAvLyBzZXQgZGF0YSB0byBuZXdEYXRhXG4gICAgICogICBlcnJvcjogdW5kZWZpbmVkIC8vIHNldCBlcnJvciB0byB1bmRlZmluZWRcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogdW5kZWZpbmVkIC8vIHNldCBkYXRhIHRvIHVuZGVmaW5lZFxuICAgICAqICAgZXJyb3I6IGVyciAvLyBzZXQgZXJyb3IgdG8gZXJyXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGsgPSBfO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBtYXJrIHJlcmVuZGVyIGFzXG4gICAgICAgICAgICAvLyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnRba10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVyZW5kZXIgJiYgIXVubW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBjb25maWcuc3VzcGVuc2UgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHN0YXRlIHJlZmVyZW5jZS5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pXG4gICAgICAgID8gW2FyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0gfHwge31dXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcbn07XG5cbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgdmFyIGZhbGxiYWNrQ29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcbiAgICAgICAgLy8gTWVyZ2UgY29uZmlndXJhdGlvbnMuXG4gICAgICAgIHZhciBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIHZhciBuZXh0ID0gaG9vaztcbiAgICAgICAgdmFyIHVzZSA9IGNvbmZpZy51c2U7XG4gICAgICAgIGlmICh1c2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB1c2UubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB1c2VbaV0obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG52YXIgc3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xuICAgIGtleWVkUmV2YWxpZGF0b3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XG52YXIgdXNlU1dSSGFuZGxlciA9IGZ1bmN0aW9uIChfa2V5LCBmZXRjaGVyLCBjb25maWcpIHtcbiAgICB2YXIgY2FjaGUgPSBjb25maWcuY2FjaGUsIGNvbXBhcmUgPSBjb25maWcuY29tcGFyZSwgZmFsbGJhY2tEYXRhID0gY29uZmlnLmZhbGxiYWNrRGF0YSwgc3VzcGVuc2UgPSBjb25maWcuc3VzcGVuc2UsIHJldmFsaWRhdGVPbk1vdW50ID0gY29uZmlnLnJldmFsaWRhdGVPbk1vdW50LCByZWZyZXNoSW50ZXJ2YWwgPSBjb25maWcucmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiA9IGNvbmZpZy5yZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lID0gY29uZmlnLnJlZnJlc2hXaGVuT2ZmbGluZTtcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGBkYXRhYCBzdGF0ZSwgYGtleUluZm9gIGhvbGRzIGV4dHJhXG4gICAgLy8gc3RhdGVzIHN1Y2ggYXMgYGVycm9yYCBhbmQgYGlzVmFsaWRhdGluZ2AgaW5zaWRlLFxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIC8vIGBmbkFyZ3NgIGlzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XG4gICAgLy8gSWYgaXQncyB0aGUgaW5pdGlhbCByZW5kZXIgb2YgdGhpcyBob29rLlxuICAgIHZhciBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgdmFyIHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICB2YXIga2V5UmVmID0gdXNlUmVmKGtleSk7XG4gICAgdmFyIGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIHZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpOyB9O1xuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgaW5mbykpO1xuICAgIH07XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgIHZhciBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSlcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxuICAgICAgICA6IGZhbGxiYWNrRGF0YTtcbiAgICB2YXIgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZCkgPyBmYWxsYmFjayA6IGNhY2hlZDtcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcbiAgICB2YXIgZXJyb3IgPSBpbmZvLmVycm9yO1xuICAgIHZhciBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50ICYmICFpc1VuZGVmaW5lZChyZXZhbGlkYXRlT25Nb3VudCkpXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBvbiBtb3VudCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSlcbiAgICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSA/IGZhbHNlIDogY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCBjb25maWcucmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgfTtcbiAgICAvLyBSZXNvbHZlIHRoZSBjdXJyZW50IHZhbGlkYXRpbmcgc3RhdGUuXG4gICAgdmFyIHJlc29sdmVWYWxpZGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IG1vdW50ZWQgeWV0IGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSBvbiBtb3VudCwgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzSW5pdGlhbE1vdW50ICYmIHNob3VsZFJldmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkYXRpbmcgPSByZXNvbHZlVmFsaWRhdGluZygpO1xuICAgIHZhciBfYyA9IHVzZVN0YXRlV2l0aERlcHMoe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGZXRjaGVyLCBuZXdEYXRhLCBzdGFydEF0LCBsb2FkaW5nLCBvcHRzLCBzaG91bGRTdGFydE5ld1JlcXVlc3QsIGlzQ3VycmVudEtleU1vdW50ZWQsIGNsZWFudXBTdGF0ZSwgbmV3U3RhdGUsIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSwgbXV0YXRpb25JbmZvLCBlcnJfMTtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50RmV0Y2hlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRLZXlNb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgaXNWYWxpZGF0aW5nOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBzZXQgc3RhdGUgaWYgaXQncyBzYWZlIChzdGlsbCBtb3VudGVkIHdpdGggdGhlIHNhbWUga2V5KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHsgaXNWYWxpZGF0aW5nOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgc3RhdGVSZWYuY3VycmVudC5kYXRhLCBzdGF0ZVJlZi5jdXJyZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgIWNhY2hlLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EgPSBGRVRDSFtrZXldLCBuZXdEYXRhID0gX2FbMF0sIHN0YXJ0QXQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGxpY2F0aW9uIGludGVydmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBvbmdvaW5nIHJlcXVlc3QocyksIHN0YXJ0ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgcmVxMi0tLS0tLS0tLS0tLS0tLS0+cmVzMlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGRVRDSFtrZXldIHx8IEZFVENIW2tleV1bMV0gIT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbG9jYWwgc3RhdGUsIGNvbXBhcmUgYW5kIGFzc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBhbmQgbmV3RGF0YSBhcmUgZGVlcGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgc2FmZSB0byBicm9hZGNhc3QgdGhlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb24sIGBicm9jYXN0U3RhdGVgIGludm9rZXMgdGhlIGBvblN0YXRlVXBkYXRlYCBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRha2VzIGNhcmUgb2YgYXZvaWRpbmcgdGhlIHJlLXJlbmRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBnbG9iYWwgc3RhdGUsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzEwNThcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHBhdXNlZCwgd2UgY29udGludWUgaGFuZGxpbmcgdGhlIGVycm9yLiBPdGhlcndpc2UgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHsgZXJyb3I6IGVycl8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBlcnJfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZHVwZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcihlcnJfMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmV0cnlpbmcsIGRlZHVwZSBpcyBhbHdheXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0byByZXZhbGlkYXRlIHdoZW4gcmVmb2N1c2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVjb25uZWN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IChvcHRzLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVwZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGxvYWRpbmcgYXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBpcyB0aGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LCBuZWVkIHRvIHRlbGwgYWxsIG90aGVyIGhvb2tzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkgJiYgc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBuZXdTdGF0ZS5kYXRhLCBuZXdTdGF0ZS5lcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0sIFxuICAgIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnc2AsIGBrZXlJbmZvYCxcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2tleV0pO1xuICAgIC8vIFNpbWlsYXIgdG8gdGhlIGdsb2JhbCBtdXRhdGUsIGJ1dCBib3VuZCB0byB0aGUgY3VycmVudCBjYWNoZSBhbmQga2V5LlxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHZhciBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcxODEsIHdlIGhhdmUgdG9cbiAgICAvLyBjYXN0IGl0IHRvIGFueSBmb3Igbm93LlxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHN0YXRlIHVwZGF0ZXIgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHVwZGF0ZSBob29rJ3NcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgdmFyIG9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlZERhdGEsIHVwZGF0ZWRFcnJvciwgdXBkYXRlZElzVmFsaWRhdGluZykge1xuICAgICAgICAgICAgc2V0U3RhdGUobWVyZ2VPYmplY3RzKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdXBkYXRlZElzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXG4gICAgICAgICAgICAvLyBjb21wYXJpc29uIGhlcmUuXG4gICAgICAgICAgICBjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgdXBkYXRlZERhdGEpXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgdmFyIG9uUmV2YWxpZGF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25Gb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IG5vdyArIGdldENvbmZpZygpLmZvY3VzVGhyb3R0bGVJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuc3ViVXBkYXRlID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBTVEFURV9VUERBVEVSUywgb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIHZhciB1bnN1YkV2ZW50cyA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgRVZFTlRfUkVWQUxJREFUT1JTLCBvblJldmFsaWRhdGUpO1xuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyBXaGVuIGBrZXlgIHVwZGF0ZXMsIHJlc2V0IHRoZSBzdGF0ZSB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAvLyBhbmQgdHJpZ2dlciBhIHJlcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUoKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTWFyayBpdCBhcyB1bm1vdW50ZWQuXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB1bnN1YlVwZGF0ZSgpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBba2V5LCByZXZhbGlkYXRlXSk7XG4gICAgLy8gUG9sbGluZ1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gaXNGdW5jdGlvbihyZWZyZXNoSW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcbiAgICAgICAgICAgICAgICA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lIGFuZCBub3QgZXJyb3JlZC5cbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxuICAgICAgICAgICAgICAgIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbcmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lLCByZXZhbGlkYXRlXSk7XG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxuICAgIHVzZURlYnVnVmFsdWUoZGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzIGV2ZW4gd2l0aCB0aGUgU3VzcGVuc2UgbW9kZS5cbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHRocm93IGlzVW5kZWZpbmVkKGVycm9yKSA/IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpIDogZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNWYWxpZGF0aW5nKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbnZhciBTV1JDb25maWcgPSBPQkpFQ1QuZGVmaW5lUHJvcGVydHkoU1dSQ29uZmlnJDEsICdkZWZhdWx0Jywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbnZhciB1bnN0YWJsZV9zZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXJpYWxpemUoa2V5KVswXTsgfTtcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuLy8gdXNlU1dSXG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIG11dGF0ZSwgdW5zdGFibGVfc2VyaWFsaXplLCB1c2VTV1JDb25maWcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@plasmicapp/query/node_modules/swr/dist/index.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/json-logic-js/logic.js":
/*!*********************************************!*\
  !*** ./node_modules/json-logic-js/logic.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* globals define,module */\n/*\nUsing a Universal Module Loader that should be browser, require, and AMD friendly\nhttp://ricostacruz.com/cheatsheets/umdjs.html\n*/\n;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function() {\n  \"use strict\";\n  /* globals console:false */\n\n  if ( ! Array.isArray) {\n    Array.isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === \"[object Array]\";\n    };\n  }\n\n  /**\n   * Return an array that contains no duplicates (original not modified)\n   * @param  {array} array   Original reference array\n   * @return {array}         New array with no duplicates\n   */\n  function arrayUnique(array) {\n    var a = [];\n    for (var i=0, l=array.length; i<l; i++) {\n      if (a.indexOf(array[i]) === -1) {\n        a.push(array[i]);\n      }\n    }\n    return a;\n  }\n\n  var jsonLogic = {};\n  var operations = {\n    \"==\": function(a, b) {\n      return a == b;\n    },\n    \"===\": function(a, b) {\n      return a === b;\n    },\n    \"!=\": function(a, b) {\n      return a != b;\n    },\n    \"!==\": function(a, b) {\n      return a !== b;\n    },\n    \">\": function(a, b) {\n      return a > b;\n    },\n    \">=\": function(a, b) {\n      return a >= b;\n    },\n    \"<\": function(a, b, c) {\n      return (c === undefined) ? a < b : (a < b) && (b < c);\n    },\n    \"<=\": function(a, b, c) {\n      return (c === undefined) ? a <= b : (a <= b) && (b <= c);\n    },\n    \"!!\": function(a) {\n      return jsonLogic.truthy(a);\n    },\n    \"!\": function(a) {\n      return !jsonLogic.truthy(a);\n    },\n    \"%\": function(a, b) {\n      return a % b;\n    },\n    \"log\": function(a) {\n      console.log(a); return a;\n    },\n    \"in\": function(a, b) {\n      if (!b || typeof b.indexOf === \"undefined\") return false;\n      return (b.indexOf(a) !== -1);\n    },\n    \"cat\": function() {\n      return Array.prototype.join.call(arguments, \"\");\n    },\n    \"substr\": function(source, start, end) {\n      if (end < 0) {\n        // JavaScript doesn't support negative end, this emulates PHP behavior\n        var temp = String(source).substr(start);\n        return temp.substr(0, temp.length + end);\n      }\n      return String(source).substr(start, end);\n    },\n    \"+\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return parseFloat(a, 10) + parseFloat(b, 10);\n      }, 0);\n    },\n    \"*\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return parseFloat(a, 10) * parseFloat(b, 10);\n      });\n    },\n    \"-\": function(a, b) {\n      if (b === undefined) {\n        return -a;\n      } else {\n        return a - b;\n      }\n    },\n    \"/\": function(a, b) {\n      return a / b;\n    },\n    \"min\": function() {\n      return Math.min.apply(this, arguments);\n    },\n    \"max\": function() {\n      return Math.max.apply(this, arguments);\n    },\n    \"merge\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return a.concat(b);\n      }, []);\n    },\n    \"var\": function(a, b) {\n      var not_found = (b === undefined) ? null : b;\n      var data = this;\n      if (typeof a === \"undefined\" || a===\"\" || a===null) {\n        return data;\n      }\n      var sub_props = String(a).split(\".\");\n      for (var i = 0; i < sub_props.length; i++) {\n        if (data === null || data === undefined) {\n          return not_found;\n        }\n        // Descending into data\n        data = data[sub_props[i]];\n        if (data === undefined) {\n          return not_found;\n        }\n      }\n      return data;\n    },\n    \"missing\": function() {\n      /*\n      Missing can receive many keys as many arguments, like {\"missing:[1,2]}\n      Missing can also receive *one* argument that is an array of keys,\n      which typically happens if it's actually acting on the output of another command\n      (like 'if' or 'merge')\n      */\n\n      var missing = [];\n      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = jsonLogic.apply({\"var\": key}, this);\n        if (value === null || value === \"\") {\n          missing.push(key);\n        }\n      }\n\n      return missing;\n    },\n    \"missing_some\": function(need_count, options) {\n      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.\n      var are_missing = jsonLogic.apply({\"missing\": options}, this);\n\n      if (options.length - are_missing.length >= need_count) {\n        return [];\n      } else {\n        return are_missing;\n      }\n    },\n  };\n\n  jsonLogic.is_logic = function(logic) {\n    return (\n      typeof logic === \"object\" && // An object\n      logic !== null && // but not null\n      ! Array.isArray(logic) && // and not an array\n      Object.keys(logic).length === 1 // with exactly one key\n    );\n  };\n\n  /*\n  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.\n\n  Spec and rationale here: http://jsonlogic.com/truthy\n  */\n  jsonLogic.truthy = function(value) {\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n    return !! value;\n  };\n\n\n  jsonLogic.get_operator = function(logic) {\n    return Object.keys(logic)[0];\n  };\n\n  jsonLogic.get_values = function(logic) {\n    return logic[jsonLogic.get_operator(logic)];\n  };\n\n  jsonLogic.apply = function(logic, data) {\n    // Does this array contain logic? Only one way to find out.\n    if (Array.isArray(logic)) {\n      return logic.map(function(l) {\n        return jsonLogic.apply(l, data);\n      });\n    }\n    // You've recursed to a primitive, stop!\n    if ( ! jsonLogic.is_logic(logic) ) {\n      return logic;\n    }\n\n    var op = jsonLogic.get_operator(logic);\n    var values = logic[op];\n    var i;\n    var current;\n    var scopedLogic;\n    var scopedData;\n    var initial;\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if ( ! Array.isArray(values)) {\n      values = [values];\n    }\n\n    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.\n    if (op === \"if\" || op == \"?:\") {\n      /* 'if' should be called with a odd number of parameters, 3 or greater\n      This works on the pattern:\n      if( 0 ){ 1 }else{ 2 };\n      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };\n      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };\n\n      The implementation is:\n      For pairs of values (0,1 then 2,3 then 4,5 etc)\n      If the first evaluates truthy, evaluate and return the second\n      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)\n      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)\n      given 0 parameters, return NULL (not great practice, but there was no Else)\n      */\n      for (i = 0; i < values.length - 1; i += 2) {\n        if ( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {\n          return jsonLogic.apply(values[i+1], data);\n        }\n      }\n      if (values.length === i+1) {\n        return jsonLogic.apply(values[i], data);\n      }\n      return null;\n    } else if (op === \"and\") { // Return first falsy, or last\n      for (i=0; i < values.length; i+=1) {\n        current = jsonLogic.apply(values[i], data);\n        if ( ! jsonLogic.truthy(current)) {\n          return current;\n        }\n      }\n      return current; // Last\n    } else if (op === \"or\") {// Return first truthy, or last\n      for (i=0; i < values.length; i+=1) {\n        current = jsonLogic.apply(values[i], data);\n        if ( jsonLogic.truthy(current) ) {\n          return current;\n        }\n      }\n      return current; // Last\n    } else if (op === \"filter\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData)) {\n        return [];\n      }\n      // Return only the elements from the array in the first argument,\n      // that return truthy when passed to the logic in the second argument.\n      // For parity with JavaScript, reindex the returned array\n      return scopedData.filter(function(datum) {\n        return jsonLogic.truthy( jsonLogic.apply(scopedLogic, datum));\n      });\n    } else if (op === \"map\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData)) {\n        return [];\n      }\n\n      return scopedData.map(function(datum) {\n        return jsonLogic.apply(scopedLogic, datum);\n      });\n    } else if (op === \"reduce\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n      initial = typeof values[2] !== \"undefined\" ? jsonLogic.apply(values[2], data) : null;\n\n      if ( ! Array.isArray(scopedData)) {\n        return initial;\n      }\n\n      return scopedData.reduce(\n        function(accumulator, current) {\n          return jsonLogic.apply(\n            scopedLogic,\n            {current: current, accumulator: accumulator}\n          );\n        },\n        initial\n      );\n    } else if (op === \"all\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n      // All of an empty set is false. Note, some and none have correct fallback after the for loop\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return false;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( ! jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return false; // First falsy, short circuit\n        }\n      }\n      return true; // All were truthy\n    } else if (op === \"none\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return true;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return false; // First truthy, short circuit\n        }\n      }\n      return true; // None were truthy\n    } else if (op === \"some\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return false;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return true; // First truthy, short circuit\n        }\n      }\n      return false; // None were truthy\n    }\n\n    // Everyone else gets immediate depth-first recursion\n    values = values.map(function(val) {\n      return jsonLogic.apply(val, data);\n    });\n\n\n    // The operation is called with \"data\" bound to its \"this\" and \"values\" passed as arguments.\n    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n    if (operations.hasOwnProperty(op) && typeof operations[op] === \"function\") {\n      return operations[op].apply(data, values);\n    } else if (op.indexOf(\".\") > 0) { // Contains a dot, and not in the 0th position\n      var sub_ops = String(op).split(\".\");\n      var operation = operations;\n      for (i = 0; i < sub_ops.length; i++) {\n        if (!operation.hasOwnProperty(sub_ops[i])) {\n          throw new Error(\"Unrecognized operation \" + op +\n            \" (failed at \" + sub_ops.slice(0, i+1).join(\".\") + \")\");\n        }\n        // Descending into operations\n        operation = operation[sub_ops[i]];\n      }\n\n      return operation.apply(data, values);\n    }\n\n    throw new Error(\"Unrecognized operation \" + op );\n  };\n\n  jsonLogic.uses_data = function(logic) {\n    var collection = [];\n\n    if (jsonLogic.is_logic(logic)) {\n      var op = jsonLogic.get_operator(logic);\n      var values = logic[op];\n\n      if ( ! Array.isArray(values)) {\n        values = [values];\n      }\n\n      if (op === \"var\") {\n        // This doesn't cover the case where the arg to var is itself a rule.\n        collection.push(values[0]);\n      } else {\n        // Recursion!\n        values.forEach(function(val) {\n          collection.push.apply(collection, jsonLogic.uses_data(val) );\n        });\n      }\n    }\n\n    return arrayUnique(collection);\n  };\n\n  jsonLogic.add_operation = function(name, code) {\n    operations[name] = code;\n  };\n\n  jsonLogic.rm_operation = function(name) {\n    delete operations[name];\n  };\n\n  jsonLogic.rule_like = function(rule, pattern) {\n    // console.log(\"Is \". JSON.stringify(rule) . \" like \" . JSON.stringify(pattern) . \"?\");\n    if (pattern === rule) {\n      return true;\n    } // TODO : Deep object equivalency?\n    if (pattern === \"@\") {\n      return true;\n    } // Wildcard!\n    if (pattern === \"number\") {\n      return (typeof rule === \"number\");\n    }\n    if (pattern === \"string\") {\n      return (typeof rule === \"string\");\n    }\n    if (pattern === \"array\") {\n      // !logic test might be superfluous in JavaScript\n      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);\n    }\n\n    if (jsonLogic.is_logic(pattern)) {\n      if (jsonLogic.is_logic(rule)) {\n        var pattern_op = jsonLogic.get_operator(pattern);\n        var rule_op = jsonLogic.get_operator(rule);\n\n        if (pattern_op === \"@\" || pattern_op === rule_op) {\n          // echo \"\\nOperators match, go deeper\\n\";\n          return jsonLogic.rule_like(\n            jsonLogic.get_values(rule, false),\n            jsonLogic.get_values(pattern, false)\n          );\n        }\n      }\n      return false; // pattern is logic, rule isn't, can't be eq\n    }\n\n    if (Array.isArray(pattern)) {\n      if (Array.isArray(rule)) {\n        if (pattern.length !== rule.length) {\n          return false;\n        }\n        /*\n          Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)\n        */\n        for (var i = 0; i < pattern.length; i += 1) {\n          // If any fail, we fail\n          if ( ! jsonLogic.rule_like(rule[i], pattern[i])) {\n            return false;\n          }\n        }\n        return true; // If they *all* passed, we pass\n      } else {\n        return false; // Pattern is array, rule isn't\n      }\n    }\n\n    // Not logic, not array, not a === match for rule.\n    return false;\n  };\n\n  return jsonLogic;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc29uLWxvZ2ljLWpzL2xvZ2ljLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNuQixJQUFJLEtBQUssRUFJTjtBQUNILENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1COztBQUU1RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxhQUFhLG1CQUFtQjtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsTUFBTTtBQUN4QixlQUFlLEdBQUcsY0FBYyxHQUFHLE1BQU07QUFDekMsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsTUFBTTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQixnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsTUFBTSx1QkFBdUI7QUFDN0IsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0M7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXGpzb24tbG9naWMtanNcXGxvZ2ljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgZGVmaW5lLG1vZHVsZSAqL1xuLypcblVzaW5nIGEgVW5pdmVyc2FsIE1vZHVsZSBMb2FkZXIgdGhhdCBzaG91bGQgYmUgYnJvd3NlciwgcmVxdWlyZSwgYW5kIEFNRCBmcmllbmRseVxuaHR0cDovL3JpY29zdGFjcnV6LmNvbS9jaGVhdHNoZWV0cy91bWRqcy5odG1sXG4qL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuanNvbkxvZ2ljID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLyogZ2xvYmFscyBjb25zb2xlOmZhbHNlICovXG5cbiAgaWYgKCAhIEFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIG5vIGR1cGxpY2F0ZXMgKG9yaWdpbmFsIG5vdCBtb2RpZmllZClcbiAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5ICAgT3JpZ2luYWwgcmVmZXJlbmNlIGFycmF5XG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIE5ldyBhcnJheSB3aXRoIG5vIGR1cGxpY2F0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICBmb3IgKHZhciBpPTAsIGw9YXJyYXkubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgaWYgKGEuaW5kZXhPZihhcnJheVtpXSkgPT09IC0xKSB7XG4gICAgICAgIGEucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgdmFyIGpzb25Mb2dpYyA9IHt9O1xuICB2YXIgb3BlcmF0aW9ucyA9IHtcbiAgICBcIj09XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID09IGI7XG4gICAgfSxcbiAgICBcIj09PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9LFxuICAgIFwiIT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgIT0gYjtcbiAgICB9LFxuICAgIFwiIT09XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICE9PSBiO1xuICAgIH0sXG4gICAgXCI+XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID4gYjtcbiAgICB9LFxuICAgIFwiPj1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9LFxuICAgIFwiPFwiOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gKGMgPT09IHVuZGVmaW5lZCkgPyBhIDwgYiA6IChhIDwgYikgJiYgKGIgPCBjKTtcbiAgICB9LFxuICAgIFwiPD1cIjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjID09PSB1bmRlZmluZWQpID8gYSA8PSBiIDogKGEgPD0gYikgJiYgKGIgPD0gYyk7XG4gICAgfSxcbiAgICBcIiEhXCI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBqc29uTG9naWMudHJ1dGh5KGEpO1xuICAgIH0sXG4gICAgXCIhXCI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiAhanNvbkxvZ2ljLnRydXRoeShhKTtcbiAgICB9LFxuICAgIFwiJVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAlIGI7XG4gICAgfSxcbiAgICBcImxvZ1wiOiBmdW5jdGlvbihhKSB7XG4gICAgICBjb25zb2xlLmxvZyhhKTsgcmV0dXJuIGE7XG4gICAgfSxcbiAgICBcImluXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmICghYiB8fCB0eXBlb2YgYi5pbmRleE9mID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gKGIuaW5kZXhPZihhKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgXCJjYXRcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiXCIpO1xuICAgIH0sXG4gICAgXCJzdWJzdHJcIjogZnVuY3Rpb24oc291cmNlLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAvLyBKYXZhU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBuZWdhdGl2ZSBlbmQsIHRoaXMgZW11bGF0ZXMgUEhQIGJlaGF2aW9yXG4gICAgICAgIHZhciB0ZW1wID0gU3RyaW5nKHNvdXJjZSkuc3Vic3RyKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHRlbXAuc3Vic3RyKDAsIHRlbXAubGVuZ3RoICsgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKS5zdWJzdHIoc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICBcIitcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLCAxMCkgKyBwYXJzZUZsb2F0KGIsIDEwKTtcbiAgICAgIH0sIDApO1xuICAgIH0sXG4gICAgXCIqXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSwgMTApICogcGFyc2VGbG9hdChiLCAxMCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFwiLVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiL1wiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAvIGI7XG4gICAgfSxcbiAgICBcIm1pblwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgXCJtYXhcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFwibWVyZ2VcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9LCBbXSk7XG4gICAgfSxcbiAgICBcInZhclwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgbm90X2ZvdW5kID0gKGIgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYjtcbiAgICAgIHZhciBkYXRhID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBhPT09XCJcIiB8fCBhPT09bnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJfcHJvcHMgPSBTdHJpbmcoYSkuc3BsaXQoXCIuXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJfcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXNjZW5kaW5nIGludG8gZGF0YVxuICAgICAgICBkYXRhID0gZGF0YVtzdWJfcHJvcHNbaV1dO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBcIm1pc3NpbmdcIjogZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgTWlzc2luZyBjYW4gcmVjZWl2ZSBtYW55IGtleXMgYXMgbWFueSBhcmd1bWVudHMsIGxpa2Uge1wibWlzc2luZzpbMSwyXX1cbiAgICAgIE1pc3NpbmcgY2FuIGFsc28gcmVjZWl2ZSAqb25lKiBhcmd1bWVudCB0aGF0IGlzIGFuIGFycmF5IG9mIGtleXMsXG4gICAgICB3aGljaCB0eXBpY2FsbHkgaGFwcGVucyBpZiBpdCdzIGFjdHVhbGx5IGFjdGluZyBvbiB0aGUgb3V0cHV0IG9mIGFub3RoZXIgY29tbWFuZFxuICAgICAgKGxpa2UgJ2lmJyBvciAnbWVyZ2UnKVxuICAgICAgKi9cblxuICAgICAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGpzb25Mb2dpYy5hcHBseSh7XCJ2YXJcIjoga2V5fSwgdGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgIG1pc3NpbmcucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgIH0sXG4gICAgXCJtaXNzaW5nX3NvbWVcIjogZnVuY3Rpb24obmVlZF9jb3VudCwgb3B0aW9ucykge1xuICAgICAgLy8gbWlzc2luZ19zb21lIHRha2VzIHR3byBhcmd1bWVudHMsIGhvdyBtYW55IChtaW5pbXVtKSBpdGVtcyBtdXN0IGJlIHByZXNlbnQsIGFuZCBhbiBhcnJheSBvZiBrZXlzIChqdXN0IGxpa2UgJ21pc3NpbmcnKSB0byBjaGVjayBmb3IgcHJlc2VuY2UuXG4gICAgICB2YXIgYXJlX21pc3NpbmcgPSBqc29uTG9naWMuYXBwbHkoe1wibWlzc2luZ1wiOiBvcHRpb25zfSwgdGhpcyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAtIGFyZV9taXNzaW5nLmxlbmd0aCA+PSBuZWVkX2NvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmVfbWlzc2luZztcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIGpzb25Mb2dpYy5pc19sb2dpYyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBsb2dpYyA9PT0gXCJvYmplY3RcIiAmJiAvLyBBbiBvYmplY3RcbiAgICAgIGxvZ2ljICE9PSBudWxsICYmIC8vIGJ1dCBub3QgbnVsbFxuICAgICAgISBBcnJheS5pc0FycmF5KGxvZ2ljKSAmJiAvLyBhbmQgbm90IGFuIGFycmF5XG4gICAgICBPYmplY3Qua2V5cyhsb2dpYykubGVuZ3RoID09PSAxIC8vIHdpdGggZXhhY3RseSBvbmUga2V5XG4gICAgKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIGhlbHBlciB3aWxsIGRlZmVyIHRvIHRoZSBKc29uTG9naWMgc3BlYyBhcyBhIHRpZS1icmVha2VyIHdoZW4gZGlmZmVyZW50IGxhbmd1YWdlIGludGVycHJldGVycyBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB0aGUgdHJ1dGhpbmVzcyBvZiBwcmltaXRpdmVzLiAgRS5nLiwgUEhQIGNvbnNpZGVycyBlbXB0eSBhcnJheXMgdG8gYmUgZmFsc3ksIGJ1dCBKYXZhc2NyaXB0IGNvbnNpZGVycyB0aGVtIHRvIGJlIHRydXRoeS4gSnNvbkxvZ2ljLCBhcyBhbiBlY29zeXN0ZW0sIG5lZWRzIG9uZSBjb25zaXN0ZW50IGFuc3dlci5cblxuICBTcGVjIGFuZCByYXRpb25hbGUgaGVyZTogaHR0cDovL2pzb25sb2dpYy5jb20vdHJ1dGh5XG4gICovXG4gIGpzb25Mb2dpYy50cnV0aHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhIHZhbHVlO1xuICB9O1xuXG5cbiAganNvbkxvZ2ljLmdldF9vcGVyYXRvciA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvZ2ljKVswXTtcbiAgfTtcblxuICBqc29uTG9naWMuZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIGxvZ2ljW2pzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpXTtcbiAgfTtcblxuICBqc29uTG9naWMuYXBwbHkgPSBmdW5jdGlvbihsb2dpYywgZGF0YSkge1xuICAgIC8vIERvZXMgdGhpcyBhcnJheSBjb250YWluIGxvZ2ljPyBPbmx5IG9uZSB3YXkgdG8gZmluZCBvdXQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9naWMpKSB7XG4gICAgICByZXR1cm4gbG9naWMubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseShsLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBZb3UndmUgcmVjdXJzZWQgdG8gYSBwcmltaXRpdmUsIHN0b3AhXG4gICAgaWYgKCAhIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICByZXR1cm4gbG9naWM7XG4gICAgfVxuXG4gICAgdmFyIG9wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihsb2dpYyk7XG4gICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgY3VycmVudDtcbiAgICB2YXIgc2NvcGVkTG9naWM7XG4gICAgdmFyIHNjb3BlZERhdGE7XG4gICAgdmFyIGluaXRpYWw7XG5cbiAgICAvLyBlYXN5IHN5bnRheCBmb3IgdW5hcnkgb3BlcmF0b3JzLCBsaWtlIHtcInZhclwiIDogXCJ4XCJ9IGluc3RlYWQgb2Ygc3RyaWN0IHtcInZhclwiIDogW1wieFwiXX1cbiAgICBpZiAoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyAnaWYnLCAnYW5kJywgYW5kICdvcicgdmlvbGF0ZSB0aGUgbm9ybWFsIHJ1bGUgb2YgZGVwdGgtZmlyc3QgY2FsY3VsYXRpbmcgY29uc2VxdWVudHMsIGxldCBlYWNoIG1hbmFnZSByZWN1cnNpb24gYXMgbmVlZGVkLlxuICAgIGlmIChvcCA9PT0gXCJpZlwiIHx8IG9wID09IFwiPzpcIikge1xuICAgICAgLyogJ2lmJyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYSBvZGQgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIDMgb3IgZ3JlYXRlclxuICAgICAgVGhpcyB3b3JrcyBvbiB0aGUgcGF0dGVybjpcbiAgICAgIGlmKCAwICl7IDEgfWVsc2V7IDIgfTtcbiAgICAgIGlmKCAwICl7IDEgfWVsc2UgaWYoIDIgKXsgMyB9ZWxzZXsgNCB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNlIGlmKCA0ICl7IDUgfWVsc2V7IDYgfTtcblxuICAgICAgVGhlIGltcGxlbWVudGF0aW9uIGlzOlxuICAgICAgRm9yIHBhaXJzIG9mIHZhbHVlcyAoMCwxIHRoZW4gMiwzIHRoZW4gNCw1IGV0YylcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgdHJ1dGh5LCBldmFsdWF0ZSBhbmQgcmV0dXJuIHRoZSBzZWNvbmRcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgZmFsc3ksIGp1bXAgdG8gdGhlIG5leHQgcGFpciAoZS5nLCAwLDEgdG8gMiwzKVxuICAgICAgZ2l2ZW4gb25lIHBhcmFtZXRlciwgZXZhbHVhdGUgYW5kIHJldHVybiBpdC4gKGl0J3MgYW4gRWxzZSBhbmQgYWxsIHRoZSBJZi9FbHNlSWYgd2VyZSBmYWxzZSlcbiAgICAgIGdpdmVuIDAgcGFyYW1ldGVycywgcmV0dXJuIE5VTEwgKG5vdCBncmVhdCBwcmFjdGljZSwgYnV0IHRoZXJlIHdhcyBubyBFbHNlKVxuICAgICAgKi9cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIGlmICgganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSkgKSApIHtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpKzFdLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IGkrMSkge1xuICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImFuZFwiKSB7IC8vIFJldHVybiBmaXJzdCBmYWxzeSwgb3IgbGFzdFxuICAgICAgZm9yIChpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGN1cnJlbnQgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzW2ldLCBkYXRhKTtcbiAgICAgICAgaWYgKCAhIGpzb25Mb2dpYy50cnV0aHkoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7IC8vIExhc3RcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcIm9yXCIpIHsvLyBSZXR1cm4gZmlyc3QgdHJ1dGh5LCBvciBsYXN0XG4gICAgICBmb3IgKGk9MDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgY3VycmVudCA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaV0sIGRhdGEpO1xuICAgICAgICBpZiAoIGpzb25Mb2dpYy50cnV0aHkoY3VycmVudCkgKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50OyAvLyBMYXN0XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJmaWx0ZXJcIikge1xuICAgICAgc2NvcGVkRGF0YSA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbMF0sIGRhdGEpO1xuICAgICAgc2NvcGVkTG9naWMgPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiBvbmx5IHRoZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheSBpbiB0aGUgZmlyc3QgYXJndW1lbnQsXG4gICAgICAvLyB0aGF0IHJldHVybiB0cnV0aHkgd2hlbiBwYXNzZWQgdG8gdGhlIGxvZ2ljIGluIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICAvLyBGb3IgcGFyaXR5IHdpdGggSmF2YVNjcmlwdCwgcmVpbmRleCB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICAgIHJldHVybiBzY29wZWREYXRhLmZpbHRlcihmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHNjb3BlZExvZ2ljLCBkYXR1bSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJtYXBcIikge1xuICAgICAgc2NvcGVkRGF0YSA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbMF0sIGRhdGEpO1xuICAgICAgc2NvcGVkTG9naWMgPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjb3BlZERhdGEubWFwKGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkoc2NvcGVkTG9naWMsIGRhdHVtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwicmVkdWNlXCIpIHtcbiAgICAgIHNjb3BlZERhdGEgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzWzBdLCBkYXRhKTtcbiAgICAgIHNjb3BlZExvZ2ljID0gdmFsdWVzWzFdO1xuICAgICAgaW5pdGlhbCA9IHR5cGVvZiB2YWx1ZXNbMl0gIT09IFwidW5kZWZpbmVkXCIgPyBqc29uTG9naWMuYXBwbHkodmFsdWVzWzJdLCBkYXRhKSA6IG51bGw7XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NvcGVkRGF0YS5yZWR1Y2UoXG4gICAgICAgIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseShcbiAgICAgICAgICAgIHNjb3BlZExvZ2ljLFxuICAgICAgICAgICAge2N1cnJlbnQ6IGN1cnJlbnQsIGFjY3VtdWxhdG9yOiBhY2N1bXVsYXRvcn1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiYWxsXCIpIHtcbiAgICAgIHNjb3BlZERhdGEgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzWzBdLCBkYXRhKTtcbiAgICAgIHNjb3BlZExvZ2ljID0gdmFsdWVzWzFdO1xuICAgICAgLy8gQWxsIG9mIGFuIGVtcHR5IHNldCBpcyBmYWxzZS4gTm90ZSwgc29tZSBhbmQgbm9uZSBoYXZlIGNvcnJlY3QgZmFsbGJhY2sgYWZ0ZXIgdGhlIGZvciBsb29wXG4gICAgICBpZiAoICEgQXJyYXkuaXNBcnJheShzY29wZWREYXRhKSB8fCAhIHNjb3BlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaT0wOyBpIDwgc2NvcGVkRGF0YS5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgaWYgKCAhIGpzb25Mb2dpYy50cnV0aHkoIGpzb25Mb2dpYy5hcHBseShzY29wZWRMb2dpYywgc2NvcGVkRGF0YVtpXSkgKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRmlyc3QgZmFsc3ksIHNob3J0IGNpcmN1aXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7IC8vIEFsbCB3ZXJlIHRydXRoeVxuICAgIH0gZWxzZSBpZiAob3AgPT09IFwibm9uZVwiKSB7XG4gICAgICBzY29wZWREYXRhID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1swXSwgZGF0YSk7XG4gICAgICBzY29wZWRMb2dpYyA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoc2NvcGVkRGF0YSkgfHwgISBzY29wZWREYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaT0wOyBpIDwgc2NvcGVkRGF0YS5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgaWYgKCBqc29uTG9naWMudHJ1dGh5KCBqc29uTG9naWMuYXBwbHkoc2NvcGVkTG9naWMsIHNjb3BlZERhdGFbaV0pICkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEZpcnN0IHRydXRoeSwgc2hvcnQgY2lyY3VpdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gTm9uZSB3ZXJlIHRydXRoeVxuICAgIH0gZWxzZSBpZiAob3AgPT09IFwic29tZVwiKSB7XG4gICAgICBzY29wZWREYXRhID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1swXSwgZGF0YSk7XG4gICAgICBzY29wZWRMb2dpYyA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoc2NvcGVkRGF0YSkgfHwgISBzY29wZWREYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGk9MDsgaSA8IHNjb3BlZERhdGEubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGlmICgganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHNjb3BlZExvZ2ljLCBzY29wZWREYXRhW2ldKSApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZpcnN0IHRydXRoeSwgc2hvcnQgY2lyY3VpdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vbmUgd2VyZSB0cnV0aHlcbiAgICB9XG5cbiAgICAvLyBFdmVyeW9uZSBlbHNlIGdldHMgaW1tZWRpYXRlIGRlcHRoLWZpcnN0IHJlY3Vyc2lvblxuICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbCwgZGF0YSk7XG4gICAgfSk7XG5cblxuICAgIC8vIFRoZSBvcGVyYXRpb24gaXMgY2FsbGVkIHdpdGggXCJkYXRhXCIgYm91bmQgdG8gaXRzIFwidGhpc1wiIGFuZCBcInZhbHVlc1wiIHBhc3NlZCBhcyBhcmd1bWVudHMuXG4gICAgLy8gU3RydWN0dXJlZCBjb21tYW5kcyBsaWtlICUgb3IgPiBjYW4gbmFtZSBmb3JtYWwgYXJndW1lbnRzIHdoaWxlIGZsZXhpYmxlIGNvbW1hbmRzIChsaWtlIG1pc3Npbmcgb3IgbWVyZ2UpIGNhbiBvcGVyYXRlIG9uIHRoZSBwc2V1ZG8tYXJyYXkgYXJndW1lbnRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2FyZ3VtZW50c1xuICAgIGlmIChvcGVyYXRpb25zLmhhc093blByb3BlcnR5KG9wKSAmJiB0eXBlb2Ygb3BlcmF0aW9uc1tvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbb3BdLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfSBlbHNlIGlmIChvcC5pbmRleE9mKFwiLlwiKSA+IDApIHsgLy8gQ29udGFpbnMgYSBkb3QsIGFuZCBub3QgaW4gdGhlIDB0aCBwb3NpdGlvblxuICAgICAgdmFyIHN1Yl9vcHMgPSBTdHJpbmcob3ApLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN1Yl9vcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvcGVyYXRpb24uaGFzT3duUHJvcGVydHkoc3ViX29wc1tpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgK1xuICAgICAgICAgICAgXCIgKGZhaWxlZCBhdCBcIiArIHN1Yl9vcHMuc2xpY2UoMCwgaSsxKS5qb2luKFwiLlwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXNjZW5kaW5nIGludG8gb3BlcmF0aW9uc1xuICAgICAgICBvcGVyYXRpb24gPSBvcGVyYXRpb25bc3ViX29wc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcGVyYXRpb24uYXBwbHkoZGF0YSwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgKTtcbiAgfTtcblxuICBqc29uTG9naWMudXNlc19kYXRhID0gZnVuY3Rpb24obG9naWMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgaWYgKGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykpIHtcbiAgICAgIHZhciBvcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpO1xuICAgICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wID09PSBcInZhclwiKSB7XG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBjb3ZlciB0aGUgY2FzZSB3aGVyZSB0aGUgYXJnIHRvIHZhciBpcyBpdHNlbGYgYSBydWxlLlxuICAgICAgICBjb2xsZWN0aW9uLnB1c2godmFsdWVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlY3Vyc2lvbiFcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5wdXNoLmFwcGx5KGNvbGxlY3Rpb24sIGpzb25Mb2dpYy51c2VzX2RhdGEodmFsKSApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29sbGVjdGlvbik7XG4gIH07XG5cbiAganNvbkxvZ2ljLmFkZF9vcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lLCBjb2RlKSB7XG4gICAgb3BlcmF0aW9uc1tuYW1lXSA9IGNvZGU7XG4gIH07XG5cbiAganNvbkxvZ2ljLnJtX29wZXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgb3BlcmF0aW9uc1tuYW1lXTtcbiAgfTtcblxuICBqc29uTG9naWMucnVsZV9saWtlID0gZnVuY3Rpb24ocnVsZSwgcGF0dGVybikge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSXMgXCIuIEpTT04uc3RyaW5naWZ5KHJ1bGUpIC4gXCIgbGlrZSBcIiAuIEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pIC4gXCI/XCIpO1xuICAgIGlmIChwYXR0ZXJuID09PSBydWxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFRPRE8gOiBEZWVwIG9iamVjdCBlcXVpdmFsZW5jeT9cbiAgICBpZiAocGF0dGVybiA9PT0gXCJAXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2lsZGNhcmQhXG4gICAgaWYgKHBhdHRlcm4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHJ1bGUgPT09IFwibnVtYmVyXCIpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuID09PSBcImFycmF5XCIpIHtcbiAgICAgIC8vICFsb2dpYyB0ZXN0IG1pZ2h0IGJlIHN1cGVyZmx1b3VzIGluIEphdmFTY3JpcHRcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJ1bGUpICYmICEganNvbkxvZ2ljLmlzX2xvZ2ljKHJ1bGUpO1xuICAgIH1cblxuICAgIGlmIChqc29uTG9naWMuaXNfbG9naWMocGF0dGVybikpIHtcbiAgICAgIGlmIChqc29uTG9naWMuaXNfbG9naWMocnVsZSkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5fb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHBhdHRlcm4pO1xuICAgICAgICB2YXIgcnVsZV9vcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IocnVsZSk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm5fb3AgPT09IFwiQFwiIHx8IHBhdHRlcm5fb3AgPT09IHJ1bGVfb3ApIHtcbiAgICAgICAgICAvLyBlY2hvIFwiXFxuT3BlcmF0b3JzIG1hdGNoLCBnbyBkZWVwZXJcXG5cIjtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnJ1bGVfbGlrZShcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHJ1bGUsIGZhbHNlKSxcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHBhdHRlcm4sIGZhbHNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTsgLy8gcGF0dGVybiBpcyBsb2dpYywgcnVsZSBpc24ndCwgY2FuJ3QgYmUgZXFcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoICE9PSBydWxlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgIE5vdGUsIGFycmF5IG9yZGVyIE1BVFRFUlMsIGJlY2F1c2Ugd2UncmUgdXNpbmcgdGhpcyBhcnJheSB0ZXN0IGxvZ2ljIHRvIGNvbnNpZGVyIGFyZ3VtZW50cywgd2hlcmUgb3JkZXIgY2FuIG1hdHRlci4gKGUuZy4sICsgaXMgY29tbXV0YXRpdmUsIGJ1dCAnLScgb3IgJ2lmJyBvciAndmFyJyBhcmUgTk9UKVxuICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyBJZiBhbnkgZmFpbCwgd2UgZmFpbFxuICAgICAgICAgIGlmICggISBqc29uTG9naWMucnVsZV9saWtlKHJ1bGVbaV0sIHBhdHRlcm5baV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBJZiB0aGV5ICphbGwqIHBhc3NlZCwgd2UgcGFzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQYXR0ZXJuIGlzIGFycmF5LCBydWxlIGlzbid0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90IGxvZ2ljLCBub3QgYXJyYXksIG5vdCBhID09PSBtYXRjaCBmb3IgcnVsZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIGpzb25Mb2dpYztcbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/json-logic-js/logic.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/constants.js":
/*!****************************************!*\
  !*** ./node_modules/next/constants.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/constants */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/constants.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrSUFBdUQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcbmV4dFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3NoYXJlZC9saWIvY29uc3RhbnRzJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/constants.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/fetch/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* globals self */ \nconst fetchModule = self.fetch.bind(self);\nmodule.exports = fetchModule;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZldGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFnQztBQUNoQztBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxidWlsZFxccG9seWZpbGxzXFxmZXRjaFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBzZWxmICovIFwidXNlIHN0cmljdFwiO1xuY29uc3QgZmV0Y2hNb2R1bGUgPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoTW9kdWxlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"(pages-dir-browser)/./pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPXByaXZhdGUtbmV4dC1wYWdlcyUyRl9hcHAmcGFnZT0lMkZfYXBwISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9FQUF5QjtBQUNoRDtBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(pages-dir-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || '';\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7b0RBSjJCO0FBRTNDLE1BQU1DLFdBQVlDLE1BQWtDLElBQWU7QUFFNUQsU0FBU0YsZ0JBQ2RLLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLE9BQTJCLEVBQzNCQyxhQUF1QztJQUV2QyxJQUFJTixLQUErQixFQUFFLEVBZ0JwQyxNQUFNO1FBQ0wsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGdldC1kb21haW4tbG9jYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgbm9ybWFsaXplTG9jYWxlUGF0aCBhcyBOb3JtYWxpemVGbiB9IGZyb20gJy4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IHR5cGUgeyBkZXRlY3REb21haW5Mb2NhbGUgYXMgRGV0ZWN0Rm4gfSBmcm9tICcuL2RldGVjdC1kb21haW4tbG9jYWxlJ1xuaW1wb3J0IHsgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21haW5Mb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXSxcbiAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoOiB0eXBlb2YgTm9ybWFsaXplRm4gPVxuICAgICAgcmVxdWlyZSgnLi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKS5ub3JtYWxpemVMb2NhbGVQYXRoXG4gICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlOiB0eXBlb2YgRGV0ZWN0Rm4gPVxuICAgICAgcmVxdWlyZSgnLi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGVcbiAgICBjb25zdCBkb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0YXJnZXQpXG4gICAgaWYgKGRvbWFpbikge1xuICAgICAgY29uc3QgcHJvdG8gPSBgaHR0cCR7ZG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly9gXG4gICAgICBjb25zdCBmaW5hbExvY2FsZSA9IHRhcmdldCA9PT0gZG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0YXJnZXR9YFxuICAgICAgcmV0dXJuIGAke3Byb3RvfSR7ZG9tYWluLmRvbWFpbn0ke25vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgICBgJHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gXG4gICAgICApfWBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(pages-dir-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(pages-dir-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(pages-dir-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\nconst _erroronce = __webpack_require__(/*! ../shared/lib/utils/error-once */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options) {\n    if (false) {}\n    if (!(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== 'undefined' ? options.locale : 'locale' in router ? router.locale : undefined;\n        const prefetchedKey = href + '%' + as + '%' + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    router.prefetch(href, as, options).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, onNavigate) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    if (!(0, _islocalurl.isLocalURL)(href)) {\n        if (replace) {\n            // browser default behavior does not replace the history state\n            // so we need to do it manually\n            e.preventDefault();\n            location.replace(href);\n        }\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        if (onNavigate) {\n            let isDefaultPrevented = false;\n            onNavigate({\n                preventDefault: ()=>{\n                    isDefaultPrevented = true;\n                }\n            });\n            if (isDefaultPrevented) {\n                return;\n            }\n        }\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if ('beforePopState' in router) {\n            router[replace ? 'replace' : 'push'](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? 'replace' : 'push'](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    navigate();\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onNavigate, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    if (true) {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'locale') {\n                if (props[key] && valType !== 'string') {\n                    throw createPropError({\n                        key,\n                        expected: '`string`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n    }\n    const { href, as } = _react.default.useMemo({\n        \"Link.LinkComponent.useMemo\": ()=>{\n            if (!router) {\n                const resolvedHref = formatStringOrUrl(hrefProp);\n                return {\n                    href: resolvedHref,\n                    as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n                };\n            }\n            const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, hrefProp, true);\n            return {\n                href: resolvedHref,\n                as: asProp ? (0, _resolvehref.resolveHref)(router, asProp) : resolvedAs || resolvedHref\n            };\n        }\n    }[\"Link.LinkComponent.useMemo\"], [\n        router,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: '200px'\n    });\n    const setIntersectionWithResetRef = _react.default.useCallback({\n        \"Link.LinkComponent.useCallback[setIntersectionWithResetRef]\": (el)=>{\n            // Before the link getting observed, check if visible state need to be reset\n            if (previousAs.current !== as || previousHref.current !== href) {\n                resetVisible();\n                previousAs.current = as;\n                previousHref.current = href;\n            }\n            setIntersectionRef(el);\n        }\n    }[\"Link.LinkComponent.useCallback[setIntersectionWithResetRef]\"], [\n        as,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    const setRef = (0, _usemergedref.useMergedRef)(setIntersectionWithResetRef, childRef);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect({\n        \"Link.LinkComponent.useEffect\": ()=>{\n            // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n            if (true) {\n                return;\n            }\n            if (!router) {\n                return;\n            }\n            // If we don't need to prefetch the URL, don't do prefetch.\n            if (!isVisible || !prefetchEnabled) {\n                return;\n            }\n            // Prefetch the URL.\n            prefetch(router, href, as, {\n                locale\n            });\n        }\n    }[\"Link.LinkComponent.useEffect\"], [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        router == null ? void 0 : router.locale,\n        router\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            });\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            });\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        const curLocale = typeof locale !== 'undefined' ? locale : router == null ? void 0 : router.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (router == null ? void 0 : router.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, router == null ? void 0 : router.locales, router == null ? void 0 : router.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, router == null ? void 0 : router.defaultLocale));\n    }\n    if (legacyBehavior) {\n        if (true) {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"cOEYCKQNQkvb3D7rzCm6zrDrstY=\")), \"cOEYCKQNQkvb3D7rzCm6zrDrstY=\");\n_c1 = Link;\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)({\n    // We do not support link status in the Pages Router, so we always return false\n    pending: false\n});\nconst useLinkStatus = ()=>{\n    // This behaviour is like React's useFormStatus. When the component is not under\n    // a <form> tag, it will get the default value, instead of throwing an error.\n    return (0, _react.useContext)(LinkStatusContext);\n};\nconst _default = Link;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUE4ckJBLE9BQW1CO2VBQW5COztJQU5hQSxhQUFhO2VBQWJBOzs7Ozs2RUFqckJvQzt5Q0FFckI7d0NBQ0Q7dUNBQ0Q7bUNBQ0k7dUNBQ0o7d0RBQ0k7NkNBRUU7NkNBQ0E7eUNBQ0o7MENBQ0M7dUNBQ0g7QUEwRzFCLE1BQU1DLGFBQWEsSUFBSUM7QUFVdkIsU0FBU0MsU0FDUEMsTUFBa0IsRUFDbEJDLElBQVksRUFDWkMsRUFBVSxFQUNWQyxPQUF3QjtJQUV4QixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFFRCxJQUFJLENBQUNFLENBQUFBLEdBQUFBLFlBQUFBLFVBQVUsRUFBQ0osT0FBTztRQUNyQjtJQUNGO0lBRUEsNEVBQTRFO0lBQzVFLFlBQVk7SUFDWixJQUFJLENBQUNFLFFBQVFHLHFCQUFxQixFQUFFO1FBQ2xDLE1BQU1DLFNBQ0osT0FDT0osUUFBUUksTUFBTSxLQUFLLGNBQ3RCSixRQUFRSSxNQUFNLEdBRWQsUUFKNkQsSUFJakRQLFNBQ1ZBLE9BQU9PLE1BQU0sR0FDYkM7UUFFUixNQUFNQyxnQkFBZ0JSLE9BQU8sTUFBTUMsS0FBSyxNQUFNSztRQUU5QyxrRUFBa0U7UUFDbEUsSUFBSVYsV0FBV2EsR0FBRyxDQUFDRCxnQkFBZ0I7WUFDakM7UUFDRjtRQUVBLCtCQUErQjtRQUMvQlosV0FBV2MsR0FBRyxDQUFDRjtJQUNqQjtJQUVBLHVEQUF1RDtJQUN2RCwwREFBMEQ7SUFDMUQsc0RBQXNEO0lBQ3RELHlEQUF5RDtJQUN6RFQsT0FBT0QsUUFBUSxDQUFDRSxNQUFNQyxJQUFJQyxTQUFTUyxLQUFLLENBQUMsQ0FBQ0M7UUFDeEMsSUFBSUMsSUFBb0IsRUFBbUI7WUFDekMscUNBQXFDO1lBQ3JDLE1BQU1EO1FBQ1I7SUFDRjtBQUNGO0FBRUEsU0FBU0ksZ0JBQWdCQyxLQUF1QjtJQUM5QyxNQUFNQyxjQUFjRCxNQUFNRSxhQUFhO0lBQ3ZDLE1BQU1DLFNBQVNGLFlBQVlHLFlBQVksQ0FBQztJQUN4QyxPQUNHRCxVQUFVQSxXQUFXLFdBQ3RCSCxNQUFNSyxPQUFPLElBQ2JMLE1BQU1NLE9BQU8sSUFDYk4sTUFBTU8sUUFBUSxJQUNkUCxNQUFNUSxNQUFNLElBQUksNkJBQTZCO0lBQzVDUixNQUFNUyxXQUFXLElBQUlULE1BQU1TLFdBQVcsQ0FBQ0MsS0FBSyxLQUFLO0FBRXREO0FBRUEsU0FBU0MsWUFDUEMsQ0FBbUIsRUFDbkI5QixNQUFzQyxFQUN0Q0MsSUFBWSxFQUNaQyxFQUFVLEVBQ1Y2QixPQUFpQixFQUNqQkMsT0FBaUIsRUFDakJDLE1BQWdCLEVBQ2hCMUIsTUFBdUIsRUFDdkIyQixVQUFtQztJQUVuQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHTCxFQUFFVixhQUFhO0lBRXBDLGtEQUFrRDtJQUNsRCxNQUFNZ0IsbUJBQW1CRCxTQUFTRSxXQUFXLE9BQU87SUFFcEQsSUFDR0Qsb0JBQW9CbkIsZ0JBQWdCYSxNQUNyQ0EsRUFBRVYsYUFBYSxDQUFDa0IsWUFBWSxDQUFDLGFBQzdCO1FBQ0EsOENBQThDO1FBQzlDO0lBQ0Y7SUFFQSxJQUFJLENBQUNqQyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXSixPQUFPO1FBQ3JCLElBQUk4QixTQUFTO1lBQ1gsOERBQThEO1lBQzlELCtCQUErQjtZQUMvQkQsRUFBRVMsY0FBYztZQUNoQkMsU0FBU1QsT0FBTyxDQUFDOUI7UUFDbkI7UUFFQSw4Q0FBOEM7UUFDOUM7SUFDRjtJQUVBNkIsRUFBRVMsY0FBYztJQUVoQixNQUFNRSxXQUFXO1FBQ2YsSUFBSVAsWUFBWTtZQUNkLElBQUlRLHFCQUFxQjtZQUV6QlIsV0FBVztnQkFDVEssZ0JBQWdCO29CQUNkRyxxQkFBcUI7Z0JBQ3ZCO1lBQ0Y7WUFFQSxJQUFJQSxvQkFBb0I7Z0JBQ3RCO1lBQ0Y7UUFDRjtRQUVBLHdFQUF3RTtRQUN4RSxNQUFNQyxlQUFlVixVQUFBQSxPQUFBQSxTQUFVO1FBQy9CLElBQUksb0JBQW9CakMsUUFBUTtZQUM5QkEsTUFBTSxDQUFDK0IsVUFBVSxZQUFZLE9BQU8sQ0FBQzlCLE1BQU1DLElBQUk7Z0JBQzdDOEI7Z0JBQ0F6QjtnQkFDQTBCLFFBQVFVO1lBQ1Y7UUFDRixPQUFPO1lBQ0wzQyxNQUFNLENBQUMrQixVQUFVLFlBQVksT0FBTyxDQUFDN0IsTUFBTUQsTUFBTTtnQkFDL0NnQyxRQUFRVTtZQUNWO1FBQ0Y7SUFDRjtJQUVBRjtBQUNGO0FBT0EsU0FBU0csa0JBQWtCQyxjQUFrQztJQUMzRCxJQUFJLE9BQU9BLG1CQUFtQixVQUFVO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUFVRDtBQUNuQjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxNQUFNRSxPQUFBQSxXQUFBQSxNQUFPQyxPQUFBQSxPQUFLLENBQUNDLFVBQVUsU0FDM0IsU0FBU0MsY0FBY0MsS0FBSyxFQUFFQyxZQUFZOztJQUN4QyxJQUFJQztJQUVKLE1BQU0sRUFDSnBELE1BQU1xRCxRQUFRLEVBQ2RwRCxJQUFJcUQsTUFBTSxFQUNWRixVQUFVRyxZQUFZLEVBQ3RCekQsVUFBVTBELGVBQWUsSUFBSSxFQUM3QkMsUUFBUSxFQUNSM0IsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTjFCLE1BQU0sRUFDTm9ELE9BQU8sRUFDUHpCLFVBQVUsRUFDVjBCLGNBQWNDLGdCQUFnQixFQUM5QkMsY0FBY0MsZ0JBQWdCLEVBQzlCQyxpQkFBaUIsS0FBSyxFQUN0QixHQUFHQyxXQUNKLEdBQUdkO0lBRUpFLFdBQVdHO0lBRVgsSUFDRVEsa0JBQ0MsUUFBT1gsYUFBYSxZQUFZLE9BQU9BLGFBQWEsU0FBTyxFQUM1RDtRQUNBQSxXQUFBQSxXQUFBQSxHQUFXLHFCQUFDYSxLQUFBQTtzQkFBR2I7O0lBQ2pCO0lBRUEsTUFBTXJELFNBQVNnRCxPQUFBQSxPQUFLLENBQUNtQixVQUFVLENBQUNDLDRCQUFBQSxhQUFhO0lBRTdDLE1BQU1DLGtCQUFrQlosaUJBQWlCO0lBRXpDLElBQUkzQyxJQUFvQixFQUFtQjtRQUN6QyxTQUFTd0QsZ0JBQWdCQyxJQUl4QjtZQUNDLE9BQU8scUJBTU4sQ0FOTSxJQUFJQyxNQUNSLGlDQUErQkQsS0FBS0UsR0FBRyxHQUFDLGlCQUFlRixLQUFLRyxRQUFRLEdBQUMsNEJBQTRCSCxLQUFLSSxNQUFNLEdBQUMsZUFDM0csTUFBNkIsR0FFMUIscUVBQ0EsRUFBQyxHQUxGO3VCQUFBOzRCQUFBOzhCQUFBO1lBTVA7UUFDRjtRQUVBLHNDQUFzQztRQUN0QyxNQUFNQyxxQkFBc0Q7WUFDMUQzRSxNQUFNO1FBQ1I7UUFDQSxNQUFNNEUsZ0JBQXFDQyxPQUFPQyxJQUFJLENBQ3BESDtRQUVGQyxjQUFjRyxPQUFPLENBQUMsQ0FBQ1A7WUFDckIsSUFBSUEsUUFBUSxRQUFRO2dCQUNsQixJQUNFdEIsS0FBSyxDQUFDc0IsSUFBSSxJQUFJLFFBQ2IsT0FBT3RCLEtBQUssQ0FBQ3NCLElBQUksS0FBSyxZQUFZLE9BQU90QixLQUFLLENBQUNzQixJQUFJLEtBQUssVUFDekQ7b0JBQ0EsTUFBTUgsZ0JBQWdCO3dCQUNwQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVF4QixLQUFLLENBQUNzQixJQUFJLEtBQUssT0FBTyxTQUFTLE9BQU90QixLQUFLLENBQUNzQixJQUFJO29CQUMxRDtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsc0NBQXNDO2dCQUN0Qyw2REFBNkQ7Z0JBQzdELE1BQU1RLElBQVdSO1lBQ25CO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsTUFBTVMscUJBQXNEO1lBQzFEaEYsSUFBSTtZQUNKNkIsU0FBUztZQUNURSxRQUFRO1lBQ1JELFNBQVM7WUFDVDBCLFVBQVU7WUFDVjNELFVBQVU7WUFDVlEsUUFBUTtZQUNSb0QsU0FBUztZQUNUQyxjQUFjO1lBQ2RFLGNBQWM7WUFDZEUsZ0JBQWdCO1lBQ2hCOUIsWUFBWTtRQUNkO1FBQ0EsTUFBTWlELGdCQUFxQ0wsT0FBT0MsSUFBSSxDQUNwREc7UUFFRkMsY0FBY0gsT0FBTyxDQUFDLENBQUNQO1lBQ3JCLE1BQU1XLFVBQVUsT0FBT2pDLEtBQUssQ0FBQ3NCLElBQUk7WUFFakMsSUFBSUEsUUFBUSxNQUFNO2dCQUNoQixJQUFJdEIsS0FBSyxDQUFDc0IsSUFBSSxJQUFJVyxZQUFZLFlBQVlBLFlBQVksVUFBVTtvQkFDOUQsTUFBTWQsZ0JBQWdCO3dCQUNwQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFTO29CQUNWO2dCQUNGO1lBQ0YsT0FBTyxJQUFJWCxRQUFRLFVBQVU7Z0JBQzNCLElBQUl0QixLQUFLLENBQUNzQixJQUFJLElBQUlXLFlBQVksVUFBVTtvQkFDdEMsTUFBTWQsZ0JBQWdCO3dCQUNwQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFTO29CQUNWO2dCQUNGO1lBQ0YsT0FBTyxJQUNMWCxRQUFRLGFBQ1JBLFFBQVEsa0JBQ1JBLFFBQVEsa0JBQ1JBLFFBQVEsY0FDUjtnQkFDQSxJQUFJdEIsS0FBSyxDQUFDc0IsSUFBSSxJQUFJVyxZQUFZLFlBQVk7b0JBQ3hDLE1BQU1kLGdCQUFnQjt3QkFDcEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRUztvQkFDVjtnQkFDRjtZQUNGLE9BQU8sSUFDTFgsUUFBUSxhQUNSQSxRQUFRLFlBQ1JBLFFBQVEsYUFDUkEsUUFBUSxjQUNSQSxRQUFRLGNBQ1JBLFFBQVEsa0JBQ1I7Z0JBQ0EsSUFBSXRCLEtBQUssQ0FBQ3NCLElBQUksSUFBSSxRQUFRVyxZQUFZLFdBQVc7b0JBQy9DLE1BQU1kLGdCQUFnQjt3QkFDcEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRUztvQkFDVjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsc0NBQXNDO2dCQUN0Qyw2REFBNkQ7Z0JBQzdELE1BQU1ILElBQVdSO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLE1BQU0sRUFBRXhFLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUc4QyxPQUFBQSxPQUFLLENBQUNxQyxPQUFPO3NDQUFDO1lBQ2pDLElBQUksQ0FBQ3JGLFFBQVE7Z0JBQ1gsTUFBTXNGLGVBQWUxQyxrQkFBa0JVO2dCQUN2QyxPQUFPO29CQUNMckQsTUFBTXFGO29CQUNOcEYsSUFBSXFELFNBQVNYLGtCQUFrQlcsVUFBVStCO2dCQUMzQztZQUNGO1lBRUEsTUFBTSxDQUFDQSxjQUFjQyxXQUFXLEdBQUdDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVl4RixRQUFRc0QsVUFBVTtZQUVqRSxPQUFPO2dCQUNMckQsTUFBTXFGO2dCQUNOcEYsSUFBSXFELFNBQVNpQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZeEYsUUFBUXVELFVBQVVnQyxjQUFjRDtZQUMzRDtRQUNGO3FDQUFHO1FBQUN0RjtRQUFRc0Q7UUFBVUM7S0FBTztJQUU3QixNQUFNa0MsZUFBZXpDLE9BQUFBLE9BQUssQ0FBQzBDLE1BQU0sQ0FBU3pGO0lBQzFDLE1BQU0wRixhQUFhM0MsT0FBQUEsT0FBSyxDQUFDMEMsTUFBTSxDQUFTeEY7SUFFeEMsb0ZBQW9GO0lBQ3BGLElBQUkwRjtJQUNKLElBQUk1QixnQkFBZ0I7UUFDbEIsSUFBSWxELElBQW9CLEVBQW9CO1lBQzFDLElBQUk2QyxTQUFTO2dCQUNYa0MsUUFBUUMsSUFBSSxDQUNULG9EQUFvRHhDLFdBQVM7WUFFbEU7WUFDQSxJQUFJTyxrQkFBa0I7Z0JBQ3BCZ0MsUUFBUUMsSUFBSSxDQUNULHlEQUF5RHhDLFdBQVM7WUFFdkU7WUFDQSxJQUFJO2dCQUNGc0MsUUFBUTVDLE9BQUFBLE9BQUssQ0FBQytDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDM0M7WUFDOUIsRUFBRSxPQUFPeEMsS0FBSztnQkFDWixJQUFJLENBQUN3QyxVQUFVO29CQUNiLE1BQU0scUJBRUwsQ0FGSyxJQUFJbUIsTUFDUCx1REFBdURsQixXQUFTLGtGQUQ3RDsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtnQkFDQSxNQUFNLHFCQUtMLENBTEssSUFBSWtCLE1BQ1AsNkRBQTZEbEIsV0FBUyw4RkFDcEUsTUFBNkIsR0FDMUIsc0VBQ0EsRUFBQyxHQUpIOzJCQUFBO2dDQUFBO2tDQUFBO2dCQUtOO1lBQ0Y7UUFDRixPQUFPLEVBRU47SUFDSCxPQUFPO1FBQ0wsSUFBSXhDLElBQW9CLEVBQW9CO1lBQzFDLElBQUksQ0FBQ3VDLFlBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFNBQWtCNEMsSUFBQUEsTUFBUyxLQUFLO2dCQUNuQyxNQUFNLHFCQUVMLENBRkssSUFBSXpCLE1BQ1Isb0tBREk7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBRU47WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNMEIsV0FBZ0JsQyxpQkFDbEI0QixTQUFTLE9BQU9BLFVBQVUsWUFBWUEsTUFBTU8sR0FBRyxHQUMvQy9DO0lBRUosTUFBTSxDQUFDZ0Qsb0JBQW9CQyxXQUFXQyxhQUFhLEdBQUdDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUFnQjtRQUNwRUMsWUFBWTtJQUNkO0lBRUEsTUFBTUMsOEJBQThCekQsT0FBQUEsT0FBSyxDQUFDMEQsV0FBVzt1RUFDbkQsQ0FBQ0M7WUFDQyw0RUFBNEU7WUFDNUUsSUFBSWhCLFdBQVdpQixPQUFPLEtBQUsxRyxNQUFNdUYsYUFBYW1CLE9BQU8sS0FBSzNHLE1BQU07Z0JBQzlEcUc7Z0JBQ0FYLFdBQVdpQixPQUFPLEdBQUcxRztnQkFDckJ1RixhQUFhbUIsT0FBTyxHQUFHM0c7WUFDekI7WUFFQW1HLG1CQUFtQk87UUFDckI7c0VBQ0E7UUFBQ3pHO1FBQUlEO1FBQU1xRztRQUFjRjtLQUFtQjtJQUc5QyxNQUFNUyxTQUFTQyxDQUFBQSxHQUFBQSxjQUFBQSxZQUFBQSxFQUFhTCw2QkFBNkJQO0lBRXpELDJEQUEyRDtJQUMzRGxELE9BQUFBLE9BQUssQ0FBQytELFNBQVM7d0NBQUM7WUFDZCxnSEFBZ0g7WUFDaEgsSUFBSWpHLElBQW9CLEVBQW1CO2dCQUN6QztZQUNGO1lBRUEsSUFBSSxDQUFDZCxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDcUcsYUFBYSxDQUFDaEMsaUJBQWlCO2dCQUNsQztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCdEUsU0FBU0MsUUFBUUMsTUFBTUMsSUFBSTtnQkFBRUs7WUFBTztRQUN0Qzt1Q0FBRztRQUFDTDtRQUFJRDtRQUFNb0c7UUFBVzlGO1FBQVE4RDtRQUFpQnJFLFVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE9BQVFPLE1BQU07UUFBRVA7S0FBTztJQUV6RSxNQUFNZ0gsYUFNRjtRQUNGYixLQUFLVTtRQUNMbEQsU0FBUTdCLENBQUM7WUFDUCxJQUFJaEIsSUFBb0IsRUFBbUI7Z0JBQ3pDLElBQUksQ0FBQ2dCLEdBQUc7b0JBQ04sTUFBTSxxQkFFTCxDQUZLLElBQUkwQyxNQUNQLG1GQURHOytCQUFBO29DQUFBO3NDQUFBO29CQUVOO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLENBQUNSLGtCQUFrQixPQUFPTCxZQUFZLFlBQVk7Z0JBQ3BEQSxRQUFRN0I7WUFDVjtZQUVBLElBQ0VrQyxrQkFDQTRCLE1BQU16QyxLQUFLLElBQ1gsT0FBT3lDLE1BQU16QyxLQUFLLENBQUNRLE9BQU8sS0FBSyxZQUMvQjtnQkFDQWlDLE1BQU16QyxLQUFLLENBQUNRLE9BQU8sQ0FBQzdCO1lBQ3RCO1lBRUEsSUFBSSxDQUFDOUIsUUFBUTtnQkFDWDtZQUNGO1lBRUEsSUFBSThCLEVBQUVtRixnQkFBZ0IsRUFBRTtnQkFDdEI7WUFDRjtZQUVBcEYsWUFDRUMsR0FDQTlCLFFBQ0FDLE1BQ0FDLElBQ0E2QixTQUNBQyxTQUNBQyxRQUNBMUIsUUFDQTJCO1FBRUo7UUFDQTBCLGNBQWE5QixDQUFDO1lBQ1osSUFBSSxDQUFDa0Msa0JBQWtCLE9BQU9ILHFCQUFxQixZQUFZO2dCQUM3REEsaUJBQWlCL0I7WUFDbkI7WUFFQSxJQUNFa0Msa0JBQ0E0QixNQUFNekMsS0FBSyxJQUNYLE9BQU95QyxNQUFNekMsS0FBSyxDQUFDUyxZQUFZLEtBQUssWUFDcEM7Z0JBQ0FnQyxNQUFNekMsS0FBSyxDQUFDUyxZQUFZLENBQUM5QjtZQUMzQjtZQUVBLElBQUksQ0FBQzlCLFFBQVE7Z0JBQ1g7WUFDRjtZQUVBRCxTQUFTQyxRQUFRQyxNQUFNQyxJQUFJO2dCQUN6Qks7Z0JBQ0EyRyxVQUFVO2dCQUNWLGdHQUFnRztnQkFDaEc1Ryx1QkFBdUI7WUFDekI7UUFDRjtRQUNBd0QsY0FBY2hELE1BQXNDLEdBQ2hETixDQUFTQSxHQUNULFNBQVNzRCxhQUFhaEMsQ0FBQztZQUNyQixJQUFJLENBQUNrQyxrQkFBa0IsT0FBT0QscUJBQXFCLFlBQVk7Z0JBQzdEQSxpQkFBaUJqQztZQUNuQjtZQUVBLElBQ0VrQyxrQkFDQTRCLE1BQU16QyxLQUFLLElBQ1gsT0FBT3lDLE1BQU16QyxLQUFLLENBQUNXLFlBQVksS0FBSyxZQUNwQztnQkFDQThCLE1BQU16QyxLQUFLLENBQUNXLFlBQVksQ0FBQ2hDO1lBQzNCO1lBRUEsSUFBSSxDQUFDOUIsUUFBUTtnQkFDWDtZQUNGO1lBRUFELFNBQVNDLFFBQVFDLE1BQU1DLElBQUk7Z0JBQ3pCSztnQkFDQTJHLFVBQVU7Z0JBQ1YsZ0dBQWdHO2dCQUNoRzVHLHVCQUF1QjtZQUN6QjtRQUNGO0lBQ047SUFFQSw2RkFBNkY7SUFDN0Ysd0ZBQXdGO0lBQ3hGLG9GQUFvRjtJQUNwRixJQUFJOEcsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBY2xILEtBQUs7UUFDckI4RyxXQUFXL0csSUFBSSxHQUFHQztJQUNwQixPQUFPLElBQ0wsQ0FBQzhELGtCQUNETixZQUNDa0MsTUFBTUssSUFBSSxLQUFLLE9BQU8sQ0FBRSxXQUFVTCxNQUFNekMsS0FBQUEsR0FDekM7UUFDQSxNQUFNa0UsWUFBWSxPQUFPOUcsV0FBVyxjQUFjQSxTQUFTUCxVQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxPQUFRTyxNQUFNO1FBRXpFLHVFQUF1RTtRQUN2RSx1RUFBdUU7UUFDdkUsTUFBTStHLGVBQ0p0SCxDQUFBQSxVQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxPQUFRdUgsY0FBQUEsS0FDUkMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCdEgsSUFBSW1ILFdBQVdySCxVQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxPQUFReUgsT0FBTyxFQUFFekgsVUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsT0FBUTBILGFBQWE7UUFFdkVWLFdBQVcvRyxJQUFJLEdBQ2JxSCxnQkFDQUssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWUMsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBQUEsRUFBVTFILElBQUltSCxXQUFXckgsVUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsT0FBUTZILGFBQWE7SUFDOUQ7SUFFQSxJQUFJN0QsZ0JBQWdCO1FBQ2xCLElBQUlsRCxJQUFvQixFQUFvQjtZQUMxQ2dILENBQUFBLEdBQUFBLFdBQUFBLFNBQUFBLEVBQ0Usb0VBQ0Usb0VBQ0EsNENBQ0E7UUFFTjtRQUNBLHFCQUFPOUUsT0FBQUEsT0FBSyxDQUFDK0UsWUFBWSxDQUFDbkMsT0FBT29CO0lBQ25DO0lBRUEsT0FDRSxXQURGLEdBQ0UscUJBQUM5QyxLQUFBQTtRQUFHLEdBQUdELFNBQVM7UUFBRyxHQUFHK0MsVUFBVTtrQkFDN0IzRDs7QUFHUDs7QUFHRixNQUFNMkUsb0JBQUFBLFdBQUFBLEdBQW9CQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUV2QjtJQUNELCtFQUErRTtJQUMvRUMsU0FBUztBQUNYO0FBRU8sTUFBTXRJLGdCQUFnQjtJQUMzQixnRkFBZ0Y7SUFDaEYsNkVBQTZFO0lBQzdFLE9BQU91RSxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXNkQ7QUFDcEI7TUFFQSxXQUFlakYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGxpbmsudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgdHlwZSB7XG4gIE5leHRSb3V0ZXIsXG4gIFByZWZldGNoT3B0aW9ucyBhcyBSb3V0ZXJQcmVmZXRjaE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlcidcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgcmVzb2x2ZUhyZWYgfSBmcm9tICcuL3Jlc29sdmUtaHJlZidcbmltcG9ydCB7IGlzTG9jYWxVUkwgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgaXNBYnNvbHV0ZVVybCB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgeyBhZGRMb2NhbGUgfSBmcm9tICcuL2FkZC1sb2NhbGUnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVySW5zdGFuY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHVzZUludGVyc2VjdGlvbiB9IGZyb20gJy4vdXNlLWludGVyc2VjdGlvbidcbmltcG9ydCB7IGdldERvbWFpbkxvY2FsZSB9IGZyb20gJy4vZ2V0LWRvbWFpbi1sb2NhbGUnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IHVzZU1lcmdlZFJlZiB9IGZyb20gJy4vdXNlLW1lcmdlZC1yZWYnXG5pbXBvcnQgeyBlcnJvck9uY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzL2Vycm9yLW9uY2UnXG5cbnR5cGUgVXJsID0gc3RyaW5nIHwgVXJsT2JqZWN0XG50eXBlIFJlcXVpcmVkS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gbmV2ZXIgOiBLXG59W2tleW9mIFRdXG50eXBlIE9wdGlvbmFsS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gSyA6IG5ldmVyXG59W2tleW9mIFRdXG5cbnR5cGUgT25OYXZpZ2F0ZUV2ZW50SGFuZGxlciA9IChldmVudDogeyBwcmV2ZW50RGVmYXVsdDogKCkgPT4gdm9pZCB9KSA9PiB2b2lkXG5cbnR5cGUgSW50ZXJuYWxMaW5rUHJvcHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCBvciBVUkwgdG8gbmF2aWdhdGUgdG8uIEl0IGNhbiBhbHNvIGJlIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xpbmsjd2l0aC11cmwtb2JqZWN0XG4gICAqL1xuICBocmVmOiBVcmxcbiAgLyoqXG4gICAqIE9wdGlvbmFsIGRlY29yYXRvciBmb3IgdGhlIHBhdGggdGhhdCB3aWxsIGJlIHNob3duIGluIHRoZSBicm93c2VyIFVSTCBiYXIuIEJlZm9yZSBOZXh0LmpzIDkuNS4zIHRoaXMgd2FzIHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzLCBjaGVjayBvdXIgW3ByZXZpb3VzIGRvY3NdKGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9ibG9iL3Y5LjUuMi9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9saW5rLm1kI2R5bmFtaWMtcm91dGVzKSB0byBzZWUgaG93IGl0IHdvcmtlZC4gTm90ZTogd2hlbiB0aGlzIHBhdGggZGlmZmVycyBmcm9tIHRoZSBvbmUgcHJvdmlkZWQgaW4gYGhyZWZgIHRoZSBwcmV2aW91cyBgaHJlZmAvYGFzYCBiZWhhdmlvciBpcyB1c2VkIGFzIHNob3duIGluIHRoZSBbcHJldmlvdXMgZG9jc10oaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Jsb2IvdjkuNS4yL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xpbmsubWQjZHluYW1pYy1yb3V0ZXMpLlxuICAgKi9cbiAgYXM/OiBVcmxcbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGN1cnJlbnQgYGhpc3RvcnlgIHN0YXRlIGluc3RlYWQgb2YgYWRkaW5nIGEgbmV3IHVybCBpbnRvIHRoZSBzdGFjay5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICByZXBsYWNlPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3JcbiAgICpcbiAgICogQGV4YW1wbGUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xpbmsjZGlzYWJsZS1zY3JvbGxpbmctdG8tdGhlLXRvcC1vZi10aGUtcGFnZVxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgKi9cbiAgc2Nyb2xsPzogYm9vbGVhblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwYXRoIG9mIHRoZSBjdXJyZW50IHBhZ2Ugd2l0aG91dCByZXJ1bm5pbmcgW2BnZXRTdGF0aWNQcm9wc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL3BhZ2VzL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9nZXQtc3RhdGljLXByb3BzKSwgW2BnZXRTZXJ2ZXJTaWRlUHJvcHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9wYWdlcy9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvZ2V0LXNlcnZlci1zaWRlLXByb3BzKSBvciBbYGdldEluaXRpYWxQcm9wc2BdKC9kb2NzL3BhZ2VzL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2dldC1pbml0aWFsLXByb3BzKS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICBzaGFsbG93PzogYm9vbGVhblxuICAvKipcbiAgICogRm9yY2VzIGBMaW5rYCB0byBzZW5kIHRoZSBgaHJlZmAgcHJvcGVydHkgdG8gaXRzIGNoaWxkLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICAvKipcbiAgICogUHJlZmV0Y2ggdGhlIHBhZ2UgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqIEFueSBgPExpbmsgLz5gIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IChpbml0aWFsbHkgb3IgdGhyb3VnaCBzY3JvbGwpIHdpbGwgYmUgcHJlZmV0Y2hlZC5cbiAgICogUHJlZmV0Y2ggY2FuIGJlIGRpc2FibGVkIGJ5IHBhc3NpbmcgYHByZWZldGNoPXtmYWxzZX1gLiBQcmVmZXRjaGluZyBpcyBvbmx5IGVuYWJsZWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogSW4gQXBwIFJvdXRlcjpcbiAgICogLSBgbnVsbGAgKGRlZmF1bHQpOiBGb3Igc3RhdGljYWxseSBnZW5lcmF0ZWQgcGFnZXMsIHRoaXMgd2lsbCBwcmVmZXRjaCB0aGUgZnVsbCBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50IGRhdGEuIEZvciBkeW5hbWljIHBhZ2VzLCB0aGlzIHdpbGwgcHJlZmV0Y2ggdXAgdG8gdGhlIG5lYXJlc3Qgcm91dGUgc2VnbWVudCB3aXRoIGEgW2Bsb2FkaW5nLmpzYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZmlsZS1jb252ZW50aW9ucy9sb2FkaW5nKSBmaWxlLiBJZiB0aGVyZSBpcyBubyBsb2FkaW5nIGZpbGUsIGl0IHdpbGwgbm90IGZldGNoIHRoZSBmdWxsIHRyZWUgdG8gYXZvaWQgZmV0Y2hpbmcgdG9vIG11Y2ggZGF0YS5cbiAgICogLSBgdHJ1ZWA6IFRoaXMgd2lsbCBwcmVmZXRjaCB0aGUgZnVsbCBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50IGRhdGEgZm9yIGFsbCByb3V0ZSBzZWdtZW50cywgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgY29udGFpbiBhIHNlZ21lbnQgd2l0aCBgbG9hZGluZy5qc2AuXG4gICAqIC0gYGZhbHNlYDogVGhpcyB3aWxsIG5vdCBwcmVmZXRjaCBhbnkgZGF0YSwgZXZlbiBvbiBob3Zlci5cbiAgICpcbiAgICogSW4gUGFnZXMgUm91dGVyOlxuICAgKiAtIGB0cnVlYCAoZGVmYXVsdCk6IFRoZSBmdWxsIHJvdXRlICYgaXRzIGRhdGEgd2lsbCBiZSBwcmVmZXRjaGVkLlxuICAgKiAtIGBmYWxzZWA6IFByZWZldGNoaW5nIHdpbGwgbm90IGhhcHBlbiB3aGVuIGVudGVyaW5nIHRoZSB2aWV3cG9ydCwgYnV0IHdpbGwgc3RpbGwgaGFwcGVuIG9uIGhvdmVyLlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYCAocGFnZXMgcm91dGVyKSBvciBgbnVsbGAgKGFwcCByb3V0ZXIpXG4gICAqL1xuICBwcmVmZXRjaD86IGJvb2xlYW4gfCBudWxsXG4gIC8qKlxuICAgKiBUaGUgYWN0aXZlIGxvY2FsZSBpcyBhdXRvbWF0aWNhbGx5IHByZXBlbmRlZC4gYGxvY2FsZWAgYWxsb3dzIGZvciBwcm92aWRpbmcgYSBkaWZmZXJlbnQgbG9jYWxlLlxuICAgKiBXaGVuIGBmYWxzZWAgYGhyZWZgIGhhcyB0byBpbmNsdWRlIHRoZSBsb2NhbGUgYXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgZGlzYWJsZWQuXG4gICAqIE5vdGU6IFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIFBhZ2VzIFJvdXRlci5cbiAgICovXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gIC8qKlxuICAgKiBFbmFibGUgbGVnYWN5IGxpbmsgYmVoYXZpb3IuXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHYxNlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvY29tbWl0LzQ4OWU2NWVkOTg1NDRlNjliMGFmZDdlMGNmYzNmOWY2YzJiODAzYjdcbiAgICovXG4gIGxlZ2FjeUJlaGF2aW9yPzogYm9vbGVhblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgbW91c2UgcG9pbnRlciBpcyBtb3ZlZCBvbnRvIExpbmtcbiAgICovXG4gIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiBMaW5rIGlzIHRvdWNoZWQuXG4gICAqL1xuICBvblRvdWNoU3RhcnQ/OiBSZWFjdC5Ub3VjaEV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gTGluayBpcyBjbGlja2VkLlxuICAgKi9cbiAgb25DbGljaz86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYDxMaW5rPmAgaXMgbmF2aWdhdGVkLlxuICAgKi9cbiAgb25OYXZpZ2F0ZT86IE9uTmF2aWdhdGVFdmVudEhhbmRsZXJcbn1cblxuLy8gVE9ETy1BUFA6IEluY2x1ZGUgdGhlIGZ1bGwgc2V0IG9mIEFuY2hvciBwcm9wc1xuLy8gYWRkaW5nIHRoaXMgdG8gdGhlIHB1YmxpY2x5IGV4cG9ydGVkIHR5cGUgY3VycmVudGx5IGJyZWFrcyBleGlzdGluZyBhcHBzXG5cbi8vIGBSb3V0ZUluZmVyVHlwZWAgaXMgYSBzdHViIGhlcmUgdG8gYXZvaWQgYnJlYWtpbmcgYHR5cGVkUm91dGVzYCB3aGVuIHRoZSB0eXBlXG4vLyBpc24ndCBnZW5lcmF0ZWQgeWV0LiBJdCB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHdlYnBhY2sgcGx1Z2luIHJ1bnMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgdHlwZSBMaW5rUHJvcHM8Um91dGVJbmZlclR5cGUgPSBhbnk+ID0gSW50ZXJuYWxMaW5rUHJvcHNcbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxJbnRlcm5hbExpbmtQcm9wcz5cblxuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbnR5cGUgUHJlZmV0Y2hPcHRpb25zID0gUm91dGVyUHJlZmV0Y2hPcHRpb25zICYge1xuICAvKipcbiAgICogYnlwYXNzUHJlZmV0Y2hlZENoZWNrIHdpbGwgYnlwYXNzIHRoZSBjaGVjayB0byBzZWUgaWYgdGhlIGBocmVmYCBoYXNcbiAgICogYWxyZWFkeSBiZWVuIGZldGNoZWQuXG4gICAqL1xuICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIHByZWZldGNoKFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgLy8gZGlzYWJsZWQuXG4gIGlmICghb3B0aW9ucy5ieXBhc3NQcmVmZXRjaGVkQ2hlY2spIHtcbiAgICBjb25zdCBsb2NhbGUgPVxuICAgICAgLy8gTGV0IHRoZSBsaW5rJ3MgbG9jYWxlIHByb3Agb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcm91dGVyIGxvY2FsZS5cbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBvcHRpb25zLmxvY2FsZVxuICAgICAgICA6IC8vIE90aGVyd2lzZSBmYWxsYmFjayB0byB0aGUgcm91dGVyJ3MgbG9jYWxlLlxuICAgICAgICAgICdsb2NhbGUnIGluIHJvdXRlclxuICAgICAgICAgID8gcm91dGVyLmxvY2FsZVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBwcmVmZXRjaGVkS2V5ID0gaHJlZiArICclJyArIGFzICsgJyUnICsgbG9jYWxlXG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZldGNoZWQgdGhlIGtleSwgdGhlbiBkb24ndCBwcmVmZXRjaCBpdCBhZ2FpbiFcbiAgICBpZiAocHJlZmV0Y2hlZC5oYXMocHJlZmV0Y2hlZEtleSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIE1hcmsgdGhpcyBVUkwgYXMgcHJlZmV0Y2hlZC5cbiAgICBwcmVmZXRjaGVkLmFkZChwcmVmZXRjaGVkS2V5KVxuICB9XG5cbiAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0JylcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICByb3V0ZXI6IE5leHRSb3V0ZXIgfCBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBvbk5hdmlnYXRlPzogT25OYXZpZ2F0ZUV2ZW50SGFuZGxlclxuKTogdm9pZCB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldFxuXG4gIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSdcblxuICBpZiAoXG4gICAgKGlzQW5jaG9yTm9kZU5hbWUgJiYgaXNNb2RpZmllZEV2ZW50KGUpKSB8fFxuICAgIGUuY3VycmVudFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJylcbiAgKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgLy8gYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGRvZXMgbm90IHJlcGxhY2UgdGhlIGhpc3Rvcnkgc3RhdGVcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZG8gaXQgbWFudWFsbHlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmKVxuICAgIH1cblxuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgY29uc3QgbmF2aWdhdGUgPSAoKSA9PiB7XG4gICAgaWYgKG9uTmF2aWdhdGUpIHtcbiAgICAgIGxldCBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZVxuXG4gICAgICBvbk5hdmlnYXRlKHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoaXNEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgIGNvbnN0IHJvdXRlclNjcm9sbCA9IHNjcm9sbCA/PyB0cnVlXG4gICAgaWYgKCdiZWZvcmVQb3BTdGF0ZScgaW4gcm91dGVyKSB7XG4gICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBzY3JvbGw6IHJvdXRlclNjcm9sbCxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShhcyB8fCBocmVmLCB7XG4gICAgICAgIHNjcm9sbDogcm91dGVyU2Nyb2xsLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBuYXZpZ2F0ZSgpXG59XG5cbnR5cGUgTGlua1Byb3BzUmVhbCA9IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPFxuICBPbWl0PFJlYWN0LkFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50Piwga2V5b2YgTGlua1Byb3BzPiAmXG4gICAgTGlua1Byb3BzXG4+XG5cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nOiBVcmxPYmplY3QgfCBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHVybE9iak9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmxPYmpPclN0cmluZ1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmxPYmpPclN0cmluZylcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IGV4dGVuZHMgdGhlIEhUTUwgYDxhPmAgZWxlbWVudCB0byBwcm92aWRlIFtwcmVmZXRjaGluZ10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9saW5raW5nLWFuZC1uYXZpZ2F0aW5nIzItcHJlZmV0Y2hpbmcpXG4gKiBhbmQgY2xpZW50LXNpZGUgbmF2aWdhdGlvbiBiZXR3ZWVuIHJvdXRlcy5cbiAqXG4gKiBJdCBpcyB0aGUgcHJpbWFyeSB3YXkgdG8gbmF2aWdhdGUgYmV0d2VlbiByb3V0ZXMgaW4gTmV4dC5qcy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIGRvY3M6IGA8TGluaz5gXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2xpbmspXG4gKi9cbmNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHNSZWFsPihcbiAgZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgbGV0IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcblxuICAgIGNvbnN0IHtcbiAgICAgIGhyZWY6IGhyZWZQcm9wLFxuICAgICAgYXM6IGFzUHJvcCxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblByb3AsXG4gICAgICBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCxcbiAgICAgIHBhc3NIcmVmLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHNoYWxsb3csXG4gICAgICBzY3JvbGwsXG4gICAgICBsb2NhbGUsXG4gICAgICBvbkNsaWNrLFxuICAgICAgb25OYXZpZ2F0ZSxcbiAgICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCxcbiAgICAgIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCxcbiAgICAgIGxlZ2FjeUJlaGF2aW9yID0gZmFsc2UsXG4gICAgICAuLi5yZXN0UHJvcHNcbiAgICB9ID0gcHJvcHNcblxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wXG5cbiAgICBpZiAoXG4gICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJylcbiAgICApIHtcbiAgICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZXIgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG5cbiAgICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3M6IHtcbiAgICAgICAga2V5OiBzdHJpbmdcbiAgICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgICBhY3R1YWw6IHN0cmluZ1xuICAgICAgfSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICtcbiAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IC8vIFRPRE86IFJlbW92ZSB0aGlzIGFkZGVuZHVtIGlmIE93bmVyIFN0YWNrcyBhcmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiXG4gICAgICAgICAgICAgIDogJycpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgICAgaHJlZjogdHJ1ZSxcbiAgICAgIH0gYXMgY29uc3RcbiAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgICAgcmVxdWlyZWRQcm9wc0d1YXJkXG4gICAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAgICh0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzT3B0aW9uYWwsIHRydWU+ID0ge1xuICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlLFxuICAgICAgICBvbk5hdmlnYXRlOiB0cnVlLFxuICAgICAgfSBhcyBjb25zdFxuICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICAgICkgYXMgTGlua1Byb3BzT3B0aW9uYWxbXVxuICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdvbkNsaWNrJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ29uTW91c2VFbnRlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdvblRvdWNoU3RhcnQnIHx8XG4gICAgICAgICAga2V5ID09PSAnb25OYXZpZ2F0ZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ2BmdW5jdGlvbmAnLFxuICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3Njcm9sbCcgfHxcbiAgICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3ByZWZldGNoJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ2xlZ2FjeUJlaGF2aW9yJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWYsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWZQcm9wLCB0cnVlKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgIGFzOiBhc1Byb3AgPyByZXNvbHZlSHJlZihyb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZixcbiAgICAgIH1cbiAgICB9LCBbcm91dGVyLCBocmVmUHJvcCwgYXNQcm9wXSlcblxuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IFJlYWN0LnVzZVJlZjxzdHJpbmc+KGhyZWYpXG4gICAgY29uc3QgcHJldmlvdXNBcyA9IFJlYWN0LnVzZVJlZjxzdHJpbmc+KGFzKVxuXG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkOiBhbnlcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlbmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArXG4gICAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgICAgIDogJycpXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAoKGNoaWxkcmVuIGFzIGFueSk/LnR5cGUgPT09ICdhJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBsZWdhY3lCZWhhdmlvclxuICAgICAgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuICAgICAgOiBmb3J3YXJkZWRSZWZcblxuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9IHVzZUludGVyc2VjdGlvbih7XG4gICAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgIH0pXG5cbiAgICBjb25zdCBzZXRJbnRlcnNlY3Rpb25XaXRoUmVzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChlbDogRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICAgICAgLy8gQmVmb3JlIHRoZSBsaW5rIGdldHRpbmcgb2JzZXJ2ZWQsIGNoZWNrIGlmIHZpc2libGUgc3RhdGUgbmVlZCB0byBiZSByZXNldFxuICAgICAgICBpZiAocHJldmlvdXNBcy5jdXJyZW50ICE9PSBhcyB8fCBwcmV2aW91c0hyZWYuY3VycmVudCAhPT0gaHJlZikge1xuICAgICAgICAgIHJlc2V0VmlzaWJsZSgpXG4gICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXNcbiAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWZcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbClcbiAgICAgIH0sXG4gICAgICBbYXMsIGhyZWYsIHJlc2V0VmlzaWJsZSwgc2V0SW50ZXJzZWN0aW9uUmVmXVxuICAgIClcblxuICAgIGNvbnN0IHNldFJlZiA9IHVzZU1lcmdlZFJlZihzZXRJbnRlcnNlY3Rpb25XaXRoUmVzZXRSZWYsIGNoaWxkUmVmKVxuXG4gICAgLy8gUHJlZmV0Y2ggdGhlIFVSTCBpZiB3ZSBoYXZlbid0IGFscmVhZHkgYW5kIGl0J3MgdmlzaWJsZS5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gaW4gZGV2LCB3ZSBvbmx5IHByZWZldGNoIG9uIGhvdmVyIHRvIGF2b2lkIHdhc3RpbmcgcmVzb3VyY2VzIGFzIHRoZSBwcmVmZXRjaCB3aWxsIHRyaWdnZXIgY29tcGlsaW5nIHRoZSBwYWdlLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHRvIHByZWZldGNoIHRoZSBVUkwsIGRvbid0IGRvIHByZWZldGNoLlxuICAgICAgaWYgKCFpc1Zpc2libGUgfHwgIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gUHJlZmV0Y2ggdGhlIFVSTC5cbiAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHsgbG9jYWxlIH0pXG4gICAgfSwgW2FzLCBocmVmLCBpc1Zpc2libGUsIGxvY2FsZSwgcHJlZmV0Y2hFbmFibGVkLCByb3V0ZXI/LmxvY2FsZSwgcm91dGVyXSlcblxuICAgIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICAgIG9uVG91Y2hTdGFydD86IFJlYWN0LlRvdWNoRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgICAgb25Nb3VzZUVudGVyOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgICAgaHJlZj86IHN0cmluZ1xuICAgICAgcmVmPzogYW55XG4gICAgfSA9IHtcbiAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgb25DbGljayhlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25DbGljayhlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGlua0NsaWNrZWQoXG4gICAgICAgICAgZSxcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICBhcyxcbiAgICAgICAgICByZXBsYWNlLFxuICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICBvbk5hdmlnYXRlXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBvbk1vdXNlRW50ZXIoZSkge1xuICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG9uVG91Y2hTdGFydDogcHJvY2Vzcy5lbnYuX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgIH1cblxuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgICAvLyBJZiB0aGUgdXJsIGlzIGFic29sdXRlLCB3ZSBjYW4gYnlwYXNzIHRoZSBsb2dpYyB0byBwcmVwZW5kIHRoZSBkb21haW4gYW5kIGxvY2FsZS5cbiAgICBpZiAoaXNBYnNvbHV0ZVVybChhcykpIHtcbiAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICFsZWdhY3lCZWhhdmlvciB8fFxuICAgICAgcGFzc0hyZWYgfHxcbiAgICAgIChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKVxuICAgICkge1xuICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXI/LmxvY2FsZVxuXG4gICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcbiAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9XG4gICAgICAgIHJvdXRlcj8uaXNMb2NhbGVEb21haW4gJiZcbiAgICAgICAgZ2V0RG9tYWluTG9jYWxlKGFzLCBjdXJMb2NhbGUsIHJvdXRlcj8ubG9jYWxlcywgcm91dGVyPy5kb21haW5Mb2NhbGVzKVxuXG4gICAgICBjaGlsZFByb3BzLmhyZWYgPVxuICAgICAgICBsb2NhbGVEb21haW4gfHxcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzLCBjdXJMb2NhbGUsIHJvdXRlcj8uZGVmYXVsdExvY2FsZSkpXG4gICAgfVxuXG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgZXJyb3JPbmNlKFxuICAgICAgICAgICdgbGVnYWN5QmVoYXZpb3JgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSAnICtcbiAgICAgICAgICAgICdyZWxlYXNlLiBBIGNvZGVtb2QgaXMgYXZhaWxhYmxlIHRvIHVwZ3JhZGUgeW91ciBjb21wb25lbnRzOlxcblxcbicgK1xuICAgICAgICAgICAgJ25weCBAbmV4dC9jb2RlbW9kQGxhdGVzdCBuZXctbGluayAuXFxuXFxuJyArXG4gICAgICAgICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vdXBncmFkaW5nL2NvZGVtb2RzI3JlbW92ZS1hLXRhZ3MtZnJvbS1saW5rLWNvbXBvbmVudHMnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxhIHsuLi5yZXN0UHJvcHN9IHsuLi5jaGlsZFByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuKVxuXG5jb25zdCBMaW5rU3RhdHVzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8e1xuICBwZW5kaW5nOiBib29sZWFuXG59Pih7XG4gIC8vIFdlIGRvIG5vdCBzdXBwb3J0IGxpbmsgc3RhdHVzIGluIHRoZSBQYWdlcyBSb3V0ZXIsIHNvIHdlIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAgcGVuZGluZzogZmFsc2UsXG59KVxuXG5leHBvcnQgY29uc3QgdXNlTGlua1N0YXR1cyA9ICgpID0+IHtcbiAgLy8gVGhpcyBiZWhhdmlvdXIgaXMgbGlrZSBSZWFjdCdzIHVzZUZvcm1TdGF0dXMuIFdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgdW5kZXJcbiAgLy8gYSA8Zm9ybT4gdGFnLCBpdCB3aWxsIGdldCB0aGUgZGVmYXVsdCB2YWx1ZSwgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvci5cbiAgcmV0dXJuIHVzZUNvbnRleHQoTGlua1N0YXR1c0NvbnRleHQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiJdLCJuYW1lcyI6WyJ1c2VMaW5rU3RhdHVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsIndpbmRvdyIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiY2F0Y2giLCJlcnIiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJvbk5hdmlnYXRlIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJoYXNBdHRyaWJ1dGUiLCJwcmV2ZW50RGVmYXVsdCIsImxvY2F0aW9uIiwibmF2aWdhdGUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyb3V0ZXJTY3JvbGwiLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwiTGluayIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsIkxpbmtDb21wb25lbnQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImNoaWxkcmVuIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaFByb3AiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0UHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwicmVzdFByb3BzIiwiYSIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwicHJlZmV0Y2hFbmFibGVkIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwicHJldmlvdXNIcmVmIiwidXNlUmVmIiwicHJldmlvdXNBcyIsImNoaWxkIiwiY29uc29sZSIsIndhcm4iLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJyZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0SW50ZXJzZWN0aW9uV2l0aFJlc2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsImN1cnJlbnQiLCJzZXRSZWYiLCJ1c2VNZXJnZWRSZWYiLCJ1c2VFZmZlY3QiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlQiLCJpc0Fic29sdXRlVXJsIiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImVycm9yT25jZSIsImNsb25lRWxlbWVudCIsIkxpbmtTdGF0dXNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInBlbmRpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(pages-dir-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function';\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OzttREErRmdCQTs7O2VBQUFBOzs7bUNBL0Z5QztpREFJbEQ7QUFxQlAsTUFBTUMsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUVoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQXVCLEVBQUU7QUFFL0IsU0FBU0MsZUFBZUMsT0FBb0M7SUFDMUQsTUFBTUMsS0FBSztRQUNUQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNoQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FDMUIsQ0FBQ0MsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUUzRCxJQUFJSztJQUVKLElBQUlILFVBQVU7UUFDWkcsV0FBV1osVUFBVWEsR0FBRyxDQUFDSjtRQUN6QixJQUFJRyxVQUFVO1lBQ1osT0FBT0E7UUFDVDtJQUNGO0lBRUEsTUFBTUUsV0FBVyxJQUFJYjtJQUNyQixNQUFNYyxXQUFXLElBQUloQixxQkFBcUIsQ0FBQ2lCO1FBQ3pDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxXQUFXTCxTQUFTRCxHQUFHLENBQUNLLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN6QkYsU0FBU0U7WUFDWDtRQUNGO0lBQ0YsR0FBR2pCO0lBQ0hRLFdBQVc7UUFDVFA7UUFDQVU7UUFDQUQ7SUFDRjtJQUVBWixPQUFPc0IsSUFBSSxDQUFDbkI7SUFDWkwsVUFBVXlCLEdBQUcsQ0FBQ3BCLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTYyxRQUNQQyxPQUFnQixFQUNoQlIsUUFBeUIsRUFDekJmLE9BQW9DO0lBRXBDLE1BQU0sRUFBRUMsRUFBRSxFQUFFVSxRQUFRLEVBQUVELFFBQVEsRUFBRSxHQUFHWCxlQUFlQztJQUNsRFUsU0FBU1csR0FBRyxDQUFDRSxTQUFTUjtJQUV0QkosU0FBU1csT0FBTyxDQUFDQztJQUNqQixPQUFPLFNBQVNDO1FBQ2RkLFNBQVNlLE1BQU0sQ0FBQ0Y7UUFDaEJaLFNBQVNhLFNBQVMsQ0FBQ0Q7UUFFbkIsdURBQXVEO1FBQ3ZELElBQUliLFNBQVNnQixJQUFJLEtBQUssR0FBRztZQUN2QmYsU0FBU2dCLFVBQVU7WUFDbkIvQixVQUFVNkIsTUFBTSxDQUFDeEI7WUFDakIsTUFBTTJCLFFBQVE5QixPQUFPK0IsU0FBUyxDQUM1QixDQUFDdEIsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUUzRCxJQUFJeUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ2Q5QixPQUFPZ0MsTUFBTSxDQUFDRixPQUFPO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU25DLGdCQUFtQyxLQUlqQztJQUppQyxNQUNqRHNDLE9BQU8sRUFDUDNCLFVBQVUsRUFDVjRCLFFBQVEsRUFDUSxHQUppQztJQUtqRCxNQUFNQyxhQUFzQkQsWUFBWSxDQUFDdEM7SUFFekMsTUFBTSxDQUFDd0MsU0FBU0MsV0FBVyxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxRQUFBQSxFQUFTO0lBQ3ZDLE1BQU1DLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQWlCO0lBQ3BDLE1BQU1DLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLFdBQUFBLEVBQVksQ0FBQ2pCO1FBQzlCYyxXQUFXSSxPQUFPLEdBQUdsQjtJQUN2QixHQUFHLEVBQUU7SUFFTG1CLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7UUFDUixJQUFJaEQseUJBQXlCO1lBQzNCLElBQUl1QyxjQUFjQyxTQUFTO1lBRTNCLE1BQU1YLFVBQVVjLFdBQVdJLE9BQU87WUFDbEMsSUFBSWxCLFdBQVdBLFFBQVFvQixPQUFPLEVBQUU7Z0JBQzlCLE1BQU1uQixZQUFZRixRQUNoQkMsU0FDQSxDQUFDTixZQUFjQSxhQUFha0IsV0FBV2xCLFlBQ3ZDO29CQUFFZixJQUFJLEVBQUU2QixXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTVSxPQUFPO29CQUFFckM7Z0JBQVc7Z0JBR3ZDLE9BQU9vQjtZQUNUO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ1UsU0FBUztnQkFDWixNQUFNVSxlQUFlQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CLElBQU1WLFdBQVc7Z0JBQzFELE9BQU8sSUFBTVcsQ0FBQUEsR0FBQUEscUJBQUFBLGtCQUFBQSxFQUFtQkY7WUFDbEM7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNYO1FBQVk3QjtRQUFZMkI7UUFBU0c7UUFBU0csV0FBV0ksT0FBTztLQUFDO0lBRWpFLE1BQU1NLGVBQWVQLENBQUFBLEdBQUFBLE9BQUFBLFdBQUFBLEVBQVk7UUFDL0JMLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQUNJO1FBQVlMO1FBQVNhO0tBQWE7QUFDNUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXHVzZS1pbnRlcnNlY3Rpb24udHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIHJlcXVlc3RJZGxlQ2FsbGJhY2ssXG4gIGNhbmNlbElkbGVDYWxsYmFjayxcbn0gZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0gUGljazxcbiAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0LFxuICAncm9vdE1hcmdpbicgfCAncm9vdCdcbj5cblxudHlwZSBVc2VJbnRlcnNlY3Rpb24gPSB7IGRpc2FibGVkPzogYm9vbGVhbiB9ICYgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ICYge1xuICAgIHJvb3RSZWY/OiBSZWFjdC5SZWZPYmplY3Q8SFRNTEVsZW1lbnQgfCBudWxsPiB8IG51bGxcbiAgfVxudHlwZSBPYnNlcnZlQ2FsbGJhY2sgPSAoaXNWaXNpYmxlOiBib29sZWFuKSA9PiB2b2lkXG50eXBlIElkZW50aWZpZXIgPSB7XG4gIHJvb3Q6IEVsZW1lbnQgfCBEb2N1bWVudCB8IG51bGxcbiAgbWFyZ2luOiBzdHJpbmdcbn1cbnR5cGUgT2JzZXJ2ZXIgPSB7XG4gIGlkOiBJZGVudGlmaWVyXG4gIG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICBlbGVtZW50czogTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz5cbn1cblxuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcblxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcDxJZGVudGlmaWVyLCBPYnNlcnZlcj4oKVxuY29uc3QgaWRMaXN0OiBJZGVudGlmaWVyW10gPSBbXVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpOiBPYnNlcnZlciB7XG4gIGNvbnN0IGlkID0ge1xuICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgIG1hcmdpbjogb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnLFxuICB9XG4gIGNvbnN0IGV4aXN0aW5nID0gaWRMaXN0LmZpbmQoXG4gICAgKG9iaikgPT4gb2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luXG4gIClcbiAgbGV0IGluc3RhbmNlOiBPYnNlcnZlciB8IHVuZGVmaW5lZFxuXG4gIGlmIChleGlzdGluZykge1xuICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZylcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+KClcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIG9wdGlvbnMpXG4gIGluc3RhbmNlID0ge1xuICAgIGlkLFxuICAgIG9ic2VydmVyLFxuICAgIGVsZW1lbnRzLFxuICB9XG5cbiAgaWRMaXN0LnB1c2goaWQpXG4gIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVDYWxsYmFjayxcbiAgb3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKVxuICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spXG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCk6IHZvaWQge1xuICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KVxuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuXG4gICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpXG4gICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoXG4gICAgICAgIChvYmopID0+IG9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpblxuICAgICAgKVxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgaWRMaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbjxUIGV4dGVuZHMgRWxlbWVudD4oe1xuICByb290UmVmLFxuICByb290TWFyZ2luLFxuICBkaXNhYmxlZCxcbn06IFVzZUludGVyc2VjdGlvbik6IFsoZWxlbWVudDogVCB8IG51bGwpID0+IHZvaWQsIGJvb2xlYW4sICgpID0+IHZvaWRdIHtcbiAgY29uc3QgaXNEaXNhYmxlZDogYm9vbGVhbiA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlclxuXG4gIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBlbGVtZW50UmVmID0gdXNlUmVmPFQgfCBudWxsPihudWxsKVxuICBjb25zdCBzZXRFbGVtZW50ID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XG4gICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudFxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuXG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICBjb25zdCB1bm9ic2VydmUgPSBvYnNlcnZlKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgKGlzVmlzaWJsZSkgPT4gaXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSxcbiAgICAgICAgICB7IHJvb3Q6IHJvb3RSZWY/LmN1cnJlbnQsIHJvb3RNYXJnaW4gfVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRWaXNpYmxlKHRydWUpKVxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjaylcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaXNEaXNhYmxlZCwgcm9vdE1hcmdpbiwgcm9vdFJlZiwgdmlzaWJsZSwgZWxlbWVudFJlZi5jdXJyZW50XSlcblxuICBjb25zdCByZXNldFZpc2libGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0VmlzaWJsZShmYWxzZSlcbiAgfSwgW10pXG5cbiAgcmV0dXJuIFtzZXRFbGVtZW50LCB2aXNpYmxlLCByZXNldFZpc2libGVdXG59XG4iXSwibmFtZXMiOlsidXNlSW50ZXJzZWN0aW9uIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDhCO0FBU3ZDLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUU3QyxtRkFBbUY7SUFDbkYseUVBQXlFO0lBQ3pFLGlHQUFpRztJQUNqRyw4RkFBOEY7SUFDOUYsZ0RBQWdEO0lBQ2hELG1HQUFtRztJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBQUEsRUFDTCxDQUFDQztRQUNDLElBQUlBLFlBQVksTUFBTTtZQUNwQixNQUFNQyxhQUFhTCxTQUFTSSxPQUFPO1lBQ25DLElBQUlDLFlBQVk7Z0JBQ2RMLFNBQVNJLE9BQU8sR0FBRztnQkFDbkJDO1lBQ0Y7WUFDQSxNQUFNQyxhQUFhSixTQUFTRSxPQUFPO1lBQ25DLElBQUlFLFlBQVk7Z0JBQ2RKLFNBQVNFLE9BQU8sR0FBRztnQkFDbkJFO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSVIsTUFBTTtnQkFDUkUsU0FBU0ksT0FBTyxHQUFHRyxTQUFTVCxNQUFNTTtZQUNwQztZQUNBLElBQUlMLE1BQU07Z0JBQ1JHLFNBQVNFLE9BQU8sR0FBR0csU0FBU1IsTUFBTUs7WUFDcEM7UUFDRjtJQUNGLEdBQ0E7UUFBQ047UUFBTUM7S0FBSztBQUVoQjtBQUVBLFNBQVNRLFNBQ1BULElBQWdDLEVBQ2hDTSxPQUFpQjtJQUVqQixJQUFJLE9BQU9OLFNBQVMsWUFBWTtRQUM5QixNQUFNVSxVQUFVVixLQUFLTTtRQUNyQixJQUFJLE9BQU9JLFlBQVksWUFBWTtZQUNqQyxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPLElBQU1WLEtBQUs7UUFDcEI7SUFDRixPQUFPO1FBQ0xBLEtBQUtNLE9BQU8sR0FBR0E7UUFDZixPQUFPO1lBQ0xOLEtBQUtNLE9BQU8sR0FBRztRQUNqQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXHVzZS1tZXJnZWQtcmVmLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYsIHR5cGUgUmVmIH0gZnJvbSAncmVhY3QnXG5cbi8vIFRoaXMgaXMgYSBjb21wYXRpYmlsaXR5IGhvb2sgdG8gc3VwcG9ydCBSZWFjdCAxOCBhbmQgMTkgcmVmcy5cbi8vIEluIDE5LCBhIGNsZWFudXAgZnVuY3Rpb24gZnJvbSByZWZzIG1heSBiZSByZXR1cm5lZC5cbi8vIEluIDE4LCByZXR1cm5pbmcgYSBjbGVhbnVwIGZ1bmN0aW9uIGNyZWF0ZXMgYSB3YXJuaW5nLlxuLy8gU2luY2Ugd2UgdGFrZSB1c2Vyc3BhY2UgcmVmcywgd2UgZG9uJ3Qga25vdyBhaGVhZCBvZiB0aW1lIGlmIGEgY2xlYW51cCBmdW5jdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuLy8gVGhpcyBpbXBsZW1lbnRzIGNsZWFudXAgZnVuY3Rpb25zIHdpdGggdGhlIG9sZCBiZWhhdmlvciBpbiAxOC5cbi8vIFdlIGtub3cgcmVmcyBhcmUgYWx3YXlzIGNhbGxlZCBhbHRlcm5hdGluZyB3aXRoIGBudWxsYCBhbmQgdGhlbiBgVGAuXG4vLyBTbyBhIGNhbGwgd2l0aCBgbnVsbGAgbWVhbnMgd2UgbmVlZCB0byBjYWxsIHRoZSBwcmV2aW91cyBjbGVhbnVwIGZ1bmN0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBSZWY8VEVsZW1lbnQ+LFxuICByZWZCOiBSZWY8VEVsZW1lbnQ+XG4pOiBSZWY8VEVsZW1lbnQ+IHtcbiAgY29uc3QgY2xlYW51cEEgPSB1c2VSZWY8KCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbClcbiAgY29uc3QgY2xlYW51cEIgPSB1c2VSZWY8KCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbClcblxuICAvLyBOT1RFOiBJbiB0aGVvcnksIHdlIGNvdWxkIHNraXAgdGhlIHdyYXBwaW5nIGlmIG9ubHkgb25lIG9mIHRoZSByZWZzIGlzIG5vbi1udWxsLlxuICAvLyAodGhpcyBoYXBwZW5zIG9mdGVuIGlmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHJlZiB0byBMaW5rL0Zvcm0vSW1hZ2UpXG4gIC8vIEJ1dCB0aGlzIGNhbiBjYXVzZSB1cyB0byBsZWFrIGEgY2xlYW51cC1yZWYgaW50byB1c2VyIGNvZGUgKGUuZy4gdmlhIGA8TGluayBsZWdhY3lCZWhhdmlvcj5gKSxcbiAgLy8gYW5kIHRoZSB1c2VyIG1pZ2h0IHBhc3MgdGhhdCByZWYgaW50byByZWYtbWVyZ2luZyBsaWJyYXJ5IHRoYXQgZG9lc24ndCBzdXBwb3J0IGNsZWFudXAgcmVmc1xuICAvLyAoYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiB1cGRhdGVkIGZvciBSZWFjdCAxOSlcbiAgLy8gd2hpY2ggY2FuIHRoZW4gY2F1c2UgdGhpbmdzIHRvIGJsb3cgdXAsIGJlY2F1c2UgYSBjbGVhbnVwLXJldHVybmluZyByZWYgZ2V0cyBjYWxsZWQgd2l0aCBgbnVsbGAuXG4gIC8vIFNvIGluIHByYWN0aWNlLCBpdCdzIHNhZmVyIHRvIGJlIGRlZmVuc2l2ZSBhbmQgYWx3YXlzIHdyYXAgdGhlIHJlZiwgZXZlbiBvbiBSZWFjdCAxOS5cbiAgcmV0dXJuIHVzZUNhbGxiYWNrKFxuICAgIChjdXJyZW50OiBURWxlbWVudCB8IG51bGwpOiB2b2lkID0+IHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbkEgPSBjbGVhbnVwQS5jdXJyZW50XG4gICAgICAgIGlmIChjbGVhbnVwRm5BKSB7XG4gICAgICAgICAgY2xlYW51cEEuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBjbGVhbnVwRm5BKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbnVwRm5CID0gY2xlYW51cEIuY3VycmVudFxuICAgICAgICBpZiAoY2xlYW51cEZuQikge1xuICAgICAgICAgIGNsZWFudXBCLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgY2xlYW51cEZuQigpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWZBKSB7XG4gICAgICAgICAgY2xlYW51cEEuY3VycmVudCA9IGFwcGx5UmVmKHJlZkEsIGN1cnJlbnQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkIpIHtcbiAgICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gYXBwbHlSZWYocmVmQiwgY3VycmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW3JlZkEsIHJlZkJdXG4gIClcbn1cblxuZnVuY3Rpb24gYXBwbHlSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBOb25OdWxsYWJsZTxSZWY8VEVsZW1lbnQ+PixcbiAgY3VycmVudDogVEVsZW1lbnRcbikge1xuICBpZiAodHlwZW9mIHJlZkEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjbGVhbnVwID0gcmVmQShjdXJyZW50KVxuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsZWFudXBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgpID0+IHJlZkEobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVmQS5jdXJyZW50ID0gY3VycmVudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWZBLmN1cnJlbnQgPSBudWxsXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlTWVyZ2VkUmVmIiwicmVmQSIsInJlZkIiLCJjbGVhbnVwQSIsInVzZVJlZiIsImNsZWFudXBCIiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwiY2xlYW51cEZuQSIsImNsZWFudXBGbkIiLCJhcHBseVJlZiIsImNsZWFudXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={114:function(e){function assertPath(e){if(typeof e!==\"string\"){throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(e))}}function normalizeStringPosix(e,r){var t=\"\";var i=0;var n=-1;var a=0;var f;for(var l=0;l<=e.length;++l){if(l<e.length)f=e.charCodeAt(l);else if(f===47)break;else f=47;if(f===47){if(n===l-1||a===1){}else if(n!==l-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var s=t.lastIndexOf(\"/\");if(s!==t.length-1){if(s===-1){t=\"\";i=0}else{t=t.slice(0,s);i=t.length-1-t.lastIndexOf(\"/\")}n=l;a=0;continue}}else if(t.length===2||t.length===1){t=\"\";i=0;n=l;a=0;continue}}if(r){if(t.length>0)t+=\"/..\";else t=\"..\";i=2}}else{if(t.length>0)t+=\"/\"+e.slice(n+1,l);else t=e.slice(n+1,l);i=l-n-1}n=l;a=0}else if(f===46&&a!==-1){++a}else{a=-1}}return t}function _format(e,r){var t=r.dir||r.root;var i=r.base||(r.name||\"\")+(r.ext||\"\");if(!t){return i}if(t===r.root){return t+i}return t+e+i}var r={resolve:function resolve(){var e=\"\";var r=false;var t;for(var i=arguments.length-1;i>=-1&&!r;i--){var n;if(i>=0)n=arguments[i];else{if(t===undefined)t=\"\";n=t}assertPath(n);if(n.length===0){continue}e=n+\"/\"+e;r=n.charCodeAt(0)===47}e=normalizeStringPosix(e,!r);if(r){if(e.length>0)return\"/\"+e;else return\"/\"}else if(e.length>0){return e}else{return\".\"}},normalize:function normalize(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0)===47;var t=e.charCodeAt(e.length-1)===47;e=normalizeStringPosix(e,!r);if(e.length===0&&!r)e=\".\";if(e.length>0&&t)e+=\"/\";if(r)return\"/\"+e;return e},isAbsolute:function isAbsolute(e){assertPath(e);return e.length>0&&e.charCodeAt(0)===47},join:function join(){if(arguments.length===0)return\".\";var e;for(var t=0;t<arguments.length;++t){var i=arguments[t];assertPath(i);if(i.length>0){if(e===undefined)e=i;else e+=\"/\"+i}}if(e===undefined)return\".\";return r.normalize(e)},relative:function relative(e,t){assertPath(e);assertPath(t);if(e===t)return\"\";e=r.resolve(e);t=r.resolve(t);if(e===t)return\"\";var i=1;for(;i<e.length;++i){if(e.charCodeAt(i)!==47)break}var n=e.length;var a=n-i;var f=1;for(;f<t.length;++f){if(t.charCodeAt(f)!==47)break}var l=t.length;var s=l-f;var o=a<s?a:s;var u=-1;var h=0;for(;h<=o;++h){if(h===o){if(s>o){if(t.charCodeAt(f+h)===47){return t.slice(f+h+1)}else if(h===0){return t.slice(f+h)}}else if(a>o){if(e.charCodeAt(i+h)===47){u=h}else if(h===0){u=0}}break}var c=e.charCodeAt(i+h);var v=t.charCodeAt(f+h);if(c!==v)break;else if(c===47)u=h}var g=\"\";for(h=i+u+1;h<=n;++h){if(h===n||e.charCodeAt(h)===47){if(g.length===0)g+=\"..\";else g+=\"/..\"}}if(g.length>0)return g+t.slice(f+u);else{f+=u;if(t.charCodeAt(f)===47)++f;return t.slice(f)}},_makeLong:function _makeLong(e){return e},dirname:function dirname(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0);var t=r===47;var i=-1;var n=true;for(var a=e.length-1;a>=1;--a){r=e.charCodeAt(a);if(r===47){if(!n){i=a;break}}else{n=false}}if(i===-1)return t?\"/\":\".\";if(t&&i===1)return\"//\";return e.slice(0,i)},basename:function basename(e,r){if(r!==undefined&&typeof r!==\"string\")throw new TypeError('\"ext\" argument must be a string');assertPath(e);var t=0;var i=-1;var n=true;var a;if(r!==undefined&&r.length>0&&r.length<=e.length){if(r.length===e.length&&r===e)return\"\";var f=r.length-1;var l=-1;for(a=e.length-1;a>=0;--a){var s=e.charCodeAt(a);if(s===47){if(!n){t=a+1;break}}else{if(l===-1){n=false;l=a+1}if(f>=0){if(s===r.charCodeAt(f)){if(--f===-1){i=a}}else{f=-1;i=l}}}}if(t===i)i=l;else if(i===-1)i=e.length;return e.slice(t,i)}else{for(a=e.length-1;a>=0;--a){if(e.charCodeAt(a)===47){if(!n){t=a+1;break}}else if(i===-1){n=false;i=a+1}}if(i===-1)return\"\";return e.slice(t,i)}},extname:function extname(e){assertPath(e);var r=-1;var t=0;var i=-1;var n=true;var a=0;for(var f=e.length-1;f>=0;--f){var l=e.charCodeAt(f);if(l===47){if(!n){t=f+1;break}continue}if(i===-1){n=false;i=f+1}if(l===46){if(r===-1)r=f;else if(a!==1)a=1}else if(r!==-1){a=-1}}if(r===-1||i===-1||a===0||a===1&&r===i-1&&r===t+1){return\"\"}return e.slice(r,i)},format:function format(e){if(e===null||typeof e!==\"object\"){throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof e)}return _format(\"/\",e)},parse:function parse(e){assertPath(e);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(e.length===0)return r;var t=e.charCodeAt(0);var i=t===47;var n;if(i){r.root=\"/\";n=1}else{n=0}var a=-1;var f=0;var l=-1;var s=true;var o=e.length-1;var u=0;for(;o>=n;--o){t=e.charCodeAt(o);if(t===47){if(!s){f=o+1;break}continue}if(l===-1){s=false;l=o+1}if(t===46){if(a===-1)a=o;else if(u!==1)u=1}else if(a!==-1){u=-1}}if(a===-1||l===-1||u===0||u===1&&a===l-1&&a===f+1){if(l!==-1){if(f===0&&i)r.base=r.name=e.slice(1,l);else r.base=r.name=e.slice(f,l)}}else{if(f===0&&i){r.name=e.slice(1,a);r.base=e.slice(1,l)}else{r.name=e.slice(f,a);r.base=e.slice(f,l)}r.ext=e.slice(a,l)}if(f>0)r.dir=e.slice(0,f-1);else if(i)r.dir=\"/\";return r},sep:\"/\",delimiter:\":\",win32:null,posix:null};r.posix=r;e.exports=r}};var r={};function __nccwpck_require__(t){var i=r[t];if(i!==undefined){return i.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(114);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsdUJBQXVCLHdCQUF3QiwyRUFBMkUsbUNBQW1DLFNBQVMsUUFBUSxTQUFTLFFBQVEsTUFBTSxZQUFZLFlBQVksS0FBSyxnQ0FBZ0MscUJBQXFCLFVBQVUsV0FBVyxvQkFBb0Isd0JBQXdCLG9GQUFvRixlQUFlLHlCQUF5QixtQkFBbUIsV0FBVyxLQUFLLElBQUksS0FBSyxlQUFlLGdDQUFnQyxJQUFJLElBQUksVUFBVSxvQ0FBb0MsS0FBSyxJQUFJLElBQUksSUFBSSxVQUFVLE1BQU0sdUJBQXVCLFlBQVksS0FBSyxLQUFLLG9DQUFvQyxzQkFBc0IsUUFBUSxJQUFJLElBQUksd0JBQXdCLElBQUksS0FBSyxNQUFNLFNBQVMsc0JBQXNCLG9CQUFvQix1Q0FBdUMsT0FBTyxTQUFTLGVBQWUsV0FBVyxhQUFhLE9BQU8sMkJBQTJCLFNBQVMsWUFBWSxNQUFNLDZCQUE2QixVQUFVLEtBQUssTUFBTSx1QkFBdUIsS0FBSyxzQkFBc0IsSUFBSSxjQUFjLGlCQUFpQixTQUFTLFVBQVUsdUJBQXVCLDZCQUE2QixNQUFNLDBCQUEwQixlQUFlLG9CQUFvQixTQUFTLEtBQUssV0FBVyxpQ0FBaUMsY0FBYywwQkFBMEIsMkJBQTJCLG9DQUFvQyw2QkFBNkIsMEJBQTBCLHdCQUF3QixpQkFBaUIsU0FBUyxtQ0FBbUMsY0FBYyx3Q0FBd0Msc0JBQXNCLGtDQUFrQyxNQUFNLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLGNBQWMsZUFBZSxxQkFBcUIsZUFBZSwyQkFBMkIsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsa0JBQWtCLGVBQWUsZUFBZSxrQkFBa0IsUUFBUSxLQUFLLFdBQVcsS0FBSyw4QkFBOEIsZUFBZSxVQUFVLFFBQVEsS0FBSyxXQUFXLEtBQUssOEJBQThCLGVBQWUsVUFBVSxjQUFjLFNBQVMsUUFBUSxLQUFLLEtBQUssS0FBSyxVQUFVLFFBQVEsMkJBQTJCLHNCQUFzQixlQUFlLHFCQUFxQixhQUFhLDJCQUEyQixJQUFJLGVBQWUsS0FBSyxNQUFNLHdCQUF3Qix3QkFBd0IsZUFBZSxtQkFBbUIsU0FBUyxZQUFZLEtBQUssS0FBSyxnQ0FBZ0Msd0JBQXdCLGVBQWUsb0NBQW9DLEtBQUssS0FBSyw0QkFBNEIsbUJBQW1CLGlDQUFpQyxTQUFTLDZCQUE2QixjQUFjLDBCQUEwQixzQkFBc0IsYUFBYSxTQUFTLFdBQVcscUJBQXFCLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLElBQUksT0FBTyxLQUFLLFNBQVMsMkJBQTJCLHVCQUF1QixvQkFBb0IsaUNBQWlDLDZGQUE2RixjQUFjLFFBQVEsU0FBUyxXQUFXLE1BQU0sa0RBQWtELHVDQUF1QyxpQkFBaUIsU0FBUyxpQkFBaUIsS0FBSyxLQUFLLHNCQUFzQixXQUFXLE9BQU8sTUFBTSxPQUFPLEtBQUssV0FBVyxRQUFRLE1BQU0sU0FBUyx3QkFBd0IsYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPLGFBQWEsMEJBQTBCLG9CQUFvQixLQUFLLGlCQUFpQixLQUFLLEtBQUsseUJBQXlCLE9BQU8sTUFBTSxPQUFPLGdCQUFnQixRQUFRLE9BQU8sbUJBQW1CLHFCQUFxQiw2QkFBNkIsY0FBYyxTQUFTLFFBQVEsU0FBUyxXQUFXLFFBQVEscUJBQXFCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFNBQVMsb0JBQW9CLDJCQUEyQixrQ0FBa0MsaUdBQWlHLHNCQUFzQix5QkFBeUIsY0FBYyxPQUFPLHVDQUF1Qyx5QkFBeUIsc0JBQXNCLGFBQWEsTUFBTSxNQUFNLFdBQVcsSUFBSSxLQUFLLElBQUksU0FBUyxRQUFRLFNBQVMsV0FBVyxpQkFBaUIsUUFBUSxLQUFLLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFdBQVcsdUNBQXVDLGlDQUFpQyxLQUFLLGFBQWEsb0JBQW9CLG9CQUFvQixLQUFLLG9CQUFvQixvQkFBb0IsbUJBQW1CLDRCQUE0QixvQkFBb0IsU0FBUyw4Q0FBOEMsVUFBVSxjQUFjLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHBhdGgtYnJvd3NlcmlmeVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcc2hhcmVkXFxsaWJcXGFtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsbUJBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxhbXAtbW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cbiJdLCJuYW1lcyI6WyJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                const srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVNQSxPQUFtQjtlQUFuQjs7SUExTGdCQSxXQUFXO2VBQVhBOzs7Ozs7NkVBWDRCO2lGQUN6QjtxREFDYTs2REFDRztxQ0FDUDtzQ0FDSDtBQU1sQixTQUFTQSxZQUFZQyxTQUFpQjtJQUFqQkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO3NCQUFDLHFCQUFDQyxRQUFBQTtZQUFLQyxTQUFRO1dBQVk7S0FBYTtJQUNyRCxJQUFJLENBQUNILFdBQVc7UUFDZEMsS0FBS0csSUFBSSxlQUNQLHFCQUFDRixRQUFBQTtZQUFLRyxNQUFLO1lBQVdDLFNBQVE7V0FBeUI7SUFFM0Q7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBU00saUJBQ1BDLElBQW9DLEVBQ3BDQyxLQUEyQztJQUUzQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQzFELE9BQU9EO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUMsTUFBTUMsSUFBSSxLQUFLQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsRUFBRTtRQUNqQyxPQUFPSixLQUFLSyxNQUFNLENBQ2hCLE9BQ0FGLE9BQUssQ0FBQ0csUUFBUSxDQUFDQyxPQUFPLENBQUNOLE1BQU1PLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQ2pELENBRUVDLGNBQ0FDO1lBRUEsSUFDRSxPQUFPQSxrQkFBa0IsWUFDekIsT0FBT0Esa0JBQWtCLFVBQ3pCO2dCQUNBLE9BQU9EO1lBQ1Q7WUFDQSxPQUFPQSxhQUFhTixNQUFNLENBQUNPO1FBQzdCLEdBQ0EsRUFBRTtJQUdSO0lBQ0EsT0FBT1osS0FBS0ssTUFBTSxDQUFDSjtBQUNyQjtBQUVBLE1BQU1ZLFlBQVk7SUFBQztJQUFRO0lBQWE7SUFBVztDQUFXO0FBRTlEOzs7O0FBSUEsR0FDQSxTQUFTQztJQUNQLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFBTUMsT0FBTyxJQUFJRDtJQUNqQixNQUFNRSxZQUFZLElBQUlGO0lBQ3RCLE1BQU1HLGlCQUFzRCxDQUFDO0lBRTdELE9BQU8sQ0FBQ0M7UUFDTixJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsU0FBUztRQUViLElBQUlGLEVBQUVHLEdBQUcsSUFBSSxPQUFPSCxFQUFFRyxHQUFHLEtBQUssWUFBWUgsRUFBRUcsR0FBRyxDQUFDQyxPQUFPLENBQUMsT0FBTyxHQUFHO1lBQ2hFRixTQUFTO1lBQ1QsTUFBTUMsTUFBTUgsRUFBRUcsR0FBRyxDQUFDRSxLQUFLLENBQUNMLEVBQUVHLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLE9BQU87WUFDN0MsSUFBSVQsS0FBS1csR0FBRyxDQUFDSCxNQUFNO2dCQUNqQkYsV0FBVztZQUNiLE9BQU87Z0JBQ0xOLEtBQUtZLEdBQUcsQ0FBQ0o7WUFDWDtRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLE9BQVFILEVBQUVsQixJQUFJO1lBQ1osS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSWUsS0FBS1MsR0FBRyxDQUFDTixFQUFFbEIsSUFBSSxHQUFHO29CQUNwQm1CLFdBQVc7Z0JBQ2IsT0FBTztvQkFDTEosS0FBS1UsR0FBRyxDQUFDUCxFQUFFbEIsSUFBSTtnQkFDakI7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUssSUFBSTBCLElBQUksR0FBR0MsTUFBTWhCLFVBQVVpQixNQUFNLEVBQUVGLElBQUlDLEtBQUtELElBQUs7b0JBQ3BELE1BQU1HLFdBQVdsQixTQUFTLENBQUNlLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1IsRUFBRVosS0FBSyxDQUFDd0IsY0FBYyxDQUFDRCxXQUFXO29CQUV2QyxJQUFJQSxhQUFhLFdBQVc7d0JBQzFCLElBQUliLFVBQVVRLEdBQUcsQ0FBQ0ssV0FBVzs0QkFDM0JWLFdBQVc7d0JBQ2IsT0FBTzs0QkFDTEgsVUFBVVMsR0FBRyxDQUFDSTt3QkFDaEI7b0JBQ0YsT0FBTzt3QkFDTCxNQUFNRSxXQUFXYixFQUFFWixLQUFLLENBQUN1QixTQUFTO3dCQUNsQyxNQUFNRyxhQUFhZixjQUFjLENBQUNZLFNBQVMsSUFBSSxJQUFJZjt3QkFDbkQsSUFBS2UsQ0FBQUEsYUFBYSxVQUFVLENBQUNULE1BQUFBLENBQUssSUFBTVksV0FBV1IsR0FBRyxDQUFDTyxXQUFXOzRCQUNoRVosV0FBVzt3QkFDYixPQUFPOzRCQUNMYSxXQUFXUCxHQUFHLENBQUNNOzRCQUNmZCxjQUFjLENBQUNZLFNBQVMsR0FBR0c7d0JBQzdCO29CQUNGO2dCQUNGO2dCQUNBO1FBQ0o7UUFFQSxPQUFPYjtJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTYyxpQkFDUEMsb0JBQW9ELEVBQ3BENUIsS0FBUTtJQUVSLE1BQU0sRUFBRWhCLFNBQVMsRUFBRSxHQUFHZ0I7SUFDdEIsT0FBTzRCLHFCQUNKMUIsTUFBTSxDQUFDWCxrQkFBa0IsRUFBRSxFQUMzQnNDLE9BQU8sR0FDUGhDLE1BQU0sQ0FBQ2QsWUFBWUMsV0FBVzZDLE9BQU8sSUFDckNDLE1BQU0sQ0FBQ3hCLFVBQ1B1QixPQUFPLEdBQ1BFLEdBQUcsQ0FBQyxDQUFDQyxHQUE0Qlo7UUFDaEMsTUFBTUwsTUFBTWlCLEVBQUVqQixHQUFHLElBQUlLO1FBQ3JCLElBQ0VhLEtBRVVqRCxFQUNWLEVBa0JEO1FBQ0QsSUFBSWlELElBQW9CLEVBQW9CO1lBQzFDLHlEQUF5RDtZQUN6RCxJQUFJRCxFQUFFdEMsSUFBSSxLQUFLLFlBQVlzQyxFQUFFaEMsS0FBSyxDQUFDLE9BQU8sS0FBSyx1QkFBdUI7Z0JBQ3BFLE1BQU0yQyxhQUFhWCxFQUFFaEMsS0FBSyxDQUFDLE1BQU0sR0FDNUIsNEJBQXlCZ0MsRUFBRWhDLEtBQUssQ0FBQyxNQUFNLEdBQUMsTUFDeEM7Z0JBQ0w0QyxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUNHLG1EQUFnREQsYUFBVztZQUVoRSxPQUFPLElBQUlYLEVBQUV0QyxJQUFJLEtBQUssVUFBVXNDLEVBQUVoQyxLQUFLLENBQUMsTUFBTSxLQUFLLGNBQWM7Z0JBQy9ENEMsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyx3RkFBcUZaLEVBQUVoQyxLQUFLLENBQUMsT0FBTyxHQUFDO1lBRTFHO1FBQ0Y7UUFDQSxxQkFBT0wsT0FBQUEsT0FBSyxDQUFDK0MsWUFBWSxDQUFDVixHQUFHO1lBQUVqQjtRQUFJO0lBQ3JDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxjQUFjLEtBQTJDO0lBQTNDLE1BQUVkLFFBQVEsRUFBaUMsR0FBM0M7SUFDWixNQUFNNkMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MseUJBQUFBLGVBQWU7SUFDM0MsTUFBTUMsY0FBY0YsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0csaUNBQUFBLGtCQUFrQjtJQUNqRCxxQkFDRSxxQkFBQ0MsWUFBQUEsT0FBTTtRQUNMQyx5QkFBeUJ6QjtRQUN6QnNCLGFBQWFBO1FBQ2JqRSxXQUFXcUUsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBWVA7a0JBRXRCN0M7O0FBR1A7S0FaUzRDO01BY1QsV0FBZUEiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxoZWFkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAtbW9kZSdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiBrZXk9XCJjaGFyc2V0XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKFxuICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIGtleT1cInZpZXdwb3J0XCIgLz5cbiAgICApXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bWJlciB8IHN0cmluZ1xuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzPFQgZXh0ZW5kcyB7fSAmIFdpdGhJbkFtcE1vZGU+KFxuICBoZWFkQ2hpbGRyZW5FbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogVFxuKSB7XG4gIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wc1xuICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHNcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFpbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJywgJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LyddLnNvbWUoXG4gICAgICAgICAgICAodXJsKSA9PiBjLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4uKGMucHJvcHMgfHwge30pIH1cbiAgICAgICAgICBuZXdQcm9wc1snZGF0YS1ocmVmJ10gPSBuZXdQcm9wc1snaHJlZiddXG4gICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgLy8gQWRkIHRoaXMgYXR0cmlidXRlIHRvIG1ha2UgaXQgZWFzeSB0byBpZGVudGlmeSBvcHRpbWl6ZWQgdGFnc1xuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLW9wdGltaXplZC1mb250cyddID0gdHJ1ZVxuXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIC8vIG9taXQgSlNPTi1MRCBzdHJ1Y3R1cmVkIGRhdGEgc25pcHBldHMgZnJvbSB0aGUgd2FybmluZ1xuICAgICAgICBpZiAoYy50eXBlID09PSAnc2NyaXB0JyAmJiBjLnByb3BzWyd0eXBlJ10gIT09ICdhcHBsaWNhdGlvbi9sZCtqc29uJykge1xuICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzWydzcmMnXVxuICAgICAgICAgICAgPyBgPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJHtjLnByb3BzWydzcmMnXX1cImBcbiAgICAgICAgICAgIDogYGlubGluZSA8c2NyaXB0PmBcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgJHtzcmNNZXNzYWdlfSkuIFVzZSBuZXh0L3NjcmlwdCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXNjcmlwdC10YWdzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydyZWwnXSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCBzdHlsZXNoZWV0cyB1c2luZyBuZXh0L2hlYWQgKHNlZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCI+IHRhZyB3aXRoIGhyZWY9XCIke2MucHJvcHNbJ2hyZWYnXX1cIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SGVhZCIsImluQW1wTW9kZSIsImhlYWQiLCJtZXRhIiwiY2hhclNldCIsInB1c2giLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiUmVhY3QiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwic3RhcnRzV2l0aCIsIm5ld1Byb3BzIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiSGVhZCIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nconst isServer = \"object\" === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    var _headManager_mountedInstances;\n                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    if (headManager) {\n                        headManager._pendingUpdate = emitChange;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    useClientOnlyEffect({\n        \"SideEffect.useClientOnlyEffect\": ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n            return ({\n                \"SideEffect.useClientOnlyEffect\": ()=>{\n                    if (headManager && headManager._pendingUpdate) {\n                        headManager._pendingUpdate();\n                        headManager._pendingUpdate = null;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyEffect\"]);\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkJ1QztBQWUvRCxNQUFNQyxXQUFXLE9BQU9DLE1BQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUVqRCxTQUFTRztRQUNQLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQy9DLE1BQU1DLGVBQWVDLE9BQUFBLFFBQVEsQ0FBQ0MsT0FBTyxDQUNuQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBMEJNLE1BQU0sQ0FDckVDO1lBR0pWLFlBQVlXLFVBQVUsQ0FBQ1Ysd0JBQXdCRyxjQUFjTDtRQUMvRDtJQUNGO0lBRUEsSUFBSU4sVUFBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCWSxHQUFHLENBQUNiLE1BQU1jLFFBQVE7UUFDakRYO0lBQ0Y7O2dEQUUwQjtnQkFDeEJGO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtZQUNqRDt3REFBTzt3QkFDTGI7b0JBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtnQkFDdEQ7O1FBQ0Y7O0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjs7Z0RBQ3pEO1lBQ3hCLElBQUliLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7WUFDQTt3REFBTztvQkFDTCxJQUFJRixhQUFhO3dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO29CQUMvQjtnQkFDRjs7UUFDRjs7OzBDQUVvQjtZQUNsQixJQUFJRixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1lBQ0E7a0RBQU87b0JBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO3dCQUM3Q2YsWUFBWWUsY0FBYzt3QkFDMUJmLFlBQVllLGNBQWMsR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0Y7O0lBRUEsT0FBTztBQUNUOzs7UUFyQ0VwQjtRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxzaWRlLWVmZmVjdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGlsZHJlbiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCB0eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUIGV4dGVuZHMge30+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUxheW91dEVmZmVjdFxuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCkgPT4ge30gOiB1c2VFZmZlY3RcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wczogU2lkZUVmZmVjdFByb3BzKSB7XG4gIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IENoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgIEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcyBhcyBTZXQ8UmVhY3QuUmVhY3ROb2RlPikuZmlsdGVyKFxuICAgICAgICAgIEJvb2xlYW5cbiAgICAgICAgKVxuICAgICAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnRbXVxuICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIGVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmFkZChwcm9wcy5jaGlsZHJlbilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmRlbGV0ZShwcm9wcy5jaGlsZHJlbilcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVzZUNsaWVudE9ubHlFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJTaWRlRWZmZWN0IiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/error-once.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"errorOnce\", ({\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n}));\nlet errorOnce = (_)=>{};\nif (true) {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n} //# sourceMappingURL=error-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NkNBV1NBOzs7ZUFBQUE7OztBQVhULElBQUlBLFlBQVksQ0FBQ0MsS0FBZTtBQUNoQyxJQUFJQyxJQUFvQixFQUFtQjtJQUN6QyxNQUFNRyxTQUFTLElBQUlDO0lBQ25CTixZQUFZLENBQUNPO1FBQ1gsSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07WUFDcEJFLFFBQVFDLEtBQUssQ0FBQ0g7UUFDaEI7UUFDQUYsT0FBT00sR0FBRyxDQUFDSjtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFx1dGlsc1xcZXJyb3Itb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZXJyb3JPbmNlID0gKF86IHN0cmluZykgPT4ge31cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGVycm9yT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghZXJyb3JzLmhhcyhtc2cpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICB9XG4gICAgZXJyb3JzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgZXJyb3JPbmNlIH1cbiJdLCJuYW1lcyI6WyJlcnJvck9uY2UiLCJfIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZXJyb3JzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsImVycm9yIiwiYWRkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/warn-once.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"warnOnce\", ({\n    enumerable: true,\n    get: function() {\n        return warnOnce;\n    }\n}));\nlet warnOnce = (_)=>{};\nif (true) {\n    const warnings = new Set();\n    warnOnce = (msg)=>{\n        if (!warnings.has(msg)) {\n            console.warn(msg);\n        }\n        warnings.add(msg);\n    };\n} //# sourceMappingURL=warn-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs0Q0FXU0E7OztlQUFBQTs7O0FBWFQsSUFBSUEsV0FBVyxDQUFDQyxLQUFlO0FBQy9CLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDLE1BQU1HLFdBQVcsSUFBSUM7SUFDckJOLFdBQVcsQ0FBQ087UUFDVixJQUFJLENBQUNGLFNBQVNHLEdBQUcsQ0FBQ0QsTUFBTTtZQUN0QkUsUUFBUUMsSUFBSSxDQUFDSDtRQUNmO1FBQ0FGLFNBQVNNLEdBQUcsQ0FBQ0o7SUFDZjtBQUNGIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcdXRpbHNcXHdhcm4tb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd2Fybk9uY2UgPSAoXzogc3RyaW5nKSA9PiB7fVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3Qgd2FybmluZ3MgPSBuZXcgU2V0PHN0cmluZz4oKVxuICB3YXJuT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghd2FybmluZ3MuaGFzKG1zZykpIHtcbiAgICAgIGNvbnNvbGUud2Fybihtc2cpXG4gICAgfVxuICAgIHdhcm5pbmdzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgd2Fybk9uY2UgfVxuIl0sIm5hbWVzIjpbIndhcm5PbmNlIiwiXyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIndhcm5pbmdzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsIndhcm4iLCJhZGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanMiLCJtYXBwaW5ncyI6IkFBQUEscUlBQWtEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXG5leHRcXGhlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/head.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"(pages-dir-browser)/./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2xpbmsuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkhBQThDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxjb21lcmNhXFxub2RlX21vZHVsZXNcXG5leHRcXGxpbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/link.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/router.js":
/*!*************************************!*\
  !*** ./node_modules/next/router.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/router */ \"(pages-dir-browser)/./node_modules/next/dist/client/router.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpSUFBZ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcbmV4dFxccm91dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9yb3V0ZXInKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/router.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/script.js":
/*!*************************************!*\
  !*** ./node_modules/next/script.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpSUFBZ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xcbmV4dFxcc2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9zY3JpcHQnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/script.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/pascalcase/index.js":
/*!******************************************!*\
  !*** ./node_modules/pascalcase/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*!\n * pascalcase <https://github.com/jonschlinkert/pascalcase>\n *\n * Copyright (c) 2015-present, Jon (\"Schlink\") Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst titlecase = input => input[0].toLocaleUpperCase() + input.slice(1);\n\nmodule.exports = value => {\n  if (value === null || value === void 0) return '';\n  if (typeof value.toString !== 'function') return '';\n\n  let input = value.toString().trim();\n  if (input === '') return '';\n  if (input.length === 1) return input.toLocaleUpperCase();\n\n  let match = input.match(/[a-zA-Z0-9]+/g);\n  if (match) {\n    return match.map(m => titlecase(m)).join('');\n  }\n\n  return input;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXNjYWxjYXNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xccGFzY2FsY2FzZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwYXNjYWxjYXNlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9wYXNjYWxjYXNlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gKFwiU2NobGlua1wiKSBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHRpdGxlY2FzZSA9IGlucHV0ID0+IGlucHV0WzBdLnRvTG9jYWxlVXBwZXJDYXNlKCkgKyBpbnB1dC5zbGljZSgxKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHJldHVybiAnJztcblxuICBsZXQgaW5wdXQgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcbiAgaWYgKGlucHV0ID09PSAnJykgcmV0dXJuICcnO1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKSByZXR1cm4gaW5wdXQudG9Mb2NhbGVVcHBlckNhc2UoKTtcblxuICBsZXQgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvW2EtekEtWjAtOV0rL2cpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2gubWFwKG0gPT4gdGl0bGVjYXNlKG0pKS5qb2luKCcnKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/pascalcase/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server-legacy.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createPreambleState() {\n      return {\n        htmlChunks: null,\n        headChunks: null,\n        bodyChunks: null,\n        contribution: NoContribution\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              parentContext.tagScope\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              parentContext.tagScope\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = escapeTextForBrowser(styleName);\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = escapeTextForBrowser(\n                    nameChunk\n                      .replace(uppercasePattern, \"-$1\")\n                      .toLowerCase()\n                      .replace(msPattern, \"-ms-\")\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? \"\" + styleValue\n                      : styleValue + \"px\")\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = escapeTextForBrowser(\n                    (\"\" + styleValue).trim()\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(attributeSeparator, name, attributeEmptyString);\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          name,\n          attributeAssign,\n          escapeTextForBrowser(value),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push('<input type=\"hidden\"');\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              \"formAction\",\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            name,\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            \"xlink:href\",\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(attributeSeparator, name, attributeEmptyString);\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(attributeSeparator, name, attributeEmptyString)\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML), target.push(\"\" + innerHTML));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          \"\\x3c/script>\"\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(escapeTextForBrowser(\"\" + props));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(escapeEntireInlineScriptContent(children));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(escapeTextForBrowser(tag)), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = \"<\" + tag;\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(escapeTextForBrowser(children));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(' selected=\"\"');\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(' selected=\"\"');\n          } else selected && target$jscomp$0.push(' selected=\"\"');\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0)));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  \"action\",\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push('<input type=\"hidden\"'),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      \"data\",\n                      attributeAssign,\n                      escapeTextForBrowser(sanitizedValue),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: escapeTextForBrowser(precedence),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    escapeTextForBrowser(href$jscomp$0)\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: escapeTextForBrowser(precedence$jscomp$0),\n                    rules: [],\n                    hrefs: [escapeTextForBrowser(href$jscomp$0)],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(escapeStyleTextContent(child$jscomp$2));\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, html)\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(\"\" + html)));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          attributeName,\n                          attributeAssign,\n                          escapeTextForBrowser(propValue$jscomp$11),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = \"</\" + tag + \">\"), endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        ((renderState.htmlChunks = preambleState.htmlChunks),\n        (preambleState.contribution |= 1));\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        ((renderState.headChunks = preambleState.headChunks),\n        (preambleState.contribution |= 4));\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        ((renderState.bodyChunks = preambleState.bodyChunks),\n        (preambleState.contribution |= 2));\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        destination.push(renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]), (renderState.length = 0), destination.push(i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      destination.push(startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      destination.push(renderState.boundaryPrefix);\n      renderState = id.toString(16);\n      destination.push(renderState);\n      return destination.push(startPendingSuspenseBoundary2);\n    }\n    function writePreambleContribution(destination, preambleState) {\n      preambleState = preambleState.contribution;\n      preambleState !== NoContribution &&\n        (destination.push(boundaryPreambleContributionChunkStart),\n        destination.push(\"\" + preambleState),\n        destination.push(boundaryPreambleContributionChunkEnd));\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            destination.push(startSegmentHTML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            destination.push(startSegmentSVG),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            destination.push(startSegmentMathML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            destination.push(startSegmentTable),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            destination.push(startSegmentTableBody),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            destination.push(startSegmentTableRow),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            destination.push(startSegmentColGroup),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return destination.push(endSegmentHTML);\n        case SVG_MODE:\n          return destination.push(endSegmentSVG);\n        case MATHML_MODE:\n          return destination.push(endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return destination.push(endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return destination.push(endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return destination.push(endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return destination.push(endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        this.push(lateStyleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)\n          this.push(hrefs[i]), this.push(spaceSeparator);\n        this.push(hrefs[i]);\n        this.push(lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) this.push(rules[i]);\n        destinationHasCapacity = this.push(lateStyleTagTemplateClose);\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) this.push(resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        this.push(stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        this.push(styleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            this.push(styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            this.push(hrefs[styleQueue]), this.push(spaceSeparator);\n          this.push(hrefs[styleQueue]);\n        }\n        this.push(styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          this.push(rules[styleQueue]);\n        this.push(styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          this.push(stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      destination.push(arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            destination.push(nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              (resource = escapeJSObjectForInstructionScripts(\"\" + resource)),\n              destination.push(resource),\n              destination.push(arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            destination.push(nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            coercedHref = escapeJSObjectForInstructionScripts(coercedHref);\n            destination.push(coercedHref);\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            destination.push(arrayInterstitial);\n            precedence = escapeJSObjectForInstructionScripts(precedence);\n            destination.push(precedence);\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            destination.push(arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      destination.push(arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(attributeName);\n      destination.push(attributeName);\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(name);\n      destination.push(attributeName);\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function createRenderState(resumableState, generateStaticMarkup) {\n      var idPrefix = resumableState.idPrefix,\n        bootstrapChunks = [],\n        bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        bootstrapChunks.push(\n          \"<script>\",\n          escapeEntireInlineScriptContent(bootstrapScriptContent),\n          \"\\x3c/script>\"\n        );\n      idPrefix = {\n        placeholderPrefix: idPrefix + \"P:\",\n        segmentPrefix: idPrefix + \"S:\",\n        boundaryPrefix: idPrefix + \"B:\",\n        startInlineScript: \"<script>\",\n        preamble: createPreambleState(),\n        externalRuntimeScript: null,\n        bootstrapChunks: bootstrapChunks,\n        importMapChunks: [],\n        onHeaders: void 0,\n        headers: null,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: void 0,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (\n          bootstrapScriptContent = 0;\n          bootstrapScriptContent < bootstrapScripts.length;\n          bootstrapScriptContent++\n        ) {\n          var scriptConfig = bootstrapScripts[bootstrapScriptContent],\n            src,\n            crossOrigin = void 0,\n            integrity = void 0,\n            props = {\n              rel: \"preload\",\n              as: \"script\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            };\n          \"string\" === typeof scriptConfig\n            ? (props.href = src = scriptConfig)\n            : ((props.href = src = scriptConfig.src),\n              (props.integrity = integrity =\n                \"string\" === typeof scriptConfig.integrity\n                  ? scriptConfig.integrity\n                  : void 0),\n              (props.crossOrigin = crossOrigin =\n                \"string\" === typeof scriptConfig ||\n                null == scriptConfig.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === scriptConfig.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);\n          bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src));\n          \"string\" === typeof integrity &&\n            bootstrapChunks.push(\n              '\" integrity=\"',\n              escapeTextForBrowser(integrity)\n            );\n          \"string\" === typeof crossOrigin &&\n            bootstrapChunks.push(\n              '\" crossorigin=\"',\n              escapeTextForBrowser(crossOrigin)\n            );\n          bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),\n            (crossOrigin = src = void 0),\n            (integrity = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            }),\n            \"string\" === typeof bootstrapScriptContent\n              ? (integrity.href = scriptConfig = bootstrapScriptContent)\n              : ((integrity.href = scriptConfig = bootstrapScriptContent.src),\n                (integrity.integrity = crossOrigin =\n                  \"string\" === typeof bootstrapScriptContent.integrity\n                    ? bootstrapScriptContent.integrity\n                    : void 0),\n                (integrity.crossOrigin = src =\n                  \"string\" === typeof bootstrapScriptContent ||\n                  null == bootstrapScriptContent.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === bootstrapScriptContent.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              idPrefix,\n              scriptConfig,\n              integrity\n            ),\n            bootstrapChunks.push(\n              '<script type=\"module\" src=\"',\n              escapeTextForBrowser(scriptConfig)\n            ),\n            \"string\" === typeof crossOrigin &&\n              bootstrapChunks.push(\n                '\" integrity=\"',\n                escapeTextForBrowser(crossOrigin)\n              ),\n            \"string\" === typeof src &&\n              bootstrapChunks.push(\n                '\" crossorigin=\"',\n                escapeTextForBrowser(src)\n              ),\n            bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n      return {\n        placeholderPrefix: idPrefix.placeholderPrefix,\n        segmentPrefix: idPrefix.segmentPrefix,\n        boundaryPrefix: idPrefix.boundaryPrefix,\n        startInlineScript: idPrefix.startInlineScript,\n        preamble: idPrefix.preamble,\n        externalRuntimeScript: idPrefix.externalRuntimeScript,\n        bootstrapChunks: idPrefix.bootstrapChunks,\n        importMapChunks: idPrefix.importMapChunks,\n        onHeaders: idPrefix.onHeaders,\n        headers: idPrefix.headers,\n        resets: idPrefix.resets,\n        charsetChunks: idPrefix.charsetChunks,\n        viewportChunks: idPrefix.viewportChunks,\n        hoistableChunks: idPrefix.hoistableChunks,\n        preconnects: idPrefix.preconnects,\n        fontPreloads: idPrefix.fontPreloads,\n        highImagePreloads: idPrefix.highImagePreloads,\n        styles: idPrefix.styles,\n        bootstrapScripts: idPrefix.bootstrapScripts,\n        scripts: idPrefix.scripts,\n        bulkPreloads: idPrefix.bulkPreloads,\n        preloads: idPrefix.preloads,\n        stylesToHoist: idPrefix.stylesToHoist,\n        generateStaticMarkup: generateStaticMarkup\n      };\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (renderState.generateStaticMarkup)\n        return target.push(escapeTextForBrowser(text)), !1;\n      \"\" === text\n        ? (target = textEmbedded)\n        : (textEmbedded && target.push(\"\\x3c!-- --\\x3e\"),\n          target.push(escapeTextForBrowser(text)),\n          (target = !0));\n      return target;\n    }\n    function pushSegmentFinale(\n      target,\n      renderState,\n      lastPushedText,\n      textEmbedded\n    ) {\n      renderState.generateStaticMarkup ||\n        (lastPushedText && textEmbedded && target.push(\"\\x3c!-- --\\x3e\"));\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue2 = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue2 = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue2;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react-stack-bottom-frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"[%s] \" + error[0],\n              \" \" + JSCompiler_inline_result + \" \"\n            )\n          : error.splice(0, 0, \"[%s] \", \" \" + JSCompiler_inline_result + \" \");\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var now = getCurrentTime();\n      1e3 < now - lastResetTime &&\n        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n        (lastResetTime = now));\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        performWork(request));\n    }\n    function createSuspenseBoundary(\n      request,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED), request.destination.destroy(error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(\"\\x3c!--F!--\\x3e\")\n              : segment.push(\"\\x3c!--F--\\x3e\");\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue2);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue2\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            var preambleTask = createRenderTask(\n              request,\n              null,\n              _children,\n              -1,\n              task.blockedBoundary,\n              preambleSegment,\n              task.blockedPreamble,\n              task.hoistableState,\n              request.abortableTasks,\n              task.keyPath,\n              task.formatContext,\n              task.context,\n              task.treeContext,\n              task.componentStack,\n              task.isFallback,\n              emptyContextObject,\n              task.debugTask\n            );\n            pushComponentStack(preambleTask);\n            request.pingedTasks.push(preambleTask);\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_ACTIVITY_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    pushSegmentFinale(\n                      boundarySegment.chunks,\n                      request.renderState,\n                      boundarySegment.lastPushedText,\n                      boundarySegment.textEmbedded\n                    ),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    pushSegmentFinale(\n                      contentRootSegment.chunks,\n                      request.renderState,\n                      contentRootSegment.lastPushedText,\n                      contentRootSegment.textEmbedded\n                    ),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    0 === request.pendingRootTasks &&\n                      task.blockedPreamble &&\n                      preparePreamble(request);\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue2;\n              type._currentValue2 = value$jscomp$0;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue2 =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue2),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            node = node[3];\n            name = task.node;\n            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (task.node === name && (task.replay = replay), x);\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = node;\n              node = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                node,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              type = node[5];\n              ref = node[2];\n              name = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              props.parentFlushed = !0;\n              props.rootSegmentID = type;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                !0,\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (key = null)\n            : ((type =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (key = \"function\" === typeof type ? type : null));\n          if (key && (type = key.call(node))) {\n            if (type === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !== Object.prototype.toString.call(type)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== key ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = type.next();\n            if (!node.done) {\n              key = [];\n              do key.push(node.value), (node = type.next());\n              while (!node.done);\n              renderChildrenArray(request, task, key, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue2,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        resumeSlots = request;\n        node = task;\n        error = childIndex;\n        if (\n          null !== error &&\n          \"object\" === typeof error &&\n          (error.$$typeof === REACT_ELEMENT_TYPE ||\n            error.$$typeof === REACT_PORTAL_TYPE) &&\n          error._store &&\n          ((!error._store.validated && null == error.key) ||\n            2 === error._store.validated)\n        ) {\n          if (\"object\" !== typeof error._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          error._store.validated = 1;\n          thrownInfo = resumeSlots.didWarnForKey;\n          null == thrownInfo &&\n            (thrownInfo = resumeSlots.didWarnForKey = new WeakSet());\n          resumeSlots = node.componentStack;\n          if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {\n            thrownInfo.add(resumeSlots);\n            var componentName = getComponentNameFromType(error.type);\n            thrownInfo = error._owner;\n            var parentOwner = resumeSlots.owner;\n            resumeSlots = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (resumeSlots =\n                  \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            resumeSlots ||\n              (componentName &&\n                (resumeSlots =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != thrownInfo &&\n              parentOwner !== thrownInfo &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof thrownInfo.type\n                ? (parentOwner = getComponentNameFromType(thrownInfo.type))\n                : \"string\" === typeof thrownInfo.name &&\n                  (parentOwner = thrownInfo.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            thrownInfo = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: error.type,\n              owner: error._owner,\n              stack: error._debugStack\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              resumeSlots,\n              componentName\n            );\n            node.componentStack = thrownInfo;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment, null);\n            fatalError(request, error, segment, null);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment, null)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear(),\n                  0 === request.pendingRootTasks &&\n                    null === request.trackedPostpones &&\n                    null !== boundary.contentPreamble &&\n                    preparePreamble(request)))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  pushSegmentFinale(\n                    request$jscomp$1.chunks,\n                    request.renderState,\n                    request$jscomp$1.lastPushedText,\n                    request$jscomp$1.textEmbedded\n                  ),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState = getThenableStateAfterSuspending();\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = 4;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    debugTask = errorDigest.debugTask;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  null === boundary$jscomp$0\n                    ? fatalError(\n                        request,\n                        x$jscomp$0,\n                        errorInfo$jscomp$1,\n                        debugTask\n                      )\n                    : (boundary$jscomp$0.pendingTasks--,\n                      boundary$jscomp$0.status !== CLIENT_RENDERED &&\n                        ((boundary$jscomp$0.status = CLIENT_RENDERED),\n                        encodeErrorForBoundary(\n                          boundary$jscomp$0,\n                          prevTaskInDEV,\n                          x$jscomp$0,\n                          errorInfo$jscomp$1,\n                          !1\n                        ),\n                        untrackBoundary(request, boundary$jscomp$0),\n                        boundary$jscomp$0.parentFlushed &&\n                          request.clientRenderedBoundaries.push(\n                            boundary$jscomp$0\n                          ),\n                        0 === request.pendingRootTasks &&\n                          null === request.trackedPostpones &&\n                          null !== boundary$jscomp$0.contentPreamble &&\n                          preparePreamble(request)));\n                  request.allPendingTasks--;\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        if (\n          !1 === hasPendingPreambles ||\n          (preamble.headChunks && preamble.bodyChunks)\n        )\n          request.completedPreambleSegments = collectedPreambleSegments;\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            destination.push(placeholder1),\n            destination.push(request.placeholderPrefix),\n            (request = hoistableState.toString(16)),\n            destination.push(request),\n            destination.push(placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              destination.push(chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            destination.push(chunks[chunkIdx]);\n          chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        if (!request.renderState.generateStaticMarkup) {\n          var errorDigest = boundary.errorDigest,\n            errorMessage = boundary.errorMessage,\n            errorStack = boundary.errorStack,\n            errorComponentStack = boundary.errorComponentStack;\n          destination.push(startClientRenderedSuspenseBoundary);\n          destination.push(clientRenderedSuspenseBoundaryError1);\n          errorDigest &&\n            (destination.push(clientRenderedSuspenseBoundaryError1A),\n            (errorDigest = escapeTextForBrowser(errorDigest)),\n            destination.push(errorDigest),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorMessage &&\n            (destination.push(clientRenderedSuspenseBoundaryError1B),\n            (errorMessage = escapeTextForBrowser(errorMessage)),\n            destination.push(errorMessage),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorStack &&\n            (destination.push(clientRenderedSuspenseBoundaryError1C),\n            (errorStack = escapeTextForBrowser(errorStack)),\n            destination.push(errorStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorComponentStack &&\n            (destination.push(clientRenderedSuspenseBoundaryError1D),\n            (errorComponentStack = escapeTextForBrowser(errorComponentStack)),\n            destination.push(errorComponentStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          destination.push(clientRenderedSuspenseBoundaryError2);\n        }\n        flushSubtree(request, destination, segment, hoistableState);\n        request.renderState.generateStaticMarkup\n          ? (destination = !0)\n          : ((request = boundary.fallbackPreamble) &&\n              writePreambleContribution(destination, request),\n            (destination = destination.push(endSuspenseBoundary)));\n        return destination;\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((boundary = boundary.fallbackState),\n            boundary.styles.forEach(hoistStyleQueueDependency, hoistableState),\n            boundary.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      if (boundary.byteSize > request.progressiveChunkSize)\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      hoistableState &&\n        ((segment = boundary.contentState),\n        segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n        segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n      request.renderState.generateStaticMarkup ||\n        destination.push(startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      request.renderState.generateStaticMarkup\n        ? (destination = !0)\n        : ((request = boundary.contentPreamble) &&\n            writePreambleContribution(destination, request),\n          (destination = destination.push(endSuspenseBoundary)));\n      return destination;\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      destination.push(request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              destination.push(completeBoundaryWithStylesScript1FullPartial))\n            : destination.push(completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryScript1Full))\n          : destination.push(completeBoundaryScript1Partial);\n      completedSegments = i.toString(16);\n      destination.push(request.boundaryPrefix);\n      destination.push(completedSegments);\n      destination.push(completeBoundaryScript2);\n      destination.push(request.segmentPrefix);\n      destination.push(completedSegments);\n      requiresStyleInsertion\n        ? (destination.push(completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : destination.push(completeBoundaryScript3b);\n      boundary = destination.push(completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      destination.push(request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          destination.push(completeSegmentScript1Full))\n        : destination.push(completeSegmentScript1Partial);\n      destination.push(request.segmentPrefix);\n      segmentID = segmentID.toString(16);\n      destination.push(segmentID);\n      destination.push(completeSegmentScript2);\n      destination.push(request.placeholderPrefix);\n      destination.push(segmentID);\n      destination = destination.push(completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            var renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                destination.push(htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  destination.push(headChunks[i$jscomp$0]);\n              else {\n                var chunk = startChunkForTag(\"head\");\n                destination.push(chunk);\n                destination.push(endOfStartTag);\n              }\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                destination.push(headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(hoistableChunks[i$jscomp$0]);\n            for (\n              renderState = hoistableChunks.length = 0;\n              renderState < completedPreambleSegments.length;\n              renderState++\n            ) {\n              var segments = completedPreambleSegments[renderState];\n              for (preamble = 0; preamble < segments.length; preamble++)\n                flushSegment(request, destination, segments[preamble], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {\n              var chunk$jscomp$0 = endChunkForTag(\"head\");\n              destination.push(chunk$jscomp$0);\n            }\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                destination.push(bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(viewportChunks$jscomp$0[completedRootSegment]);\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                renderState$jscomp$0.push(clientRenderScript1Full))\n              : renderState$jscomp$0.push(clientRenderScript1Partial);\n            renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);\n            var chunk$jscomp$1 = id.toString(16);\n            renderState$jscomp$0.push(chunk$jscomp$1);\n            renderState$jscomp$0.push(clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            ) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(\n                errorDigest || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$2);\n            }\n            if (errorMessage || errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(\n                errorMessage || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$3);\n            }\n            if (errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(\n                errorStack || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$4);\n            }\n            if (errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$5 =\n                escapeJSStringsForInstructionScripts(errorComponentStack);\n              renderState$jscomp$0.push(chunk$jscomp$5);\n            }\n            var JSCompiler_inline_result = renderState$jscomp$0.push(\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n          0 === request.pingedTasks.length &&\n          0 === request.clientRenderedBoundaries.length &&\n          0 === request.completedBoundaries.length &&\n          ((request.flushScheduled = !1),\n          (i = request.resumableState),\n          i.hasBody &&\n            ((partialBoundaries = endChunkForTag(\"body\")),\n            destination.push(partialBoundaries)),\n          i.hasHtml && ((i = endChunkForTag(\"html\")), destination.push(i)),\n          0 !== request.abortableTasks.size &&\n            console.error(\n              \"There was still abortable task at the root when we closed. This is a bug in React.\"\n            ),\n          (request.status = CLOSED),\n          destination.push(null),\n          (request.destination = null));\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      performWork(request);\n      10 === request.status && (request.status = 11);\n      null === request.trackedPostpones &&\n        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n    }\n    function enqueueFlush(request) {\n      if (\n        !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination\n      ) {\n        request.flushScheduled = !0;\n        var destination = request.destination;\n        destination\n          ? flushCompletedQueues(request, destination)\n          : (request.flushScheduled = !1);\n      }\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED), destination.destroy(request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function onError() {}\n    function renderToStringImpl(\n      children,\n      options,\n      generateStaticMarkup,\n      abortReason\n    ) {\n      var didFatal = !1,\n        fatalError = null,\n        result = \"\",\n        readyToStream = !1;\n      options = createResumableState(\n        options ? options.identifierPrefix : void 0\n      );\n      children = createRequest(\n        children,\n        options,\n        createRenderState(options, generateStaticMarkup),\n        createFormatContext(ROOT_HTML_MODE, null, 0),\n        Infinity,\n        onError,\n        void 0,\n        function () {\n          readyToStream = !0;\n        },\n        void 0,\n        void 0,\n        void 0\n      );\n      startWork(children);\n      abort(children, abortReason);\n      startFlowing(children, {\n        push: function (chunk) {\n          null !== chunk && (result += chunk);\n          return !0;\n        },\n        destroy: function (error) {\n          didFatal = !0;\n          fatalError = error;\n        }\n      });\n      if (didFatal && fatalError !== abortReason) throw fatalError;\n      if (!readyToStream)\n        throw Error(\n          \"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\"\n        );\n      return result;\n    }\n    var React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! react-dom */ \"(pages-dir-browser)/./node_modules/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: escapeTextForBrowser(precedence),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var NoContribution = 0,\n      ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      styleNameCache = new Map(),\n      styleAttributeStart = ' style=\"',\n      styleAssign = \":\",\n      styleSeparator = \";\",\n      attributeSeparator = \" \",\n      attributeAssign = '=\"',\n      attributeEnd = '\"',\n      attributeEmptyString = '=\"\"',\n      actionJavaScriptURL = escapeTextForBrowser(\n        \"javascript:throw new Error('React form unexpectedly submitted.')\"\n      ),\n      endOfStartTag = \">\",\n      endOfStartTagSelfClosing = \"/>\",\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      formReplayingRuntimeScript =\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});',\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = \"\\n\",\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      endTagCache = new Map(),\n      placeholder1 = '<template id=\"',\n      placeholder2 = '\"></template>',\n      startCompletedSuspenseBoundary = \"\\x3c!--$--\\x3e\",\n      startPendingSuspenseBoundary1 = '\\x3c!--$?--\\x3e<template id=\"',\n      startPendingSuspenseBoundary2 = '\"></template>',\n      startClientRenderedSuspenseBoundary = \"\\x3c!--$!--\\x3e\",\n      endSuspenseBoundary = \"\\x3c!--/$--\\x3e\",\n      clientRenderedSuspenseBoundaryError1 = \"<template\",\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial = '\"',\n      clientRenderedSuspenseBoundaryError1A = ' data-dgst=\"',\n      clientRenderedSuspenseBoundaryError1B = ' data-msg=\"',\n      clientRenderedSuspenseBoundaryError1C = ' data-stck=\"',\n      clientRenderedSuspenseBoundaryError1D = ' data-cstck=\"',\n      clientRenderedSuspenseBoundaryError2 = \"></template>\",\n      boundaryPreambleContributionChunkStart = \"\\x3c!--\",\n      boundaryPreambleContributionChunkEnd = \"--\\x3e\",\n      startSegmentHTML = '<div hidden id=\"',\n      startSegmentHTML2 = '\">',\n      endSegmentHTML = \"</div>\",\n      startSegmentSVG = '<svg aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentSVG2 = '\">',\n      endSegmentSVG = \"</svg>\",\n      startSegmentMathML = '<math aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentMathML2 = '\">',\n      endSegmentMathML = \"</math>\",\n      startSegmentTable = '<table hidden id=\"',\n      startSegmentTable2 = '\">',\n      endSegmentTable = \"</table>\",\n      startSegmentTableBody = '<table hidden><tbody id=\"',\n      startSegmentTableBody2 = '\">',\n      endSegmentTableBody = \"</tbody></table>\",\n      startSegmentTableRow = '<table hidden><tr id=\"',\n      startSegmentTableRow2 = '\">',\n      endSegmentTableRow = \"</tr></table>\",\n      startSegmentColGroup = '<table hidden><colgroup id=\"',\n      startSegmentColGroup2 = '\">',\n      endSegmentColGroup = \"</colgroup></table>\",\n      completeSegmentScript1Full =\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"',\n      completeSegmentScript1Partial = '$RS(\"',\n      completeSegmentScript2 = '\",\"',\n      completeSegmentScriptEnd = '\")\\x3c/script>',\n      completeBoundaryScript1Full =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"',\n      completeBoundaryScript1Partial = '$RC(\"',\n      completeBoundaryWithStylesScript1FullBoth =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1FullPartial =\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1Partial = '$RR(\"',\n      completeBoundaryScript2 = '\",\"',\n      completeBoundaryScript3a = '\",',\n      completeBoundaryScript3b = '\"',\n      completeBoundaryScriptEnd = \")\\x3c/script>\",\n      clientRenderScript1Full =\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"',\n      clientRenderScript1Partial = '$RX(\"',\n      clientRenderScript1A = '\"',\n      clientRenderErrorScriptArgInterstitial = \",\",\n      clientRenderScriptEnd = \")\\x3c/script>\",\n      regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = '<style media=\"not all\" data-precedence=\"',\n      lateStyleTagResourceOpen2 = '\" data-href=\"',\n      lateStyleTagResourceOpen3 = '\">',\n      lateStyleTagTemplateClose = \"</style>\",\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = '<style data-precedence=\"',\n      styleTagResourceOpen2 = '\" data-href=\"',\n      spaceSeparator = \" \",\n      styleTagResourceOpen3 = '\">',\n      styleTagResourceClose = \"</style>\",\n      arrayFirstOpenBracket = \"[\",\n      arraySubsequentOpenBracket = \",[\",\n      arrayInterstitial = \",\",\n      arrayCloseBracket = \"]\",\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      doctypeChunk = \"\",\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue2;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"\\u00ab\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"\\u00bb\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      lastResetTime = 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      var getCurrentTime = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      getCurrentTime = function () {\n        return localDate.now();\n      };\n    }\n    var CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    exports.renderToStaticMarkup = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !0,\n        'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.renderToString = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !1,\n        'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.version = \"19.1.0\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixpQkFBaUIsbURBQW1ELG1CQUFtQixXQUFXLCtCQUErQjtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLDRCQUE0QixXQUFXLGVBQWUsbUJBQW1CO0FBQ3pFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCw4QkFBOEI7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzZkFBc2YsV0FBVywwTEFBMEwsU0FBUyxXQUFXLEVBQUU7QUFDanRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHFCQUFxQixXQUFXLGVBQWUsbUJBQW1CO0FBQ2xFLG1CQUFtQjtBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQixnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBLFFBQVE7QUFDUiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3Qiw0Q0FBNEMsTUFBTSxtQ0FBbUMsc0JBQXNCLGtWQUFrVixFQUFFO0FBQ3RnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkIsNkJBQTZCLGdDQUFnQyxhQUFhLDJDQUEyQyw2QkFBNkI7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCLDRCQUE0QixpQ0FBaUMsTUFBTSxvQkFBb0IsK0NBQStDLEtBQUssZUFBZSxnQkFBZ0IsUUFBUSxHQUFHLHNCQUFzQixhQUFhLDJCQUEyQixTQUFTLHFDQUFxQyxnQkFBZ0IsaUJBQWlCLElBQUksU0FBUyxLQUFLLGFBQWEsZ0NBQWdDLFdBQVcsaUNBQWlDO0FBQ3ZlO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCLDRCQUE0QixpQ0FBaUMsTUFBTSxvQkFBb0IsK0NBQStDLEtBQUssZUFBZSxnQkFBZ0IsUUFBUSxHQUFHLHNCQUFzQixhQUFhLDJCQUEyQixTQUFTLHFDQUFxQyxnQkFBZ0IsaUJBQWlCLElBQUksU0FBUyxLQUFLLGFBQWEsZ0NBQWdDLFdBQVcsaUNBQWlDLFlBQVksc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM1Z0Q7QUFDQSxxQkFBcUIsc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM5aUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQywwSUFBMEk7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMscURBQXFEO0FBQ3JELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CLEdBQUciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xccmVhY3QtZG9tXFxjanNcXHJlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcblxuXG4gSlMgSW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMgKHIxMzYpIChhcyBvZiBNYXkgMjAsIDIwMTEpXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTEgR2FyeSBDb3VydFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIFNPRlRXQVJFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gc3R5bGVSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcNzMgXCIgOiBcIlxcXFw1MyBcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjcmlwdFJlcGxhY2VyKG1hdGNoLCBwcmVmaXgsIHMsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAoXCJzXCIgPT09IHMgPyBcIlxcXFx1MDA3M1wiIDogXCJcXFxcdTAwNTNcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmplY3QpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgICAgICAgcmV0dXJuIHAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2Uoa2V5KSB7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGtleSArICdcIicgPT09IGVuY29kZWRLZXkgPyBrZXkgOiBlbmNvZGVkS2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgMTAgPj0gdmFsdWUubGVuZ3RoID8gdmFsdWUgOiB2YWx1ZS5zbGljZSgwLCAxMCkgKyBcIi4uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHZhbHVlICYmIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRylcbiAgICAgICAgICAgIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICAgIHZhbHVlID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHZhbHVlID8gXCJ7Li4ufVwiIDogdmFsdWU7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUdcbiAgICAgICAgICAgID8gXCJjbGllbnRcIlxuICAgICAgICAgICAgOiAodmFsdWUgPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyB2YWx1ZVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS50eXBlKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2Uob2JqZWN0T3JBcnJheSwgZXhwYW5kZWROYW1lKSB7XG4gICAgICB2YXIgb2JqS2luZCA9IG9iamVjdE5hbWUob2JqZWN0T3JBcnJheSk7XG4gICAgICBpZiAoXCJPYmplY3RcIiAhPT0gb2JqS2luZCAmJiBcIkFycmF5XCIgIT09IG9iaktpbmQpIHJldHVybiBvYmpLaW5kO1xuICAgICAgdmFyIHN0YXJ0ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBpZiAoaXNBcnJheUltcGwob2JqZWN0T3JBcnJheSkpXG4gICAgICAgIGlmIChqc3hDaGlsZHJlblBhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdE9yQXJyYXlbaV07XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiXG4gICAgICAgICAgICAgICAgICA6IFwie1wiICsgZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIjtcbiAgICAgICAgICAgIFwiXCIgKyBpID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSB2YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IHZhbHVlKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxNSA+IHZhbHVlLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiey4uLn1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI8L1wiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIltcIjtcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgICAgIDAgPCB0eXBlICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChpID0gb2JqZWN0T3JBcnJheVt0eXBlXSksXG4gICAgICAgICAgICAgIChpID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaSAmJiBudWxsICE9PSBpXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGkpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoaSkpLFxuICAgICAgICAgICAgICBcIlwiICsgdHlwZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IGkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IGkpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IGkubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIGlcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwiXVwiO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUob2JqZWN0T3JBcnJheS50eXBlKSArIFwiLz5cIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICBpZiAoanN4UHJvcHNQYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIG9iaktpbmQgPSBqc3hQcm9wc1BhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIChkZXNjcmliZUVsZW1lbnRUeXBlKG9iaktpbmQpIHx8IFwiLi4uXCIpO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqS2luZCArPSBcIiBcIjtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZVtpXTtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI9XCI7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdO1xuICAgICAgICAgICAgdmFyIF9zdWJzdHIyID1cbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZSAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBfdmFsdWUyICYmIChfc3Vic3RyMiA9IFwie1wiICsgX3N1YnN0cjIgKyBcIn1cIik7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfc3Vic3RyMikpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTAgPiBfc3Vic3RyMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF9zdWJzdHIyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfc3Vic3RyMlxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJ7XCI7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgMCA8IGkgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gdHlwZVtpXSksXG4gICAgICAgICAgICAgIChvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiOiBcIiksXG4gICAgICAgICAgICAgIChfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV0pLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiYgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpKSxcbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBfdmFsdWUyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfdmFsdWUyKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBfdmFsdWUyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3ZhbHVlMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgID8gb2JqS2luZFxuICAgICAgICA6IC0xIDwgc3RhcnQgJiYgMCA8IGxlbmd0aFxuICAgICAgICAgID8gKChvYmplY3RPckFycmF5ID0gXCIgXCIucmVwZWF0KHN0YXJ0KSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKSxcbiAgICAgICAgICAgIFwiXFxuICBcIiArIG9iaktpbmQgKyBcIlxcbiAgXCIgKyBvYmplY3RPckFycmF5KVxuICAgICAgICAgIDogXCJcXG4gIFwiICsgb2JqS2luZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbXVybXVyaGFzaDNfMzJfZ2Moa2V5LCBzZWVkKSB7XG4gICAgICB2YXIgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7XG4gICAgICB2YXIgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICAgICAgdmFyIGgxID0gc2VlZDtcbiAgICAgIGZvciAoc2VlZCA9IDA7IHNlZWQgPCBieXRlczsgKSB7XG4gICAgICAgIHZhciBrMSA9XG4gICAgICAgICAgKGtleS5jaGFyQ29kZUF0KHNlZWQpICYgMjU1KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCA4KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCAxNikgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgMjQpO1xuICAgICAgICArK3NlZWQ7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCgzNDMyOTE4MzUzICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgICAgICBrMSA9XG4gICAgICAgICAgKDQ2MTg0NTkwNyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCg0NjE4NDU5MDcgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gKGgxIDw8IDEzKSB8IChoMSA+Pj4gMTkpO1xuICAgICAgICBoMSA9XG4gICAgICAgICAgKDUgKiAoaDEgJiA2NTUzNSkgKyAoKCg1ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJiA0Mjk0OTY3Mjk1O1xuICAgICAgICBoMSA9IChoMSAmIDY1NTM1KSArIDI3NDkyICsgKCgoKGgxID4+PiAxNikgKyA1ODk2NCkgJiA2NTUzNSkgPDwgMTYpO1xuICAgICAgfVxuICAgICAgazEgPSAwO1xuICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChzZWVkICsgMikgJiAyNTUpIDw8IDE2O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KHNlZWQgKyAxKSAmIDI1NSkgPDwgODtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIChrMSBePSBrZXkuY2hhckNvZGVBdChzZWVkKSAmIDI1NSksXG4gICAgICAgICAgICAoazEgPVxuICAgICAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAgICAgKCgoMzQzMjkxODM1MyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSksXG4gICAgICAgICAgICAoazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNykpLFxuICAgICAgICAgICAgKGgxIF49XG4gICAgICAgICAgICAgICg0NjE4NDU5MDcgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgICAgICgoKDQ2MTg0NTkwNyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSk7XG4gICAgICB9XG4gICAgICBoMSBePSBrZXkubGVuZ3RoO1xuICAgICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgICAgaDEgPVxuICAgICAgICAoMjI0NjgyMjUwNyAqIChoMSAmIDY1NTM1KSArXG4gICAgICAgICAgKCgoMjI0NjgyMjUwNyAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgIGgxIF49IGgxID4+PiAxMztcbiAgICAgIGgxID1cbiAgICAgICAgKDMyNjY0ODk5MDkgKiAoaDEgJiA2NTUzNSkgK1xuICAgICAgICAgICgoKDMyNjY0ODk5MDkgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICByZXR1cm4gKGgxIF4gKGgxID4+PiAxNikpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgXCJPYmplY3RcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpLCAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITApO1xuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwO1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2BcIiwgYXR0cmlidXRlTmFtZSk7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHxcbiAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMub25JbnB1dCB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIChcInNlbGVjdFwiID09PSB0YWdOYW1lXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGBvbkNoYW5nZWAuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICAgICAgKSk7XG4gICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLmNoZWNrZWQgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkkMSh0YWdOYW1lLCBuYW1lKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJlxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV1cbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBcImFyaWEtXCIgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpIHJldHVybiAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgbmFtZSAhPT0gdGFnTmFtZSAmJlxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcykge1xuICAgICAgdmFyIGludmFsaWRQcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSkgfHwgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gaW52YWxpZFByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSBpbnZhbGlkUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgaW52YWxpZFByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKFwib25mb2N1c2luXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwib25mb2N1c291dFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCBhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICgoXCJmb3JtXCIgPT09IHRhZ05hbWUgJiYgXCJhY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJpbnB1dFwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImJ1dHRvblwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSkge1xuICAgICAgICB0YWdOYW1lID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgICBpZiAoZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgZXZlbnRSZWdpc3RyeSA9IHRhZ05hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgPyB0YWdOYW1lW2xvd2VyQ2FzZWROYW1lXVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50UmVnaXN0cnlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHJBUklBLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbC50ZXN0KG5hbWUpKSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJpbm5lcmh0bWxcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcImFyaWFcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuIFBhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJpc1wiID09PSBsb3dlckNhc2VkTmFtZSAmJlxuICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICB2b2lkIDAgIT09IHZhbHVlICYmXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBpc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGxvd2VyQ2FzZWROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSksXG4gICAgICAgICAgbG93ZXJDYXNlZE5hbWUgIT09IG5hbWUpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSBpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiBJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSBlbGVtZW50LlwiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcImFyaWEtXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG5JZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoXCJmYWxzZVwiID09PSB2YWx1ZSB8fCBcInRydWVcIiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJXMgRGlkIHlvdSBtZWFuICVzPXslc30/XCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBcImZhbHNlXCIgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBcIlRoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLlwiXG4gICAgICAgICAgICAgICAgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgdmFyIHVua25vd25Qcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpIHx8XG4gICAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gdW5rbm93blByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSB1bmtub3duUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IHVua25vd25Qcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB0ZXh0IHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0ZXh0IHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiB0ZXh0XG4gICAgICApXG4gICAgICAgIHJldHVybiBcIlwiICsgdGV4dDtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHRleHQpO1xuICAgICAgdGV4dCA9IFwiXCIgKyB0ZXh0O1xuICAgICAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWModGV4dCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBcIlwiLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxhc3RJbmRleCA9IDA7XG4gICAgICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCB0ZXh0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHN3aXRjaCAodGV4dC5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZxdW90O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImYW1wO1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImI3gyNztcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmx0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImZ3Q7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RJbmRleCAhPT0gaW5kZXggJiYgKGh0bWwgKz0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgIGh0bWwgKz0gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gICAgICByZXR1cm4gaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdChcIlwiICsgdXJsKVxuICAgICAgICA/IFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGhhcyBibG9ja2VkIGEgamF2YXNjcmlwdDogVVJMIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4nKVwiXG4gICAgICAgIDogdXJsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KHNjcmlwdFRleHQpIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHNjcmlwdFRleHQpO1xuICAgICAgcmV0dXJuIChcIlwiICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcsXG4gICAgICBib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgIGJvb3RzdHJhcE1vZHVsZXNcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkUHJlZml4OiB2b2lkIDAgPT09IGlkZW50aWZpZXJQcmVmaXggPyBcIlwiIDogaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgbmV4dEZvcm1JRDogMCxcbiAgICAgICAgc3RyZWFtaW5nRm9ybWF0OiAwLFxuICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50OiBib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgICBib290c3RyYXBTY3JpcHRzOiBib290c3RyYXBTY3JpcHRzLFxuICAgICAgICBib290c3RyYXBNb2R1bGVzOiBib290c3RyYXBNb2R1bGVzLFxuICAgICAgICBpbnN0cnVjdGlvbnM6IE5vdGhpbmdTZW50LFxuICAgICAgICBoYXNCb2R5OiAhMSxcbiAgICAgICAgaGFzSHRtbDogITEsXG4gICAgICAgIHVua25vd25SZXNvdXJjZXM6IHt9LFxuICAgICAgICBkbnNSZXNvdXJjZXM6IHt9LFxuICAgICAgICBjb25uZWN0UmVzb3VyY2VzOiB7IGRlZmF1bHQ6IHt9LCBhbm9ueW1vdXM6IHt9LCBjcmVkZW50aWFsczoge30gfSxcbiAgICAgICAgaW1hZ2VSZXNvdXJjZXM6IHt9LFxuICAgICAgICBzdHlsZVJlc291cmNlczoge30sXG4gICAgICAgIHNjcmlwdFJlc291cmNlczoge30sXG4gICAgICAgIG1vZHVsZVVua25vd25SZXNvdXJjZXM6IHt9LFxuICAgICAgICBtb2R1bGVTY3JpcHRSZXNvdXJjZXM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQcmVhbWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHRtbENodW5rczogbnVsbCxcbiAgICAgICAgaGVhZENodW5rczogbnVsbCxcbiAgICAgICAgYm9keUNodW5rczogbnVsbCxcbiAgICAgICAgY29udHJpYnV0aW9uOiBOb0NvbnRyaWJ1dGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlLCB0YWdTY29wZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgdGFnU2NvcGU6IHRhZ1Njb3BlXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMudmFsdWUgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCAyXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJmb3JlaWduT2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX0NPTEdST1VQX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIEhUTUxfSEVBRF9NT0RFLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIEhUTUxfSFRNTF9NT0RFLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUgfHxcbiAgICAgICAgcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFXG4gICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgIDogcGFyZW50Q29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgc3R5bGUpIHtcbiAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3R5bGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaXNGaXJzdCA9ICEwLFxuICAgICAgICBzdHlsZU5hbWU7XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBzdHlsZSlcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPSBzdHlsZVZhbHVlICYmXG4gICAgICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHN0eWxlVmFsdWUgJiZcbiAgICAgICAgICAgIFwiXCIgIT09IHN0eWxlVmFsdWVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICgwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lQ2h1bmsgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpO1xuICAgICAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgICAgICAgc3R5bGVWYWx1ZSA9IGVzY2FwZVRleHRGb3JCcm93c2VyKChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKC0xIDwgbmFtZUNodW5rLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgXCJtcy1cIikpXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lQ2h1bmspKVxuICAgICAgICAgICAgICAgIChuYW1lID0gbmFtZUNodW5rKSxcbiAgICAgICAgICAgICAgICAgICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWUkanNjb21wJDBdKSB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uIFRyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoaXNOYU4odmFsdWUpXG4gICAgICAgICAgICAgICAgICA/IHdhcm5lZEZvck5hTlZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9yTmFOVmFsdWUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IGlzRmluaXRlKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHlsZU5hbWVDYWNoZS5nZXQobmFtZUNodW5rKTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gKG5hbWVDaHVuayA9IHZhbHVlKVxuICAgICAgICAgICAgICAgIDogKCh2YWx1ZSA9IGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCBcIi0kMVwiKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobXNQYXR0ZXJuLCBcIi1tcy1cIilcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgc3R5bGVOYW1lQ2FjaGUuc2V0KG5hbWVDaHVuaywgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgKG5hbWVDaHVuayA9IHZhbHVlKSk7XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgPyAoc3R5bGVWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHN0eWxlVmFsdWUgfHwgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIlwiICsgc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIDogc3R5bGVWYWx1ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICA6IChjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgIChzdHlsZVZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpXG4gICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0ZpcnN0XG4gICAgICAgICAgICAgID8gKChpc0ZpcnN0ID0gITEpLFxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgICAgc3R5bGVBdHRyaWJ1dGVTdGFydCxcbiAgICAgICAgICAgICAgICAgIG5hbWVDaHVuayxcbiAgICAgICAgICAgICAgICAgIHN0eWxlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogdGFyZ2V0LnB1c2goc3R5bGVTZXBhcmF0b3IsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHN0eWxlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaXNGaXJzdCB8fCB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBuYW1lLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICAgICAgdGhpcy5wdXNoKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiJyk7XG4gICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUpO1xuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0aGlzLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGhpcywgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICB0aGlzLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkZpbGUvQmxvYiBmaWVsZHMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHByb2dyZXNzaXZlIGZvcm1zLiBXaWxsIGZhbGxiYWNrIHRvIGNsaWVudCBoeWRyYXRpb24uXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhyZXN1bWFibGVTdGF0ZSwgZm9ybUFjdGlvbikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTikge1xuICAgICAgICB2YXIgaWQgPSByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEKys7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICBpZiAoY3VzdG9tRmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YTtcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiYgZm9ybURhdGEuZm9yRWFjaCh2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3VzdG9tRmllbGRzO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgIClcbiAgICAgICAgICAgIHRocm93IHg7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIHNlcmlhbGl6ZSBhbiBhY3Rpb24gZm9yIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50OlxcbiVzXCIsXG4gICAgICAgICAgICB4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKFxuICAgICAgdGFyZ2V0LFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtVGFyZ2V0LFxuICAgICAgbmFtZVxuICAgICkge1xuICAgICAgdmFyIGZvcm1EYXRhID0gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmb3JtQWN0aW9uKSB7XG4gICAgICAgIG51bGwgPT09IG5hbWUgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IGEgXCJuYW1lXCIgcHJvcCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJ1xuICAgICAgICAgICkpO1xuICAgICAgICAobnVsbCA9PT0gZm9ybUVuY1R5cGUgJiYgbnVsbCA9PT0gZm9ybU1ldGhvZCkgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgKSk7XG4gICAgICAgIG51bGwgPT09IGZvcm1UYXJnZXQgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtVGFyZ2V0IGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICkpO1xuICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhyZXN1bWFibGVTdGF0ZSwgZm9ybUFjdGlvbik7XG4gICAgICAgIG51bGwgIT09IGN1c3RvbUZpZWxkc1xuICAgICAgICAgID8gKChuYW1lID0gY3VzdG9tRmllbGRzLm5hbWUpLFxuICAgICAgICAgICAgKGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgKGZvcm1FbmNUeXBlID0gY3VzdG9tRmllbGRzLmVuY1R5cGUpLFxuICAgICAgICAgICAgKGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kKSxcbiAgICAgICAgICAgIChmb3JtVGFyZ2V0ID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAoZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YSkpXG4gICAgICAgICAgOiAodGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGZvcm1UYXJnZXQgPSBmb3JtTWV0aG9kID0gZm9ybUVuY1R5cGUgPSBmb3JtQWN0aW9uID0gbmFtZSA9IG51bGwpLFxuICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICB9XG4gICAgICBudWxsICE9IG5hbWUgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtQWN0aW9uXCIsIGZvcm1BY3Rpb24pO1xuICAgICAgbnVsbCAhPSBmb3JtRW5jVHlwZSAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtRW5jVHlwZVwiLCBmb3JtRW5jVHlwZSk7XG4gICAgICBudWxsICE9IGZvcm1NZXRob2QgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybU1ldGhvZFwiLCBmb3JtTWV0aG9kKTtcbiAgICAgIG51bGwgIT0gZm9ybVRhcmdldCAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtVGFyZ2V0XCIsIGZvcm1UYXJnZXQpO1xuICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwiY2xhc3NcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGFiSW5kZXhcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ0YWJpbmRleFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXJcIjpcbiAgICAgICAgY2FzZSBcInJvbGVcIjpcbiAgICAgICAgY2FzZSBcInZpZXdCb3hcIjpcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICBpZiAoXCJcIiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIFwic3JjXCIgPT09IG5hbWVcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUaGlzIG1heSBjYXVzZSB0aGUgYnJvd3NlciB0byBkb3dubG9hZCB0aGUgd2hvbGUgcGFnZSBhZ2FpbiBvdmVyIHRoZSBuZXR3b3JrLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgIFwieGxpbms6aHJlZlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgIFwiXCIgIT09IHZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbbmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW25hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiBlbXB0eSBzdHJpbmcgZm9yIGEgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gVGhpcyB3aWxsIHRyZWF0IHRoZSBhdHRyaWJ1dGUgYXMgaWYgaXQgd2VyZSBmYWxzZS4gRWl0aGVyIHBhc3MgYGZhbHNlYCB0byBzaWxlbmNlIHRoaXMgd2FybmluZywgb3IgcGFzcyBgdHJ1ZWAgaWYgeW91IHVzZWQgYW4gZW1wdHkgc3RyaW5nIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgUmVhY3QgdG8gaW5kaWNhdGUgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBuYW1lLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICEwID09PSB2YWx1ZVxuICAgICAgICAgICAgPyB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKVxuICAgICAgICAgICAgOiAhMSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgICAgMSA8PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YWN0dWF0ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphcmNyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnJvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6c2hvd1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dGl0bGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmJhc2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpsYW5nXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOnNwYWNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKDIgPCBuYW1lLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChcIm9cIiAhPT0gbmFtZVswXSAmJiBcIk9cIiAhPT0gbmFtZVswXSkgfHxcbiAgICAgICAgICAgIChcIm5cIiAhPT0gbmFtZVsxXSAmJiBcIk5cIiAhPT0gbmFtZVsxXSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgobmFtZSA9IGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWUpLCBpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4ICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4KSByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCkge1xuICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCB8fCAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICBpbm5lckhUTUwgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgICBudWxsICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihpbm5lckhUTUwpLCB0YXJnZXQucHVzaChcIlwiICsgaW5uZXJIVE1MKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgKCh2YWx1ZSA9IGlzQXJyYXlJbXBsKHZhbHVlKSksXG4gICAgICAgIHByb3BzLm11bHRpcGxlICYmICF2YWx1ZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgYG11bHRpcGxlYCBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogIXByb3BzLm11bHRpcGxlICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgdmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS5cIixcbiAgICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgKChjb250ZW50ICs9IGNoaWxkKSxcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbm5vdCBpbmZlciB0aGUgb3B0aW9uIHZhbHVlIG9mIGNvbXBsZXggY2hpbGRyZW4uIFBhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LlwiXG4gICAgICAgICAgICApKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiAxNikgPT09IE5vdGhpbmdTZW50ICYmXG4gICAgICAgICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IDE2KSxcbiAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQoXG4gICAgICAgICAgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsXG4gICAgICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQsXG4gICAgICAgICAgXCJcXHgzYy9zY3JpcHQ+XCJcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwibGlua1wiKSk7XG4gICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwibGluayBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHlsZVRleHRDb250ZW50KHN0eWxlVGV4dCkge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3R5bGVUZXh0KTtcbiAgICAgIHJldHVybiAoXCJcIiArIHN0eWxlVGV4dCkucmVwbGFjZShzdHlsZVJlZ2V4LCBzdHlsZVJlcGxhY2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRpdGxlSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwidGl0bGVcIikpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgaW5uZXJIVE1MID0gbnVsbCxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHByb3BzID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgPyAyID4gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgPyBjaGlsZHJlblswXVxuICAgICAgICAgIDogbnVsbFxuICAgICAgICA6IGNoaWxkcmVuO1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcHMgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHByb3BzICYmXG4gICAgICAgIG51bGwgIT09IHByb3BzICYmXG4gICAgICAgIHZvaWQgMCAhPT0gcHJvcHMgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHByb3BzKSk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyhcInRpdGxlXCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwic2NyaXB0XCIpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBudWxsICE9IGNoaWxkcmVuICYmXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBjaGlsZHJlbiAmJlxuICAgICAgICAoKHByb3BzID1cbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGRyZW5cbiAgICAgICAgICAgID8gXCJhIG51bWJlciBmb3IgY2hpbGRyZW5cIlxuICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgICAgICA/IFwiYW4gYXJyYXkgZm9yIGNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgOiBcInNvbWV0aGluZyB1bmV4cGVjdGVkIGZvciBjaGlsZHJlblwiKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc2NyaXB0IGVsZW1lbnQgd2FzIHJlbmRlcmVkIHdpdGggJXMuIElmIHNjcmlwdCBlbGVtZW50IGhhcyBjaGlsZHJlbiBpdCBtdXN0IGJlIGEgc2luZ2xlIHN0cmluZy4gQ29uc2lkZXIgdXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgb3IgcGFzc2luZyBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbi5cIixcbiAgICAgICAgICBwcm9wc1xuICAgICAgICApKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiAmJlxuICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KGNoaWxkcmVuKSk7XG4gICAgICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyhcInNjcmlwdFwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gKHRhZyA9IG51bGwpLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIHRhZyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIHRhZyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gKHRhZyA9IG51bGwpLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIHRhZyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIHRhZyk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRhZ1xuICAgICAgICA/ICh0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0YWcpKSwgbnVsbClcbiAgICAgICAgOiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSB7XG4gICAgICB2YXIgdGFnU3RhcnRDaHVuayA9IHZhbGlkYXRlZFRhZ0NhY2hlLmdldCh0YWcpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdGFnU3RhcnRDaHVuaykge1xuICAgICAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHRocm93IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICAgICAgdGFnU3RhcnRDaHVuayA9IFwiPFwiICsgdGFnO1xuICAgICAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWdTdGFydENodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBwcmVhbWJsZVN0YXRlLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkLFxuICAgICAgaXNGYWxsYmFja1xuICAgICkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIGI6IGlmICgtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSkgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuICAgICAgIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJlxuICAgICAgICBwcm9wcy5jb250ZW50RWRpdGFibGUgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmXG4gICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUgJiZcbiAgICAgICAgLTEgPT09IHR5cGUuaW5kZXhPZihcIi1cIikgJiZcbiAgICAgICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImFcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBwcm9wVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImhyZWZcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBjaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsIFwiZGVmYXVsdFZhbHVlXCIpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITApKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic2VsZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMCwgY2hpbGRyZW4kanNjb21wJDApO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMDtcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvcHRpb25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDFdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiBzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgPT09IGlubmVySFRNTCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoc2VsZWN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sIFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZVtpXSA9PT0gc3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaCgnIHNlbGVjdGVkPVwiXCInKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWUsIFwic2VsZWN0LnZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goJyBzZWxlY3RlZD1cIlwiJyk7XG4gICAgICAgICAgfSBlbHNlIHNlbGVjdGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKCcgc2VsZWN0ZWQ9XCJcIicpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwkanNjb21wJDEsIGNoaWxkcmVuJGpzY29tcCQxKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDE7XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJ0ZXh0YXJlYVwiLCBwcm9wcyk7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQyO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMiBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQyKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQyID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMl07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDIpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IHZhbHVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBkZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZSRqc2NvbXAkMCA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4kanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIGlmICgxIDwgY2hpbGRyZW4kanNjb21wJDIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDJbMF0pO1xuICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IFwiXCIgKyBjaGlsZHJlbiRqc2NvbXAkMlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuJGpzY29tcCQyKTtcbiAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IHZhbHVlJGpzY29tcCQwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlJGpzY29tcCQwLCBcInZhbHVlXCIpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHZhbHVlJGpzY29tcCQwKSkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgdmFsdWUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDMpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0IGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkM1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uIHx8XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBudWxsID09PSBjaGVja2VkIHx8XG4gICAgICAgICAgICBudWxsID09PSBkZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDEgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIG51bGwgIT09IGNoZWNrZWRcbiAgICAgICAgICAgID8gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgY2hlY2tlZClcbiAgICAgICAgICAgIDogbnVsbCAhPT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgZGVmYXVsdENoZWNrZWQpO1xuICAgICAgICAgIG51bGwgIT09IHZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICA/IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcInZhbHVlXCIsIHZhbHVlJGpzY29tcCQxKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0VmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgZGVmYXVsdFZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYnV0dG9uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDMgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDRdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDQpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBuYW1lJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1FbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1UYXJnZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEkanNjb21wJDAgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDAgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhJGpzY29tcCQwLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMiwgY2hpbGRyZW4kanNjb21wJDMpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDMpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQzKSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gY2hpbGRyZW4kanNjb21wJDM7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiZm9ybVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ1O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ1KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ1ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ1XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24kanNjb21wJDEpIHtcbiAgICAgICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJiBudWxsID09PSBmb3JtTWV0aG9kJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICAgICAgPyAoKGZvcm1BY3Rpb24kanNjb21wJDEgPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIChmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgICAgICAoZm9ybU1ldGhvZCRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgICAgIChmb3JtVGFyZ2V0JGpzY29tcCQxID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAgICAgKGZvcm1EYXRhJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmRhdGEpLFxuICAgICAgICAgICAgICAgIChmb3JtQWN0aW9uTmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSlcbiAgICAgICAgICAgICAgOiAodGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCksXG4gICAgICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiYWN0aW9uXCIsIGZvcm1BY3Rpb24kanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImVuY1R5cGVcIiwgZm9ybUVuY1R5cGUkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibWV0aG9kXCIsIGZvcm1NZXRob2QkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybVRhcmdldCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidGFyZ2V0XCIsIGZvcm1UYXJnZXQkanNjb21wJDEpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1BY3Rpb25OYW1lICYmXG4gICAgICAgICAgICAodGFyZ2V0JGpzY29tcCQwLnB1c2goJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKSxcbiAgICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcIm5hbWVcIiwgZm9ybUFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKSxcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMywgY2hpbGRyZW4kanNjb21wJDQpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDQpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ0KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gY2hpbGRyZW4kanNjb21wJDQ7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjtcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm1lbnVpdGVtXCIpKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5JGpzY29tcCQ2IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDYpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDYgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ2XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwib2JqZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDc7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ3IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDcpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDcgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ3XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wVmFsdWUkanNjb21wJDcsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHByb3BWYWx1ZSRqc2NvbXAkNyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09PSBzYW5pdGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzYW5pdGl6ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkNCwgY2hpbGRyZW4kanNjb21wJDUpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDUpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ1KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gY2hpbGRyZW4kanNjb21wJDU7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgdmFyIGluc2VydGlvbk1vZGUgPSBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgICAgICBub3NjcmlwdFRhZ0luU2NvcGUgPSAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSk7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiY2hpbGRyZW5cIikpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDYpXG4gICAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ2WzBdXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ2O1xuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNikgJiYgMSA8IGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBBcnJheSB3aXRoIGxlbmd0aCAlcyBpbnN0ZWFkLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSBBcnJheXMgb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3Qgc3VwcG9ydGVkLiBXaGVuIHVzaW5nIEpTWCBpdCBjYW4gYmUgY29tbW9uIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkIHx8IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZFxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkID8gXCJhIEZ1bmN0aW9uXCIgOiBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChudWxsICE9IGNoaWxkLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPiBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgcmVsID0gcHJvcHMucmVsLFxuICAgICAgICAgICAgaHJlZiA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiAodGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICA6IHB1c2hMaW5rSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDU7XG4gICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICB2YXIgYXN5bmNQcm9wID0gcHJvcHMuYXN5bmM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIXByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIWFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkxvYWQgfHxcbiAgICAgICAgICAgIHByb3BzLm9uRXJyb3IgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IHB1c2hTY3JpcHRJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzLnNyYztcbiAgICAgICAgICAgIGlmIChcIm1vZHVsZVwiID09PSBwcm9wcy50eXBlKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcyksXG4gICAgICAgICAgICAgICAgKHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cyk7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCA9IHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgID8gcmVzb3VyY2VzW2tleV1cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgICAgICAgICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlJGpzY29tcCQwLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgKChzY3JpcHRQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMpKSxcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHNjcmlwdFByb3BzLCByZXNvdXJjZVN0YXRlJGpzY29tcCQwKSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCA9IHByZWxvYWRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgKHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMC5sZW5ndGggPSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UkanNjb21wJDAgPSBbXTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UkanNjb21wJDApO1xuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChyZXNvdXJjZSRqc2NvbXAkMCwgc2NyaXB0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDcgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQkanNjb21wJDAgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ3Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkN1swXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNztcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZCRqc2NvbXAkMCkpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEluIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICA/IFwiYSBGdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICA6IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICA/IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYW4gQXJyYXlcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZSRqc2NvbXAkMCA9IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmJGpzY29tcCQwID0gcHJvcHMuaHJlZjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWYkanNjb21wJDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4O1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ4IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ4ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOF07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ4KVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDhcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDgpXG4gICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDhbMF1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkODtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoY2hpbGQkanNjb21wJDEpKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZENodW5rRm9yVGFnKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYkanNjb21wJDAuaW5jbHVkZXMoXCIgXCIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1JlYWN0IGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCBmb3IgYSA8c3R5bGU+IHRhZyBvcHRpbmcgaW50byBob2lzdGluZyBzZW1hbnRpY3MgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHRvIG5vdCBoYXZlIGFueSBzcGFjZXMgYnV0IGVjb3VudGVyZWQgc3BhY2VzIGluc3RlYWQuIHVzaW5nIHNwYWNlcyBpbiB0aGlzIHByb3Agd2lsbCBjYXVzZSBoeWRyYXRpb24gb2YgdGhpcyBzdHlsZSB0byBmYWlsIG9uIHRoZSBjbGllbnQuIFRoZSBocmVmIGZvciB0aGUgPHN0eWxlPiB3aGVyZSB0aGlzIG9jdXJyZWQgaXMgXCIlc1wiLicsXG4gICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQxICE9PSBFWElTVFMpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZiRqc2NvbXAkMF0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgaG9pc3RhYmxlIHN0eWxlIHRhZyBmb3IgdGhlIHNhbWUgaHJlZiBhcyBhIHByZWxvYWQ6IFwiJXNcIi4gV2hlbiB1c2luZyBhIHN0eWxlIHRhZyB0byBpbmxpbmUgc3R5bGVzIHlvdSBzaG91bGQgbm90IGFsc28gcHJlbG9hZCBpdCBhcyBhIHN0eWxzaGVldC4nLFxuICAgICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/IHN0eWxlUXVldWUkanNjb21wJDAuaHJlZnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6ICgoc3R5bGVRdWV1ZSRqc2NvbXAkMCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmJGpzY29tcCQwKV0sXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2UkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3R5bGVRdWV1ZSRqc2NvbXAkMC5ydWxlcyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IG51bGwsXG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ5O1xuICAgICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ5ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOV07XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDkpXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDkgPSBwcm9wVmFsdWUkanNjb21wJDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNiA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNoaWxkJGpzY29tcCQyID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDlbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDk7XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMikpO1xuICAgICAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MJGpzY29tcCQ2LCBjaGlsZHJlbiRqc2NvbXAkOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSRqc2NvbXAkMCk7XG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3O1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jaGFyU2V0XG4gICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICA6IFwidmlld3BvcnRcIiA9PT0gcHJvcHMubmFtZVxuICAgICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcywgcHJvcHMsIFwibWV0YVwiKVxuICAgICAgICAgICAgICAgICAgICA6IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4O1xuICAgICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgICBjYXNlIFwicHJlXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDcgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQxMCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMTAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQxMF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMTApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMCA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBpbm5lckhUTUwkanNjb21wJDcpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGNoaWxkcmVuJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5uZXJIVE1MJGpzY29tcCQ3IHx8XG4gICAgICAgICAgICAgICEoXCJfX2h0bWxcIiBpbiBpbm5lckhUTUwkanNjb21wJDcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gaW5uZXJIVE1MJGpzY29tcCQ3Ll9faHRtbDtcbiAgICAgICAgICAgIG51bGwgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBodG1sICYmXG4gICAgICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHRtbCAmJiAwIDwgaHRtbC5sZW5ndGggJiYgXCJcXG5cIiA9PT0gaHRtbFswXVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0JGpzY29tcCQwLnB1c2gobGVhZGluZ05ld2xpbmUsIGh0bWwpXG4gICAgICAgICAgICAgICAgOiAoY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCksXG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcIlwiICsgaHRtbCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuJGpzY29tcCQxMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gY2hpbGRyZW4kanNjb21wJDEwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgIHZhciBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICAgICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgXCJsYXp5XCIgPT09IHByb3BzLmxvYWRpbmcgfHxcbiAgICAgICAgICAgICAgKCFzcmMgJiYgIXNyY1NldCkgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgJiYgbnVsbCAhPSBzcmMpIHx8XG4gICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0ICYmIG51bGwgIT0gc3JjU2V0KVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgXCJsb3dcIiAhPT0gcHJvcHMuZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgITEgPT09ICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAzKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1s0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1swXSAmJiBcIkRcIiAhPT0gc3JjWzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1sxXSAmJiBcIkFcIiAhPT0gc3JjWzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1syXSAmJiBcIlRcIiAhPT0gc3JjWzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1szXSAmJiBcIkFcIiAhPT0gc3JjWzNdKSkgJiZcbiAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0IHx8XG4gICAgICAgICAgICAgIFwiOlwiICE9PSBzcmNTZXRbNF0gfHxcbiAgICAgICAgICAgICAgKFwiZFwiICE9PSBzcmNTZXRbMF0gJiYgXCJEXCIgIT09IHNyY1NldFswXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbMV0gJiYgXCJBXCIgIT09IHNyY1NldFsxXSkgfHxcbiAgICAgICAgICAgICAgKFwidFwiICE9PSBzcmNTZXRbMl0gJiYgXCJUXCIgIT09IHNyY1NldFsyXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbM10gJiYgXCJBXCIgIT09IHNyY1NldFszXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuc2l6ZXMgPyBwcm9wcy5zaXplcyA6IHZvaWQgMCxcbiAgICAgICAgICAgICAga2V5JGpzY29tcCQwID0gc3JjU2V0ID8gc3JjU2V0ICsgXCJcXG5cIiArIChzaXplcyB8fCBcIlwiKSA6IHNyYyxcbiAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLFxuICAgICAgICAgICAgICByZXNvdXJjZSRqc2NvbXAkMSA9IHByb21vdGFibGVQcmVsb2Fkcy5nZXQoa2V5JGpzY29tcCQwKTtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZSRqc2NvbXAkMSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICAxMCA+IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLnNpemVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5kZWxldGUoa2V5JGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5JGpzY29tcCQwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzW2tleSRqc2NvbXAkMF0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy5jcm9zc09yaWdpbjtcbiAgICAgICAgICAgICAgdmFyIGNyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXRcbiAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgaGVhZGVyO1xuICAgICAgICAgICAgICBoZWFkZXJzICYmXG4gICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5zcmNTZXQgJiZcbiAgICAgICAgICAgICAgKFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgNTAwID4gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKHNyYywgXCJpbWFnZVwiLCB7XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQ6IHByb3BzLnNyY1NldCxcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVzOiBwcm9wcy5zaXplcyxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJlclBvbGljeVxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIDAgPD0gKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgocmVzb3VyY2UkanNjb21wJDEgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UkanNjb21wJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogc3JjU2V0ID8gdm9pZCAwIDogc3JjLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldDogc3JjU2V0LFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNpemVzOiBzaXplcyxcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgICAxMCA+IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpLFxuICAgICAgICAgICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5zZXQoa2V5JGpzY29tcCQwLCByZXNvdXJjZSRqc2NvbXAkMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQkanNjb21wJDAsIHByb3BzLCBcImltZ1wiKTtcbiAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgY2FzZSBcImFyZWFcIjpcbiAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICAgIGNhc2UgXCJwYXJhbVwiOlxuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgICAgICBjYXNlIFwid2JyXCI6XG4gICAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQkanNjb21wJDAsIHByb3BzLCB0eXBlKTtcbiAgICAgICAgY2FzZSBcImFubm90YXRpb24teG1sXCI6XG4gICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1zcmNcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6XG4gICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZS5oZWFkQ2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGhlYWQ+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBwcmVhbWJsZS5oZWFkQ2h1bmtzID0gW107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5ID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUuaGVhZENodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaGVhZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5ID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaGVhZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDk7XG4gICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQwID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGJvZHk+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzID0gW107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImJvZHlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTAgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJib2R5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTA7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMSA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUkanNjb21wJDEuaHRtbENodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxodG1sPmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDEuaHRtbENodW5rcyA9IFtkb2N0eXBlQ2h1bmtdO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTEgPSBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KFxuICAgICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDExID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaHRtbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDExO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICgtMSAhPT0gdHlwZS5pbmRleE9mKFwiLVwiKSkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDExID0gbnVsbCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4ID0gbnVsbCxcbiAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTE7XG4gICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDExIGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMTEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMTEgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQxMV07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExID0gcHJvcFZhbHVlJGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgcHJvcFZhbHVlJGpzY29tcCQxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJjbGFzc1wiO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlTmFtZVNhZmUocHJvcEtleSRqc2NvbXAkMTEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IHByb3BWYWx1ZSRqc2NvbXAkMTFcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gcHJvcFZhbHVlJGpzY29tcCQxMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxMSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSRqc2NvbXAkMTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIGNodW5rID0gZW5kVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICB2b2lkIDAgPT09IGNodW5rICYmXG4gICAgICAgICgoY2h1bmsgPSBcIjwvXCIgKyB0YWcgKyBcIj5cIiksIGVuZFRhZ0NhY2hlLnNldCh0YWcsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0UHJlYW1ibGVTdGF0ZShyZW5kZXJTdGF0ZSwgcHJlYW1ibGVTdGF0ZSkge1xuICAgICAgcmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlLmh0bWxDaHVua3MgJiZcbiAgICAgICAgcHJlYW1ibGVTdGF0ZS5odG1sQ2h1bmtzICYmXG4gICAgICAgICgocmVuZGVyU3RhdGUuaHRtbENodW5rcyA9IHByZWFtYmxlU3RhdGUuaHRtbENodW5rcyksXG4gICAgICAgIChwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbiB8PSAxKSk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyAmJlxuICAgICAgICAoKHJlbmRlclN0YXRlLmhlYWRDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmhlYWRDaHVua3MpLFxuICAgICAgICAocHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb24gfD0gNCkpO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MgJiZcbiAgICAgICAgKChyZW5kZXJTdGF0ZS5ib2R5Q2h1bmtzID0gcHJlYW1ibGVTdGF0ZS5ib2R5Q2h1bmtzKSxcbiAgICAgICAgKHByZWFtYmxlU3RhdGUuY29udHJpYnV0aW9uIHw9IDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVuZGVyU3RhdGUubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlW2ldKTtcbiAgICAgIHJldHVybiBpIDwgcmVuZGVyU3RhdGUubGVuZ3RoXG4gICAgICAgID8gKChpID0gcmVuZGVyU3RhdGVbaV0pLCAocmVuZGVyU3RhdGUubGVuZ3RoID0gMCksIGRlc3RpbmF0aW9uLnB1c2goaSkpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxKTtcbiAgICAgIGlmIChudWxsID09PSBpZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBbiBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBiZWZvcmUgd2UgY2FuIGNvbXBsZXRlIHRoZSBib3VuZGFyeS5cIlxuICAgICAgICApO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5ib3VuZGFyeVByZWZpeCk7XG4gICAgICByZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVByZWFtYmxlQ29udHJpYnV0aW9uKGRlc3RpbmF0aW9uLCBwcmVhbWJsZVN0YXRlKSB7XG4gICAgICBwcmVhbWJsZVN0YXRlID0gcHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb247XG4gICAgICBwcmVhbWJsZVN0YXRlICE9PSBOb0NvbnRyaWJ1dGlvbiAmJlxuICAgICAgICAoZGVzdGluYXRpb24ucHVzaChib3VuZGFyeVByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmtTdGFydCksXG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2goXCJcIiArIHByZWFtYmxlU3RhdGUpLFxuICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua0VuZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSEVBRF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRIVE1MKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudEhUTUwyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50U1ZHKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFNWRzIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRNYXRoTUwpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50TWF0aE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZUJvZHkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGVCb2R5MilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGVSb3cpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGVSb3cyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudENvbEdyb3VwKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudENvbEdyb3VwMilcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICAgICAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICAgICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hFQURfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudEhUTUwpO1xuICAgICAgICBjYXNlIFNWR19NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRTVkcpO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRNYXRoTUwpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50VGFibGUpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFRhYmxlUm93KTtcbiAgICAgICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudENvbEdyb3VwKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyxcbiAgICAgICAgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwMjZcIjtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzZVwiO1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnkoc3R5bGVRdWV1ZSkge1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgMCA8IHJ1bGVzLmxlbmd0aCAmJlxuICAgICAgICAwID09PSBocmVmcy5sZW5ndGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGhyZWYgZm9yIGFuIGEgaG9pc3RhYmxlIHN0eWxlIGJ1dCBmb3VuZCBub25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaChsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgICAgIGZvciAodGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIpOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIHRoaXMucHVzaChocmVmc1tpXSksIHRoaXMucHVzaChzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIHRoaXMucHVzaChocmVmc1tpXSk7XG4gICAgICAgIHRoaXMucHVzaChsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB0aGlzLnB1c2gocnVsZXNbaV0pO1xuICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UpO1xuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMDtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzU3R5bGVzVG9Ib2lzdChzdHlsZXNoZWV0KSB7XG4gICAgICByZXR1cm4gc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEVcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITApXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMTtcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSAhMDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ICYmXG4gICAgICAgIChyZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gITApO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHRoaXMucHVzaChyZXNvdXJjZVtpXSk7XG4gICAgICByZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlSW5QcmVhbWJsZShzdHlsZXNoZWV0KSB7XG4gICAgICBwdXNoTGlua0ltcGwoc3R5bGVzaGVldEZsdXNoaW5nUXVldWUsIHN0eWxlc2hlZXQucHJvcHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW2ldKTtcbiAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFQU1CTEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVzSW5QcmVhbWJsZShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgaGFzU3R5bGVzaGVldHMgPSAwIDwgc3R5bGVRdWV1ZS5zaGVldHMuc2l6ZTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2goZmx1c2hTdHlsZUluUHJlYW1ibGUsIHRoaXMpO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgICAgIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXMsXG4gICAgICAgIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcbiAgICAgIGlmICghaGFzU3R5bGVzaGVldHMgfHwgaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgICAgICB0aGlzLnB1c2goc3R5bGVRdWV1ZS5wcmVjZWRlbmNlKTtcbiAgICAgICAgc3R5bGVRdWV1ZSA9IDA7XG4gICAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdGhpcy5wdXNoKHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlIDwgaHJlZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHRoaXMucHVzaChocmVmc1tzdHlsZVF1ZXVlXSksIHRoaXMucHVzaChzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgICAgdGhpcy5wdXNoKGhyZWZzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2goc3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcbiAgICAgICAgZm9yIChzdHlsZVF1ZXVlID0gMDsgc3R5bGVRdWV1ZSA8IHJ1bGVzLmxlbmd0aDsgc3R5bGVRdWV1ZSsrKVxuICAgICAgICAgIHRoaXMucHVzaChydWxlc1tzdHlsZVF1ZXVlXSk7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpO1xuICAgICAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgICAgICBocmVmcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICAgICAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgdmFyIHByb3BzID0gc3R5bGVzaGVldC5wcm9wcztcbiAgICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCB7XG4gICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgIGhyZWY6IHN0eWxlc2hlZXQucHJvcHMuaHJlZixcbiAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgICAgICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBzdHlsZXNoZWV0ID0gMDtcbiAgICAgICAgICBzdHlsZXNoZWV0IDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoO1xuICAgICAgICAgIHN0eWxlc2hlZXQrK1xuICAgICAgICApXG4gICAgICAgICAgdGhpcy5wdXNoKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW3N0eWxlc2hlZXRdKTtcbiAgICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZXMoc3R5bGVRdWV1ZSkge1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlLCB0aGlzKTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5Rmlyc3RPcGVuQnJhY2tldCk7XG4gICAgICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgICBpZiAocmVzb3VyY2Uuc3RhdGUgIT09IFBSRUFNQkxFKVxuICAgICAgICAgIGlmIChyZXNvdXJjZS5zdGF0ZSA9PT0gTEFURSlcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gobmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspLFxuICAgICAgICAgICAgICAocmVzb3VyY2UgPSByZXNvdXJjZS5wcm9wcy5ocmVmKSxcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihyZXNvdXJjZSwgXCJocmVmXCIpLFxuICAgICAgICAgICAgICAocmVzb3VyY2UgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhcIlwiICsgcmVzb3VyY2UpKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZXNvdXJjZSksXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlDbG9zZUJyYWNrZXQpLFxuICAgICAgICAgICAgICAobmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlID0gcmVzb3VyY2UucHJvcHNbXCJkYXRhLXByZWNlZGVuY2VcIl0sXG4gICAgICAgICAgICAgIHByb3BzID0gcmVzb3VyY2UucHJvcHMsXG4gICAgICAgICAgICAgIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoXCJcIiArIHJlc291cmNlLnByb3BzLmhyZWYpO1xuICAgICAgICAgICAgY29lcmNlZEhyZWYgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZik7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvZXJjZWRIcmVmKTtcbiAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgXCJwcmVjZWRlbmNlXCIpO1xuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IFwiXCIgKyBwcmVjZWRlbmNlO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMocHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpICYmXG4gICAgICAgICAgICAgICAgKChwcmVjZWRlbmNlID0gcHJvcHNbcHJvcEtleV0pLCBudWxsICE9IHByZWNlZGVuY2UpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVsXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicHJlY2VkZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGEtcHJlY2VkZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGluayBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKFxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgICAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJjbGFzc1wiO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICBpZiAoITEgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgICAgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgyIDwgbmFtZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKFwib1wiID09PSBuYW1lWzBdIHx8IFwiT1wiID09PSBuYW1lWzBdKSAmJlxuICAgICAgICAgICAgICAoXCJuXCIgPT09IG5hbWVbMV0gfHwgXCJOXCIgPT09IG5hbWVbMV0pKSB8fFxuICAgICAgICAgICAgIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgYXR0cmlidXRlTmFtZSA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgYXR0cmlidXRlTmFtZSA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKG5hbWUpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBzdHlsZXM6IG5ldyBTZXQoKSwgc3R5bGVzaGVldHM6IG5ldyBTZXQoKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgaHJlZixcbiAgICAgIHByb3BzXG4gICAgKSB7XG4gICAgICAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpIHx8XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnSW50ZXJuYWwgUmVhY3QgRXJyb3I6IFJlYWN0IGV4cGVjdGVkIGJvb3RzdHJhcCBzY3JpcHQgb3IgbW9kdWxlIHdpdGggc3JjIFwiJXNcIiB0byBub3QgaGF2ZSBiZWVuIHByZWxvYWRlZCBhbHJlYWR5LiBwbGVhc2UgZmlsZSBhbiBpc3N1ZScsXG4gICAgICAgICAgaHJlZlxuICAgICAgICApO1xuICAgICAgcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgcmVzdW1hYmxlU3RhdGUgPSBbXTtcbiAgICAgIHB1c2hMaW5rSW1wbChyZXN1bWFibGVTdGF0ZSwgcHJvcHMpO1xuICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZG9wdFByZWxvYWRDcmVkZW50aWFscyh0YXJnZXQsIHByZWxvYWRTdGF0ZSkge1xuICAgICAgbnVsbCA9PSB0YXJnZXQuY3Jvc3NPcmlnaW4gJiYgKHRhcmdldC5jcm9zc09yaWdpbiA9IHByZWxvYWRTdGF0ZVswXSk7XG4gICAgICBudWxsID09IHRhcmdldC5pbnRlZ3JpdHkgJiYgKHRhcmdldC5pbnRlZ3JpdHkgPSBwcmVsb2FkU3RhdGVbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIHBhcmFtcykge1xuICAgICAgaHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgICAgIGFzID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGFzLCBcImFzXCIpO1xuICAgICAgYXMgPSBcIjxcIiArIGhyZWYgKyAnPjsgcmVsPXByZWxvYWQ7IGFzPVwiJyArIGFzICsgJ1wiJztcbiAgICAgIGZvciAodmFyIHBhcmFtTmFtZSBpbiBwYXJhbXMpXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpICYmXG4gICAgICAgICAgKChocmVmID0gcGFyYW1zW3BhcmFtTmFtZV0pLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgICAgICAoYXMgKz1cbiAgICAgICAgICAgICAgXCI7IFwiICtcbiAgICAgICAgICAgICAgcGFyYW1OYW1lLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAnPVwiJyArXG4gICAgICAgICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVxuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiJykpO1xuICAgICAgcmV0dXJuIGFzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZklucHV0KSB7XG4gICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWZJbnB1dCwgXCJocmVmXCIpO1xuICAgICAgcmV0dXJuIChcIlwiICsgaHJlZklucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0LFxuICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0NcIjtcbiAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0VcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIiUwQVwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImVzY2FwZUxpbmtIcmVmRm9ySGVhZGVyQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KHZhbHVlLCBuYW1lKSB7XG4gICAgICB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkgJiZcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBvcHRpb24gaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSk7XG4gICAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQsXG4gICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgcmV0dXJuIFwiJTIyXCI7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTI3XCI7XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNCXCI7XG4gICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTJDXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlMEFcIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIiUwRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3koc3R5bGVRdWV1ZSkge1xuICAgICAgdGhpcy5zdHlsZXMuYWRkKHN0eWxlUXVldWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5KHN0eWxlc2hlZXQpIHtcbiAgICAgIHRoaXMuc3R5bGVzaGVldHMuYWRkKHN0eWxlc2hlZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGF0ZShyZXN1bWFibGVTdGF0ZSwgZ2VuZXJhdGVTdGF0aWNNYXJrdXApIHtcbiAgICAgIHZhciBpZFByZWZpeCA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4LFxuICAgICAgICBib290c3RyYXBDaHVua3MgPSBbXSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRzLFxuICAgICAgICBib290c3RyYXBNb2R1bGVzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwTW9kdWxlcztcbiAgICAgIHZvaWQgMCAhPT0gYm9vdHN0cmFwU2NyaXB0Q29udGVudCAmJlxuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICBcIjxzY3JpcHQ+XCIsXG4gICAgICAgICAgZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChib290c3RyYXBTY3JpcHRDb250ZW50KSxcbiAgICAgICAgICBcIlxceDNjL3NjcmlwdD5cIlxuICAgICAgICApO1xuICAgICAgaWRQcmVmaXggPSB7XG4gICAgICAgIHBsYWNlaG9sZGVyUHJlZml4OiBpZFByZWZpeCArIFwiUDpcIixcbiAgICAgICAgc2VnbWVudFByZWZpeDogaWRQcmVmaXggKyBcIlM6XCIsXG4gICAgICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeCArIFwiQjpcIixcbiAgICAgICAgc3RhcnRJbmxpbmVTY3JpcHQ6IFwiPHNjcmlwdD5cIixcbiAgICAgICAgcHJlYW1ibGU6IGNyZWF0ZVByZWFtYmxlU3RhdGUoKSxcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBudWxsLFxuICAgICAgICBib290c3RyYXBDaHVua3M6IGJvb3RzdHJhcENodW5rcyxcbiAgICAgICAgaW1wb3J0TWFwQ2h1bmtzOiBbXSxcbiAgICAgICAgb25IZWFkZXJzOiB2b2lkIDAsXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIHJlc2V0czoge1xuICAgICAgICAgIGZvbnQ6IHt9LFxuICAgICAgICAgIGRuczoge30sXG4gICAgICAgICAgY29ubmVjdDogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgICAgaW1hZ2U6IHt9LFxuICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IFtdLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgICAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgICAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJlbG9hZHM6IHtcbiAgICAgICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgbm9uY2U6IHZvaWQgMCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IG51bGwsXG4gICAgICAgIHN0eWxlc1RvSG9pc3Q6ICExXG4gICAgICB9O1xuICAgICAgaWYgKHZvaWQgMCAhPT0gYm9vdHN0cmFwU2NyaXB0cylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gMDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50IDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCsrXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRzW2Jvb3RzdHJhcFNjcmlwdENvbnRlbnRdLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gPSB2b2lkIDAsXG4gICAgICAgICAgICBpbnRlZ3JpdHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgYXM6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICAgIG5vbmNlOiB2b2lkIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNjcmlwdENvbmZpZ1xuICAgICAgICAgICAgPyAocHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZylcbiAgICAgICAgICAgIDogKChwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnLnNyYyksXG4gICAgICAgICAgICAgIChwcm9wcy5pbnRlZ3JpdHkgPSBpbnRlZ3JpdHkgPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzY3JpcHRDb25maWcuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IHNjcmlwdENvbmZpZy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwKSxcbiAgICAgICAgICAgICAgKHByb3BzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzY3JpcHRDb25maWcgfHxcbiAgICAgICAgICAgICAgICBudWxsID09IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIDogXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKTtcbiAgICAgICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUocmVzdW1hYmxlU3RhdGUsIGlkUHJlZml4LCBzcmMsIHByb3BzKTtcbiAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaCgnPHNjcmlwdCBzcmM9XCInLCBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzcmMpKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW50ZWdyaXR5ICYmXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgJ1wiIGludGVncml0eT1cIicsXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGludGVncml0eSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgJ1wiIGNyb3Nzb3JpZ2luPVwiJyxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoY3Jvc3NPcmlnaW4pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKCdcIiBhc3luYz1cIlwiPlxceDNjL3NjcmlwdD4nKTtcbiAgICAgICAgfVxuICAgICAgaWYgKHZvaWQgMCAhPT0gYm9vdHN0cmFwTW9kdWxlcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRzID0gMDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRzIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cysrXG4gICAgICAgIClcbiAgICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IGJvb3RzdHJhcE1vZHVsZXNbYm9vdHN0cmFwU2NyaXB0c10pLFxuICAgICAgICAgICAgKGNyb3NzT3JpZ2luID0gc3JjID0gdm9pZCAwKSxcbiAgICAgICAgICAgIChpbnRlZ3JpdHkgPSB7XG4gICAgICAgICAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICAgIG5vbmNlOiB2b2lkIDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdENvbnRlbnRcbiAgICAgICAgICAgICAgPyAoaW50ZWdyaXR5LmhyZWYgPSBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRDb250ZW50KVxuICAgICAgICAgICAgICA6ICgoaW50ZWdyaXR5LmhyZWYgPSBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRDb250ZW50LnNyYyksXG4gICAgICAgICAgICAgICAgKGludGVncml0eS5pbnRlZ3JpdHkgPSBjcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgPyBib290c3RyYXBTY3JpcHRDb250ZW50LmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgICAgKGludGVncml0eS5jcm9zc09yaWdpbiA9IHNyYyA9XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYm9vdHN0cmFwU2NyaXB0Q29udGVudCB8fFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PSBib290c3RyYXBTY3JpcHRDb250ZW50LmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIDogXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIikpLFxuICAgICAgICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgaWRQcmVmaXgsXG4gICAgICAgICAgICAgIHNjcmlwdENvbmZpZyxcbiAgICAgICAgICAgICAgaW50ZWdyaXR5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICc8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCInLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzY3JpcHRDb25maWcpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICdcIiBpbnRlZ3JpdHk9XCInLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGNyb3NzT3JpZ2luKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNyYyAmJlxuICAgICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgICAnXCIgY3Jvc3NvcmlnaW49XCInLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHNyYylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKCdcIiBhc3luYz1cIlwiPlxceDNjL3NjcmlwdD4nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWNlaG9sZGVyUHJlZml4OiBpZFByZWZpeC5wbGFjZWhvbGRlclByZWZpeCxcbiAgICAgICAgc2VnbWVudFByZWZpeDogaWRQcmVmaXguc2VnbWVudFByZWZpeCxcbiAgICAgICAgYm91bmRhcnlQcmVmaXg6IGlkUHJlZml4LmJvdW5kYXJ5UHJlZml4LFxuICAgICAgICBzdGFydElubGluZVNjcmlwdDogaWRQcmVmaXguc3RhcnRJbmxpbmVTY3JpcHQsXG4gICAgICAgIHByZWFtYmxlOiBpZFByZWZpeC5wcmVhbWJsZSxcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBpZFByZWZpeC5leHRlcm5hbFJ1bnRpbWVTY3JpcHQsXG4gICAgICAgIGJvb3RzdHJhcENodW5rczogaWRQcmVmaXguYm9vdHN0cmFwQ2h1bmtzLFxuICAgICAgICBpbXBvcnRNYXBDaHVua3M6IGlkUHJlZml4LmltcG9ydE1hcENodW5rcyxcbiAgICAgICAgb25IZWFkZXJzOiBpZFByZWZpeC5vbkhlYWRlcnMsXG4gICAgICAgIGhlYWRlcnM6IGlkUHJlZml4LmhlYWRlcnMsXG4gICAgICAgIHJlc2V0czogaWRQcmVmaXgucmVzZXRzLFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBpZFByZWZpeC5jaGFyc2V0Q2h1bmtzLFxuICAgICAgICB2aWV3cG9ydENodW5rczogaWRQcmVmaXgudmlld3BvcnRDaHVua3MsXG4gICAgICAgIGhvaXN0YWJsZUNodW5rczogaWRQcmVmaXguaG9pc3RhYmxlQ2h1bmtzLFxuICAgICAgICBwcmVjb25uZWN0czogaWRQcmVmaXgucHJlY29ubmVjdHMsXG4gICAgICAgIGZvbnRQcmVsb2FkczogaWRQcmVmaXguZm9udFByZWxvYWRzLFxuICAgICAgICBoaWdoSW1hZ2VQcmVsb2FkczogaWRQcmVmaXguaGlnaEltYWdlUHJlbG9hZHMsXG4gICAgICAgIHN0eWxlczogaWRQcmVmaXguc3R5bGVzLFxuICAgICAgICBib290c3RyYXBTY3JpcHRzOiBpZFByZWZpeC5ib290c3RyYXBTY3JpcHRzLFxuICAgICAgICBzY3JpcHRzOiBpZFByZWZpeC5zY3JpcHRzLFxuICAgICAgICBidWxrUHJlbG9hZHM6IGlkUHJlZml4LmJ1bGtQcmVsb2FkcyxcbiAgICAgICAgcHJlbG9hZHM6IGlkUHJlZml4LnByZWxvYWRzLFxuICAgICAgICBzdHlsZXNUb0hvaXN0OiBpZFByZWZpeC5zdHlsZXNUb0hvaXN0LFxuICAgICAgICBnZW5lcmF0ZVN0YXRpY01hcmt1cDogZ2VuZXJhdGVTdGF0aWNNYXJrdXBcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gICAgICBpZiAocmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApXG4gICAgICAgIHJldHVybiB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSksICExO1xuICAgICAgXCJcIiA9PT0gdGV4dFxuICAgICAgICA/ICh0YXJnZXQgPSB0ZXh0RW1iZWRkZWQpXG4gICAgICAgIDogKHRleHRFbWJlZGRlZCAmJiB0YXJnZXQucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkpLFxuICAgICAgICAgICh0YXJnZXQgPSAhMCkpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICB0YXJnZXQsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGxhc3RQdXNoZWRUZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkXG4gICAgKSB7XG4gICAgICByZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCB8fFxuICAgICAgICAobGFzdFB1c2hlZFRleHQgJiYgdGV4dEVtYmVkZGVkICYmIHRhcmdldC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHByZXYpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHByZXYgJiYgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwYXJlbnROZXh0ICYmIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAgICAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICBwcmV2ICE9PSBuZXdTbmFwc2hvdCAmJlxuICAgICAgICAobnVsbCA9PT0gcHJldlxuICAgICAgICAgID8gcHVzaEFsbE5leHQobmV3U25hcHNob3QpXG4gICAgICAgICAgOiBudWxsID09PSBuZXdTbmFwc2hvdFxuICAgICAgICAgICAgPyBwb3BBbGxQcmV2aW91cyhwcmV2KVxuICAgICAgICAgICAgOiBwcmV2LmRlcHRoID09PSBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICA6IHByZXYuZGVwdGggPiBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICAgID8gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpLFxuICAgICAgICAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3U25hcHNob3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocHVibGljSW5zdGFuY2UpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gICAgICBiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0Lm92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOlxuICAgICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICAgIG92ZXJmbG93OiBsZW5ndGggKyBiYXNlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgb3ZlcmZsb3c6IGJhc2VDb250ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMigpIHt9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBpbmRleCA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGUudGhlbihub29wJDIsIG5vb3AkMiksICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKVxuICAgICAgICAgICAgOiAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZSksXG4gICAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICAgICAgaWYgKDAgPCBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIik7XG4gICAgICByZXR1cm4geyBtZW1vaXplZFN0YXRlOiBudWxsLCBxdWV1ZTogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyBudWxsID09PSBmaXJzdFdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rKSlcbiAgICAgICAgOiBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dFxuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlciAmJiAoY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIik7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgICAgIGluaXRpYWxBcmcgPSBpbml0LmRpc3BhdGNoO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVuZGVyUGhhc2VVcGRhdGVzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KGluaXQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUoaW5pdCk7XG4gICAgICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICAgICAgICAgIGluaXQgPSByZWR1Y2VyKGluaXQsIGFjdGlvbik7XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgICAgICAgICBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2luaXQsIGluaXRpYWxBcmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBpbml0aWFsQXJnXTtcbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgcmVkdWNlciA9XG4gICAgICAgIHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsQXJnXG4gICAgICAgICAgICA/IGluaXRpYWxBcmcoKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnXG4gICAgICAgICAgOiB2b2lkIDAgIT09IGluaXRcbiAgICAgICAgICAgID8gaW5pdChpbml0aWFsQXJnKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0geyBsYXN0OiBudWxsLCBkaXNwYXRjaDogbnVsbCB9O1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2spIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YXRlICYmIG51bGwgIT09IGRlcHMpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcHJldlN0YXRlWzFdO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdClcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBzLmxlbmd0aCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgZGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgaSA8IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiYgaSA8IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhkZXBzW2ldLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICBuZXh0Q3JlYXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0Q3JlYXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0Q3JlYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICAgICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICAoY29tcG9uZW50SWRlbnRpdHkgPSB7IGFjdGlvbjogYWN0aW9uLCBuZXh0OiBudWxsIH0pLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlclBoYXNlVXBkYXRlcyAmJiAocmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAoYWN0aW9uID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gYWN0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHF1ZXVlID0gYWN0aW9uOyBudWxsICE9PSBxdWV1ZS5uZXh0OyApIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICBxdWV1ZS5uZXh0ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIiRBQ1RJT05fS0VZXCIsIG5leHRQb3N0YmFja1N0YXRlS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgYWN0aW9uLCAhMV07XG4gICAgICB9XG4gICAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgICExXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IFtdKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0T3duZXJTdGFjayhlcnJvcikge1xuICAgICAgdmFyIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UocHJldlByZXBhcmVTdGFja1RyYWNlICsgMSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmxhc3RJbmRleE9mKFxuICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgICkpO1xuICAgICAgaWYgKC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgICAgIGVycm9yID0gZXJyb3Iuc2xpY2UoMCwgcHJldlByZXBhcmVTdGFja1RyYWNlKTtcbiAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICAgICAgICA/IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgITApXG4gICAgICAgICAgOiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICExKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnR5cGUsICExKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBsYXp5Q29tcG9uZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlLm5hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwYXlsb2FkID0gdHlwZS5lbnYpLFxuICAgICAgICAgICAgZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgICAgIHR5cGUubmFtZSArIChwYXlsb2FkID8gXCIgW1wiICsgcGF5bG9hZCArIFwiXVwiIDogXCJcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICkge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZXJyb3IuZW52aXJvbm1lbnROYW1lO1xuICAgICAgICBlcnJvciA9IFtlcnJvcl0uc2xpY2UoMCk7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvclswXVxuICAgICAgICAgID8gZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBcIlslc10gXCIgKyBlcnJvclswXSxcbiAgICAgICAgICAgICAgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZXJyb3Iuc3BsaWNlKDAsIDAsIFwiWyVzXSBcIiwgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIik7XG4gICAgICAgIGVycm9yLnVuc2hpZnQoY29uc29sZSk7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQuYXBwbHkoY29uc29sZS5lcnJvciwgZXJyb3IpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQoKTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmZsdXNoU2NoZWR1bGVkID0gITE7XG4gICAgICB0aGlzLnJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGU7XG4gICAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICB0aGlzLnJvb3RGb3JtYXRDb250ZXh0ID0gcm9vdEZvcm1hdENvbnRleHQ7XG4gICAgICB0aGlzLnByb2dyZXNzaXZlQ2h1bmtTaXplID1cbiAgICAgICAgdm9pZCAwID09PSBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA/IDEyODAwIDogcHJvZ3Jlc3NpdmVDaHVua1NpemU7XG4gICAgICB0aGlzLnN0YXR1cyA9IDEwO1xuICAgICAgdGhpcy5mYXRhbEVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Jvb3RUYXNrcyA9IHRoaXMuYWxsUGVuZGluZ1Rhc2tzID0gdGhpcy5uZXh0U2VnbWVudElkID0gMDtcbiAgICAgIHRoaXMuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHRoaXMuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydGFibGVUYXNrcyA9IGFib3J0U2V0O1xuICAgICAgdGhpcy5waW5nZWRUYXNrcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMuY29tcGxldGVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5wYXJ0aWFsQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy50cmFja2VkUG9zdHBvbmVzID0gbnVsbDtcbiAgICAgIHRoaXMub25FcnJvciA9IHZvaWQgMCA9PT0gb25FcnJvciA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yO1xuICAgICAgdGhpcy5vblBvc3Rwb25lID0gdm9pZCAwID09PSBvblBvc3Rwb25lID8gbm9vcCA6IG9uUG9zdHBvbmU7XG4gICAgICB0aGlzLm9uQWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uQWxsUmVhZHkgPyBub29wIDogb25BbGxSZWFkeTtcbiAgICAgIHRoaXMub25TaGVsbFJlYWR5ID0gdm9pZCAwID09PSBvblNoZWxsUmVhZHkgPyBub29wIDogb25TaGVsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsRXJyb3IgPSB2b2lkIDAgPT09IG9uU2hlbGxFcnJvciA/IG5vb3AgOiBvblNoZWxsRXJyb3I7XG4gICAgICB0aGlzLm9uRmF0YWxFcnJvciA9IHZvaWQgMCA9PT0gb25GYXRhbEVycm9yID8gbm9vcCA6IG9uRmF0YWxFcnJvcjtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gdm9pZCAwID09PSBmb3JtU3RhdGUgPyBudWxsIDogZm9ybVN0YXRlO1xuICAgICAgdGhpcy5kaWRXYXJuRm9yS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICAgICAgMWUzIDwgbm93IC0gbGFzdFJlc2V0VGltZSAmJlxuICAgICAgICAoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzID0gMCksXG4gICAgICAgIChsYXN0UmVzZXRUaW1lID0gbm93KSk7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IG5ldyBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICByZW5kZXJTdGF0ZSA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgMCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgICExLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAtMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmFib3J0YWJsZVRhc2tzLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZW1wdHlUcmVlQ29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgITEsXG4gICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHB1c2hDb21wb25lbnRTdGFjayhjaGlsZHJlbik7XG4gICAgICByZXN1bWFibGVTdGF0ZS5waW5nZWRUYXNrcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIHJldHVybiByZXN1bWFibGVTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgMSA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiksXG4gICAgICAgIHBlcmZvcm1Xb3JrKHJlcXVlc3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgICAgY29udGVudFByZWFtYmxlLFxuICAgICAgZmFsbGJhY2tQcmVhbWJsZVxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBQRU5ESU5HLFxuICAgICAgICByb290U2VnbWVudElEOiAtMSxcbiAgICAgICAgcGFyZW50Rmx1c2hlZDogITEsXG4gICAgICAgIHBlbmRpbmdUYXNrczogMCxcbiAgICAgICAgY29tcGxldGVkU2VnbWVudHM6IFtdLFxuICAgICAgICBieXRlU2l6ZTogMCxcbiAgICAgICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICAgICAgZXJyb3JEaWdlc3Q6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgZmFsbGJhY2tTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgY29udGVudFByZWFtYmxlOiBjb250ZW50UHJlYW1ibGUsXG4gICAgICAgIGZhbGxiYWNrUHJlYW1ibGU6IGZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgIHRyYWNrZWRDb250ZW50S2V5UGF0aDogbnVsbCxcbiAgICAgICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICAgICBlcnJvclN0YWNrOiBudWxsLFxuICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICBub2RlLFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgIGJsb2NrZWRTZWdtZW50LFxuICAgICAgYmxvY2tlZFByZWFtYmxlLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbGVnYWN5Q29udGV4dCxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcbiAgICAgIG51bGwgPT09IGJsb2NrZWRCb3VuZGFyeVxuICAgICAgICA/IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcysrXG4gICAgICAgIDogYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgdmFyIHRhc2sgPSB7XG4gICAgICAgIHJlcGxheTogbnVsbCxcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgICAgIGJsb2NrZWRTZWdtZW50OiBibG9ja2VkU2VnbWVudCxcbiAgICAgICAgYmxvY2tlZFByZWFtYmxlOiBibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgIGhvaXN0YWJsZVN0YXRlOiBob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICBmb3JtYXRDb250ZXh0OiBmb3JtYXRDb250ZXh0LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB0cmVlQ29udGV4dDogdHJlZUNvbnRleHQsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgaXNGYWxsYmFjazogaXNGYWxsYmFja1xuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbGVnYWN5Q29udGV4dCxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcbiAgICAgIG51bGwgPT09IGJsb2NrZWRCb3VuZGFyeVxuICAgICAgICA/IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcysrXG4gICAgICAgIDogYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgdmFyIHRhc2sgPSB7XG4gICAgICAgIHJlcGxheTogcmVwbGF5LFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgICAgIGJsb2NrZWRQcmVhbWJsZTogbnVsbCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICBpc0ZhbGxiYWNrOiBpc0ZhbGxiYWNrXG4gICAgICB9O1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBkZWJ1Z1Rhc2s7XG4gICAgICBhYm9ydFNldC5hZGQodGFzayk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICBsYXN0UHVzaGVkVGV4dCxcbiAgICAgIHRleHRFbWJlZGRlZFxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBQRU5ESU5HLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgaWQ6IC0xLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgcHJlYW1ibGVDaGlsZHJlbjogW10sXG4gICAgICAgIHBhcmVudEZvcm1hdENvbnRleHQ6IHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgbGFzdFB1c2hlZFRleHQ6IGxhc3RQdXNoZWRUZXh0LFxuICAgICAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFN0YWNrSW5ERVYoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudFRhc2tJbkRFViB8fCBudWxsID09PSBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2s7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY29tcG9uZW50U3RhY2sudHlwZSlcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKGNvbXBvbmVudFN0YWNrLnR5cGUpO1xuICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnRTdGFjay50eXBlKSB7XG4gICAgICAgICAgaWYgKCFjb21wb25lbnRTdGFjay5vd25lcikge1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm8sXG4gICAgICAgICAgICAgIGZuID0gY29tcG9uZW50U3RhY2sudHlwZSxcbiAgICAgICAgICAgICAgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCI7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gbmFtZVxuICAgICAgICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIGluZm8gPSBKU0NvbXBpbGVyX3RlbXBfY29uc3QgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBjb21wb25lbnRTdGFjay5vd25lciB8fFxuICAgICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZShjb21wb25lbnRTdGFjay50eXBlKSk7XG4gICAgICAgIGZvciAoOyBjb21wb25lbnRTdGFjazsgKVxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT0gY29tcG9uZW50U3RhY2suZGVidWdTdGFja1xuICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBmb3JtYXRPd25lclN0YWNrKFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50U3RhY2suZGVidWdTdGFja1xuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogKChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAgICAgbnVsbCAhPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2sgJiZcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXBfY29uc3QgPVxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrID0gZm9ybWF0T3duZXJTdGFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrKSksXG4gICAgICAgICAgICAoY29tcG9uZW50U3RhY2sgPSBjb21wb25lbnRTdGFjay5vd25lcikgJiZcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0ICYmXG4gICAgICAgICAgICAgIChpbmZvICs9IFwiXFxuXCIgKyBKU0NvbXBpbGVyX3RlbXBfY29uc3QpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gaW5mbztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgZGVidWdJbmZvKSB7XG4gICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudEluZm8gPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudEluZm8ubmFtZSAmJlxuICAgICAgICAgICAgdm9pZCAwICE9PSBjb21wb25lbnRJbmZvLmRlYnVnU3RhY2sgJiZcbiAgICAgICAgICAgICgodGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiBjb21wb25lbnRJbmZvLFxuICAgICAgICAgICAgICBvd25lcjogY29tcG9uZW50SW5mby5vd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IGNvbXBvbmVudEluZm8uZGVidWdTdGFja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAodGFzay5kZWJ1Z1Rhc2sgPSBjb21wb25lbnRJbmZvLmRlYnVnVGFzaykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICBvd25lciA9IG5vZGUuX293bmVyLFxuICAgICAgICAgICAgICBzdGFjayA9IG5vZGUuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gbm9kZS5fZGVidWdUYXNrO1xuICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBzdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuICYmXG4gICAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRocm93bkluZm8obm9kZSRqc2NvbXAkMCkge1xuICAgICAgdmFyIGVycm9ySW5mbyA9IHt9O1xuICAgICAgbm9kZSRqc2NvbXAkMCAmJlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGluZm8gPSBcIlwiLFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlJGpzY29tcCQwO1xuICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgIChpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUobm9kZS50eXBlKSksXG4gICAgICAgICAgICAgICAgICAobm9kZSA9IG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgd2hpbGUgKG5vZGUpO1xuICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBpbmZvO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBzdGFjayA9IFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckluZm8sIFwiY29tcG9uZW50U3RhY2tcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogc3RhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gZXJyb3JJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgYm91bmRhcnksXG4gICAgICBkaWdlc3QsXG4gICAgICBlcnJvcixcbiAgICAgIHRocm93bkluZm8sXG4gICAgICB3YXNBYm9ydGVkXG4gICAgKSB7XG4gICAgICBib3VuZGFyeS5lcnJvckRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgPyAoKGRpZ2VzdCA9IFN0cmluZyhlcnJvci5tZXNzYWdlKSksIChlcnJvciA9IFN0cmluZyhlcnJvci5zdGFjaykpKVxuICAgICAgICA6ICgoZGlnZXN0ID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJiBudWxsICE9PSBlcnJvclxuICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGVycm9yKVxuICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvcikpLFxuICAgICAgICAgIChlcnJvciA9IG51bGwpKTtcbiAgICAgIHdhc0Fib3J0ZWQgPSB3YXNBYm9ydGVkXG4gICAgICAgID8gXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgYWJvcnRlZCBkdWUgdG86XFxuXFxuXCJcbiAgICAgICAgOiBcIlN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmluZyBlcnJvcmVkOlxcblxcblwiO1xuICAgICAgYm91bmRhcnkuZXJyb3JNZXNzYWdlID0gd2FzQWJvcnRlZCArIGRpZ2VzdDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yU3RhY2sgPSBudWxsICE9PSBlcnJvciA/IHdhc0Fib3J0ZWQgKyBlcnJvciA6IG51bGw7XG4gICAgICBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrID0gdGhyb3duSW5mby5jb21wb25lbnRTdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0Lm9uRXJyb3I7XG4gICAgICBlcnJvciA9IGRlYnVnVGFza1xuICAgICAgICA/IGRlYnVnVGFzay5ydW4ocmVxdWVzdC5iaW5kKG51bGwsIGVycm9yLCBlcnJvckluZm8pKVxuICAgICAgICA6IHJlcXVlc3QoZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgICBpZiAobnVsbCAhPSBlcnJvciAmJiBcInN0cmluZ1wiICE9PSB0eXBlb2YgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ29uRXJyb3IgcmV0dXJuZWQgc29tZXRoaW5nIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gXCJzdHJpbmdcIi4gb25FcnJvciBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGFuZCBtYXkgcmV0dXJuIG51bGwgb3IgdW5kZWZpbmVkIGJ1dCBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgZWxzZS4gSXQgcmVjZWl2ZWQgc29tZXRoaW5nIG9mIHR5cGUgXCIlc1wiIGluc3RlYWQnLFxuICAgICAgICAgIHR5cGVvZiBlcnJvclxuICAgICAgICApO1xuICAgICAgZWxzZSByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgZGVidWdUYXNrKSB7XG4gICAgICBlcnJvckluZm8gPSByZXF1ZXN0Lm9uU2hlbGxFcnJvcjtcbiAgICAgIHZhciBvbkZhdGFsRXJyb3IgPSByZXF1ZXN0Lm9uRmF0YWxFcnJvcjtcbiAgICAgIGRlYnVnVGFza1xuICAgICAgICA/IChkZWJ1Z1Rhc2sucnVuKGVycm9ySW5mby5iaW5kKG51bGwsIGVycm9yKSksXG4gICAgICAgICAgZGVidWdUYXNrLnJ1bihvbkZhdGFsRXJyb3IuYmluZChudWxsLCBlcnJvcikpKVxuICAgICAgICA6IChlcnJvckluZm8oZXJyb3IpLCBvbkZhdGFsRXJyb3IoZXJyb3IpKTtcbiAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb25cbiAgICAgICAgPyAoKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSwgcmVxdWVzdC5kZXN0aW5hdGlvbi5kZXN0cm95KGVycm9yKSlcbiAgICAgICAgOiAoKHJlcXVlc3Quc3RhdHVzID0gMTMpLCAocmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VGhlbmFibGVTdGF0ZSA9IHRhc2sudGhlbmFibGVTdGF0ZTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSB7fTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG4gICAgICBmb3IgKFxuICAgICAgICByZXF1ZXN0ID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIClcbiAgICAgICAgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSksXG4gICAgICAgICAgKGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMCksXG4gICAgICAgICAgKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xKSxcbiAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAobnVtYmVyT2ZSZVJlbmRlcnMgKz0gMSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBoYXNJZCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICApIHtcbiAgICAgIHZhciBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITE7XG4gICAgICBpZiAoMCAhPT0gYWN0aW9uU3RhdGVDb3VudCAmJiBudWxsICE9PSByZXF1ZXN0LmZvcm1TdGF0ZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICEwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvblN0YXRlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGkgPT09IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICA/IHNlZ21lbnQucHVzaChcIlxceDNjIS0tRiEtLVxceDNlXCIpXG4gICAgICAgICAgICAgIDogc2VnbWVudC5wdXNoKFwiXFx4M2MhLS1GLS1cXHgzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IHRhc2sua2V5UGF0aDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBoYXNJZFxuICAgICAgICA/ICgoa2V5UGF0aCA9IHRhc2sudHJlZUNvbnRleHQpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KGtleVBhdGgsIDEsIDApKSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBrZXlQYXRoKSlcbiAgICAgICAgOiBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzXG4gICAgICAgICAgPyByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSlcbiAgICAgICAgICA6IHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgdGFzay5rZXlQYXRoID0gYWN0aW9uU3RhdGVDb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID09PSBwcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAodm9pZCAwID09PSBjb250ZXh0VHlwZSB8fFxuICAgICAgICAgICAgICBjb250ZXh0VHlwZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBjb250ZXh0VHlwZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgICA6IGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIn0uXCI7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAoY29udGV4dCA9IGNvbnRleHRUeXBlLl9jdXJyZW50VmFsdWUyKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZShyZXNvbHZlZFByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGluc3RhbmNlLnN0YXRlIHx8IHZvaWQgMCA9PT0gaW5zdGFuY2Uuc3RhdGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcImAlc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuIFRoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IGluc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsLFxuICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxNb3VudE5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZSB8fFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPVxuICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgICAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuXCIsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgICAgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHR5cGUuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuaGFzKHR5cGUpICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUucHJvdG90eXBlICYmXG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJBIHB1cmUgY29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIElmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCB1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciBydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzO1xuICAgICAgICAgIHZvaWQgMCAhPT0gaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICAgIGhhc011dGF0ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyB1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXModHlwZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICBzdGF0ZSAmJlxuICAgICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdGF0ZSB8fCBpc0FycmF5SW1wbChzdGF0ZSkpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIG5hbWUpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHZvaWQgMCAhPT0gaW5zdGFuY2Uuc3RhdGUgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gICAgICAgICAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7IHF1ZXVlOiBbXSwgcmVwbGFjZTogITEgfTtcbiAgICAgICAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMgPSBpbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICAgIHZhciBjb250ZXh0VHlwZSRqc2NvbXAkMCA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlJGpzY29tcCQwXG4gICAgICAgICAgICAgID8gY29udGV4dFR5cGUkanNjb21wJDAuX2N1cnJlbnRWYWx1ZTJcbiAgICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSByZXNvbHZlZFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUkanNjb21wJDEpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgOiBhc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQyID1cbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdIHx8XG4gICAgICAgICAgICAgICAgICAoY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpIG9yIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdID1cbiAgICAgICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgb2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlICYmXG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGludGVybmFsSW5zdGFuY2UucXVldWUgJiZcbiAgICAgICAgICAgICAgMCA8IGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIG9sZFF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSxcbiAgICAgICAgICAgICAgICBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gITE7XG4gICAgICAgICAgICAgIGlmIChvbGRSZXBsYWNlICYmIDEgPT09IG9sZFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gITAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICBpIDwgb2xkUXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFydGlhbC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnRpYWw7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAoZG9udE11dGF0ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKChkb250TXV0YXRlID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gY2FsbFJlbmRlckluREVWKGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiYSBjb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMyA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZSRqc2NvbXAkM10gPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgdmFyIGhhc0lkID0gMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50ID0gYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4JGpzY29tcCQwID0gYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4O1xuICAgICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW19jb21wb25lbnROYW1lJGpzY29tcCQwXSB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSAmJlxuICAgICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4gICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uXCIsXG4gICAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lMlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID1cbiAgICAgICAgICAgICAgICAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5jb250ZXh0VHlwZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGhhc0lkLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIHByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgcHJldktleVBhdGgkanNjb21wJDAgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jaGlsZHJlbiA9IHB1c2hTdGFydEluc3RhbmNlKFxuICAgICAgICAgICAgc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsXG4gICAgICAgICAgICB0YXNrLmlzRmFsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICB2YXIgX3ByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgX3ByZXZLZXlQYXRoMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIF9wcmV2Q29udGV4dCxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICkpLmluc2VydGlvbk1vZGUgPT09IEhUTUxfSEVBRF9NT0RFXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGVTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VnbWVudC5wcmVhbWJsZUNoaWxkcmVuLnB1c2gocHJlYW1ibGVTZWdtZW50KTtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZVRhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBfY2hpbGRyZW4sXG4gICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgcHJlYW1ibGVTZWdtZW50LFxuICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHByZWFtYmxlVGFzayk7XG4gICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gocHJlYW1ibGVUYXNrKTtcbiAgICAgICAgICB9IGVsc2UgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBfcHJldkNvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoMjtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFyZWFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwYXJhbVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgICAgICAgICAgICBjYXNlIFwid2JyXCI6XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Lmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0h0bWwgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMSA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICAgIGlmIChcImhpZGRlblwiICE9PSBwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICBhOiBpZiAobnVsbCAhPT0gdGFzay5yZXBsYXkpIHtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQzID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50UHJlYW1ibGUgPSB0YXNrLmJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRIb2lzdGFibGVTdGF0ZSA9IHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjayxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0JvdW5kYXJ5ID1cbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgICAgICAgIChuZXdCb3VuZGFyeS50cmFja2VkQ29udGVudEtleVBhdGggPSBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5jaHVua3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTtcbiAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgICAgICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tLZXlQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMl1cbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGUgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsxXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoWzJdLFxuICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcC5zZXQoXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGgsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnRyYWNrZWRGYWxsYmFja05vZGUgPSBmYWxsYmFja1JlcGxheU5vZGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGJvdW5kYXJ5U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gZmFsbGJhY2tLZXlQYXRoO1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGZhbGxiYWNrLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hTZWdtZW50RmluYWxlKFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQubGFzdFB1c2hlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAoYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gMTIgPT09IHJlcXVlc3Quc3RhdHVzID8gMyA6IDQpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IHBhcmVudFByZWFtYmxlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZFByaW1hcnlUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50UHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgICAgICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRQcmltYXJ5VGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IG5ld0JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlID0gbmV3Qm91bmRhcnkuY29udGVudFByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KG5ld0JvdW5kYXJ5LCBjb250ZW50Um9vdFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSBuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQyKSB7XG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXF1ZXN0LmZhdGFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA0KSwgKGVycm9yID0gdGhyb3duVmFsdWUkMik7XG4gICAgICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBuZXdCb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFByZWFtYmxlID0gcGFyZW50UHJlYW1ibGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZEZhbGxiYWNrVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgICAhMCxcbiAgICAgICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2soc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBwcm9wcztcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQwID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUucmVuZGVyLFxuICAgICAgICAgICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLnR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gcHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQ0ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdHlwZS5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFZhbHVlMiA9IHZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlcHRoOiBudWxsID09PSBwcmV2Tm9kZSA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB0eXBlLFxuICAgICAgICAgICAgICAgICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMSwgLTEpO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90JGpzY29tcCQwID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNuYXBzaG90JGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dC5fY3VycmVudFZhbHVlMiA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudFZhbHVlO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50KTtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICB2YXIgY29udGV4dCRqc2NvbXAkMCA9IHR5cGUuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlbmRlciAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKGNvbnRleHQkanNjb21wJDAuX2N1cnJlbnRWYWx1ZTIpLFxuICAgICAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQ1ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gY2FsbExhenlJbml0SW5ERVYodHlwZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgQ29tcG9uZW50LCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBpbmZvICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAoKG51bGwgPT0gdHlwZSA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5LFxuICAgICAgICBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgcmVzdW1lZFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtZWRTZWdtZW50LmlkID0gc2VnbWVudElkO1xuICAgICAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gbnVsbCksXG4gICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAocmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgICAgID8gKHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudClcbiAgICAgICAgICAgIDogKHF1ZXVlQ29tcGxldGVkU2VnbWVudChibG9ja2VkQm91bmRhcnksIHJlc3VtZWRTZWdtZW50KSxcbiAgICAgICAgICAgICAgYmxvY2tlZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYmxvY2tlZEJvdW5kYXJ5KSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAodGFzay5yZXBsYXkgPSBwcmV2UmVwbGF5KSwgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5RWxlbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIG5hbWUsXG4gICAgICBrZXlPckluZGV4LFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcGxheVxuICAgICkge1xuICAgICAgY2hpbGRJbmRleCA9IHJlcGxheS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkSW5kZXhbaV07XG4gICAgICAgIGlmIChrZXlPckluZGV4ID09PSBub2RlWzFdKSB7XG4gICAgICAgICAgaWYgKDQgPT09IG5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gbmFtZSAmJiBuYW1lICE9PSBub2RlWzBdKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxcIiArXG4gICAgICAgICAgICAgICAgICBub2RlWzBdICtcbiAgICAgICAgICAgICAgICAgIFwiPiBpbiB0aGlzIHNsb3QgYnV0IGluc3RlYWQgaXQgcmVuZGVyZWQgPFwiICtcbiAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgXCI+LiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlWzJdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbM107XG4gICAgICAgICAgICBuYW1lID0gdGFzay5ub2RlO1xuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7IG5vZGVzOiBjaGlsZE5vZGVzLCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyAodGFzay5ub2RlID09PSBuYW1lICYmICh0YXNrLnJlcGxheSA9IHJlcGxheSksIHgpO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgdHlwZSA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgIHByb3BzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgICAgICAgICBrZXlQYXRoID0geDtcbiAgICAgICAgICAgICAgcmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocHJvcHMsIGtleVBhdGgsIHR5cGUsIHRhc2suZGVidWdUYXNrKTtcbiAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPFN1c3BlbnNlPiBpbiB0aGlzIHNsb3QgYnV0IGluc3RlYWQgaXQgcmVuZGVyZWQgPFwiICtcbiAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgcmVwbGF5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB0eXBlID0gbm9kZVs1XTtcbiAgICAgICAgICAgICAgcmVmID0gbm9kZVsyXTtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGVbM107XG4gICAgICAgICAgICAgIGtleU9ySW5kZXggPSBudWxsID09PSBub2RlWzRdID8gW10gOiBub2RlWzRdWzJdO1xuICAgICAgICAgICAgICBub2RlID0gbnVsbCA9PT0gbm9kZVs0XSA/IG51bGwgOiBub2RlWzRdWzNdO1xuICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXBsYXlTZXQgPSB0YXNrLnJlcGxheSxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjayxcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBwcm9wcyA9XG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREVcbiAgICAgICAgICAgICAgICAgID8gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZWFtYmxlU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcm9wcy5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgIHByb3BzLnJvb3RTZWdtZW50SUQgPSB0eXBlO1xuICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHByb3BzO1xuICAgICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlID0gcHJvcHMuY29udGVudFN0YXRlO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IHJlZiwgc2xvdHM6IG5hbWUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByb3BzLnBlbmRpbmdUYXNrcyAmJiBwcm9wcy5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzLnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIChwcm9wcy5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgKGNoaWxkTm9kZXMgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spKSxcbiAgICAgICAgICAgICAgICAgIChyZXBsYXkgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShwcm9wcywgcmVwbGF5LCBlcnJvciwgY2hpbGROb2RlcywgITEpLFxuICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeSksXG4gICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLnJlcGxheSA9IHByZXZpb3VzUmVwbGF5U2V0KSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcHMgPSBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB7IG5vZGVzOiBrZXlPckluZGV4LCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAwIH0sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgcHJvcHMuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2socHJvcHMpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZEluZGV4LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkgJiYgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRhc2sucmVwbGF5LnNsb3RzXG4gICAgICAgID8gcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCB0YXNrLnJlcGxheS5zbG90cywgbm9kZSwgY2hpbGRJbmRleClcbiAgICAgICAgOiAoKHRhc2subm9kZSA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4KSxcbiAgICAgICAgICAobm9kZSA9IHRhc2suY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgIChjaGlsZEluZGV4ID0gdGFzay5kZWJ1Z1Rhc2spLFxuICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSxcbiAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgdGFzayksXG4gICAgICAgICAgKHRhc2suY29tcG9uZW50U3RhY2sgPSBub2RlKSxcbiAgICAgICAgICAodGFzay5kZWJ1Z1Rhc2sgPSBjaGlsZEluZGV4KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZSxcbiAgICAgICAgY2hpbGRJbmRleCA9IHRhc2suY2hpbGRJbmRleDtcbiAgICAgIGlmIChudWxsICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSkge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHJlZlByb3AgPSBub2RlLnJlZjtcbiAgICAgICAgICAgICAgcmVmUHJvcCA9IHZvaWQgMCAhPT0gcmVmUHJvcCA/IHJlZlByb3AgOiBudWxsO1xuICAgICAgICAgICAgICB2YXIgZGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2ssXG4gICAgICAgICAgICAgICAgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICAgICAga2V5ID0gbnVsbCA9PSBrZXkgPyAoLTEgPT09IGNoaWxkSW5kZXggPyAwIDogY2hpbGRJbmRleCkgOiBrZXk7XG4gICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgbmFtZSwga2V5XTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICA/IGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGxheUVsZW1lbnQuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IHJlcGxheUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVmUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJFbGVtZW50LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgbm9kZSwgcmVmUHJvcCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBub2RlID0gY2FsbExhenlJbml0SW5ERVYobm9kZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IG5vZGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKGtleSA9IG51bGwpXG4gICAgICAgICAgICA6ICgodHlwZSA9XG4gICAgICAgICAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBub2RlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuICAgICAgICAgICAgICAoa2V5ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSA/IHR5cGUgOiBudWxsKSk7XG4gICAgICAgICAgaWYgKGtleSAmJiAodHlwZSA9IGtleS5jYWxsKG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC0xICE9PSBjaGlsZEluZGV4IHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gdGFzay5jb21wb25lbnRTdGFjayB8fFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHRhc2suY29tcG9uZW50U3RhY2sudHlwZSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvcl1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGUpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBub2RlLmVudHJpZXMgIT09IGtleSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSk7XG4gICAgICAgICAgICBub2RlID0gdHlwZS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUuZG9uZSkge1xuICAgICAgICAgICAgICBrZXkgPSBbXTtcbiAgICAgICAgICAgICAgZG8ga2V5LnB1c2gobm9kZS52YWx1ZSksIChub2RlID0gdHlwZS5uZXh0KCkpO1xuICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUuZG9uZSk7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywga2V5LCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShub2RlKSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIG5vZGUuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobm9kZSkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QpICtcbiAgICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgPyAoKHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgKHRhc2subGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHRhc2suY2h1bmtzLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICB0YXNrLmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5vZGUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKCh0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgICAodGFzay5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICB0YXNrLmNodW5rcyxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBub2RlLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2subGFzdFB1c2hlZFRleHRcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAoKHJlcXVlc3QgPSBub2RlLmRpc3BsYXlOYW1lIHx8IG5vZGUubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCIsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgJXNcIixcbiAgICAgICAgICAgICAgICAgIFN0cmluZyhub2RlKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2s7XG4gICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgdGFzay5ub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgaWYgKFxuICAgICAgICAtMSAhPT0gY2hpbGRJbmRleCAmJlxuICAgICAgICAoKHRhc2sua2V5UGF0aCA9IFt0YXNrLmtleVBhdGgsIFwiRnJhZ21lbnRcIiwgY2hpbGRJbmRleF0pLFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSlcbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheSwgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXMsIGogPSAwO1xuICAgICAgICAgIGogPCByZXBsYXlOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaisrXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbal07XG4gICAgICAgICAgaWYgKG5vZGVbMV0gPT09IGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggPSBub2RlWzJdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbM107XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IGNoaWxkSW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDEgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0geCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVwbGF5ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICAgIHJlcGxheU5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJlxuICAgICAgICAoKGogPSB0YXNrLnJlcGxheS5zbG90cyksIG51bGwgIT09IGogJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGopXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHJlcGxheU5vZGVzOyBjaGlsZEluZGV4KyspXG4gICAgICAgICAgKG5vZGUgPSBjaGlsZHJlbltjaGlsZEluZGV4XSksXG4gICAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChcbiAgICAgICAgICAgICAgcmVwbGF5LFxuICAgICAgICAgICAgICByZXBsYXlOb2RlcyxcbiAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoZXJyb3IgPSBqW2NoaWxkSW5kZXhdKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBlcnJvclxuICAgICAgICAgICAgICA/IChyZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIGVycm9yLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAgICAgICBkZWxldGUgaltjaGlsZEluZGV4XSlcbiAgICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCByZXBsYXlOb2RlczsgaisrKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBjaGlsZHJlbltqXTtcbiAgICAgICAgcmVzdW1lU2xvdHMgPSByZXF1ZXN0O1xuICAgICAgICBub2RlID0gdGFzaztcbiAgICAgICAgZXJyb3IgPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAoZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX1BPUlRBTF9UWVBFKSAmJlxuICAgICAgICAgIGVycm9yLl9zdG9yZSAmJlxuICAgICAgICAgICgoIWVycm9yLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBlcnJvci5rZXkpIHx8XG4gICAgICAgICAgICAyID09PSBlcnJvci5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGVycm9yLl9zdG9yZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlcnJvci5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgICB0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleTtcbiAgICAgICAgICBudWxsID09IHRocm93bkluZm8gJiZcbiAgICAgICAgICAgICh0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAgIHJlc3VtZVNsb3RzID0gbm9kZS5jb21wb25lbnRTdGFjaztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVzdW1lU2xvdHMgJiYgIXRocm93bkluZm8uaGFzKHJlc3VtZVNsb3RzKSkge1xuICAgICAgICAgICAgdGhyb3duSW5mby5hZGQocmVzdW1lU2xvdHMpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZXJyb3IudHlwZSk7XG4gICAgICAgICAgICB0aHJvd25JbmZvID0gZXJyb3IuX293bmVyO1xuICAgICAgICAgICAgdmFyIHBhcmVudE93bmVyID0gcmVzdW1lU2xvdHMub3duZXI7XG4gICAgICAgICAgICByZXN1bWVTbG90cyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocGFyZW50T3duZXIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHBhcmVudE93bmVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50T3duZXIudHlwZSk7XG4gICAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgICAgICAocmVzdW1lU2xvdHMgPVxuICAgICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VtZVNsb3RzIHx8XG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgICAgKHJlc3VtZVNsb3RzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgIHBhcmVudE93bmVyICE9PSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgICgocGFyZW50T3duZXIgPSBudWxsKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRocm93bkluZm8udHlwZVxuICAgICAgICAgICAgICAgID8gKHBhcmVudE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRocm93bkluZm8udHlwZSkpXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhyb3duSW5mby5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAocGFyZW50T3duZXIgPSB0aHJvd25JbmZvLm5hbWUpLFxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAmJlxuICAgICAgICAgICAgICAgIChjb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgcGFyZW50T3duZXIgKyBcIi5cIikpO1xuICAgICAgICAgICAgdGhyb3duSW5mbyA9IG5vZGUuY29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IG5vZGUuY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBlcnJvci5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5fZGVidWdTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0gdGhyb3duSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChyZXBsYXksIHJlcGxheU5vZGVzLCBqKTtcbiAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZEluZGV4LCBqKTtcbiAgICAgIH1cbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoKSxcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5ID0gcmVxdWVzdC53b3JraW5nTWFwLmdldChib3VuZGFyeSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkubGVuZ3RoID0gNCksIChib3VuZGFyeVsyXSA9IFtdKSwgKGJvdW5kYXJ5WzNdID0gbnVsbCkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5yZXBsYXksXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRhc2suaXNGYWxsYmFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrLFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsID09PSBzZWdtZW50KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlc2V0SG9va3NTdGF0ZSgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlKSxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKSB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIGNodW5rTGVuZ3RoID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSQzID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUkMyksXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICkucGluZztcbiAgICAgICAgICAgICAgbm9kZS50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiA9PT0gbm9kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIG5vZGUgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgbm9kZSk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgdGhyb3cgbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrU29mdCh0YXNrKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgIHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgbnVsbCAhPT0gdGFzayAmJiAoKHRhc2suc3RhdHVzID0gMyksIGZpbmlzaGVkVGFzayh0aGlzLCBib3VuZGFyeSwgdGFzaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgbm9kZXMsXG4gICAgICBzbG90cyxcbiAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICBhYm9ydGVkXG4gICAgKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aClcbiAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgbm9kZVsyXSxcbiAgICAgICAgICAgIG5vZGVbM10sXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgYWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMDtcbiAgICAgICAgICBub2RlID0gbm9kZVs1XTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8gPSBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICB3YXNBYm9ydGVkID0gYWJvcnRlZCxcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5yb290U2VnbWVudElEID0gbm9kZTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICByZXN1bWVkQm91bmRhcnksXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JJbmZvLFxuICAgICAgICAgICAgd2FzQWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIGlmIChudWxsICE9PSBzbG90cykge1xuICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIldlIHNob3VsZCBub3QgaGF2ZSBhbnkgcmVzdW1hYmxlIG5vZGVzIGluIHRoZSBzaGVsbC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgKChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKSxcbiAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygc2xvdHMpXG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIGRlbGV0ZSBzbG90c1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgIT09IHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKDYgPT09IHNlZ21lbnQuc3RhdHVzKSByZXR1cm47XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gMztcbiAgICAgIH1cbiAgICAgIHNlZ21lbnQgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmICgxMyAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgcmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCkge1xuICAgICAgICAgIGJvdW5kYXJ5ID0gdGFzay5yZXBsYXk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgIDAgPCBib3VuZGFyeS5ub2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICAgICgodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5Lm5vZGVzLFxuICAgICAgICAgICAgICBib3VuZGFyeS5zbG90cyxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICEwXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiYgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgdGFzaywgZXJyb3IsIHNlZ21lbnQsICEwKSxcbiAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSksXG4gICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgb25IZWFkZXJzID0gcmVuZGVyU3RhdGUub25IZWFkZXJzO1xuICAgICAgICBpZiAob25IZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkZXJzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsaW5rSGVhZGVyID0gaGVhZGVycy5wcmVjb25uZWN0cztcbiAgICAgICAgICAgIGhlYWRlcnMuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzKSk7XG4gICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGlmICghc2hlbGxDb21wbGV0ZSkge1xuICAgICAgICAgICAgICB2YXIgcXVldWVJdGVyID0gcmVuZGVyU3RhdGUuc3R5bGVzLnZhbHVlcygpLFxuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgIGI6IGZvciAoXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFxdWV1ZVN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJiAhc2hlZXRTdGVwLmRvbmU7XG4gICAgICAgICAgICAgICAgICBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBzaGVldFN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gc2hlZXQucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyRqc2NvbXAkMC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMkanNjb21wJDAuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcyRqc2NvbXAkMC5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzJGpzY29tcCQwLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzJGpzY29tcCQwLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMkanNjb21wJDAuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMkanNjb21wJDAucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IHByb3BzJGpzY29tcCQwLm1lZGlhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY3Jvc3NPcmlnaW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQUkVMT0FEX05PX0NSRURTKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rSGVhZGVyID8gb25IZWFkZXJzKHsgTGluazogbGlua0hlYWRlciB9KSA6IG9uSGVhZGVycyh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB7fSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hlbGwocmVxdWVzdCkge1xuICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsICEwKTtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICByZXF1ZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQWxsKHJlcXVlc3QpIHtcbiAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiBudWxsID09PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50IHx8XG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORURcbiAgICAgICk7XG4gICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc2VnbWVudC5jaHVua3MubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIG51bGwgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgJiZcbiAgICAgICAgLTEgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uaWRcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgICAgfSBlbHNlIGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50ICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICgwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3NcbiAgICAgICAgICAgICAgPyAoYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmIChib3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIChib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIGFib3J0VGFza1NvZnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCksXG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgKHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgMSA9PT0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QkanNjb21wJDIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXMgIT09IENMT1NFRCAmJlxuICAgICAgICAxMyAhPT0gcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXNcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgICAgICAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyO1xuICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICAgICAgICB2YXIgcHJldlJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0JGpzY29tcCQyLnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QkanNjb21wJDIucGluZ2VkVGFza3MsXG4gICAgICAgICAgICBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICB0YXNrID0gcGluZ2VkVGFza3NbaV0sXG4gICAgICAgICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUYXNrSW5ERVYgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrO1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChyZXF1ZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVxdWVzdC5yZXBsYXkuc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiByZXRyeU5vZGUocmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIDEgPT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAwIDwgcmVxdWVzdC5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0JGpzY29tcCQwLCByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHggPVxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaW5nID0gcmVxdWVzdC5waW5nO1xuICAgICAgICAgICAgICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdC5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSA9IHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdCRqc2NvbXAkMC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0JGpzY29tcCQwLmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCA9IGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYXlOb2RlcyA9IHJlcXVlc3QucmVwbGF5Lm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzID0gcmVxdWVzdC5yZXBsYXkuc2xvdHM7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICgocmVxdWVzdCRqc2NvbXAkMCA9IHByZXZUYXNrSW5ERVYgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSB0YXNrKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3QkanNjb21wJDEgPSBzZWdtZW50KSxcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KGVycm9yRGlnZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IGVycm9yRGlnZXN0O1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaHVua0xlbmd0aCA9IHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgZXJyb3JEaWdlc3QpLFxuICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICAgICAgICAocmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgeCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgIDogMTIgPT09IHJlcXVlc3Quc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0LmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4JGpzY29tcCQwLnRoZW5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcGluZyRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LnBpbmc7XG4gICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLnRoZW4ocGluZyRqc2NvbXAkMCwgcGluZyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8kanNjb21wJDEgPSBnZXRUaHJvd25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IDQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayA9IGVycm9yRGlnZXN0LmRlYnVnVGFzaztcbiAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgID8gZmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IChib3VuZGFyeSRqc2NvbXAkMC5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QkanNjb21wJDIuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChwaW5nZWRUYXNrcyA9IHt9KSxcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcHJldlJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCksXG4gICAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9PT0gSG9va3NEaXNwYXRjaGVyICYmIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMucHVzaChzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4pO1xuICAgICAgZm9yICh2YXIgcGVuZGluZ1ByZWFtYmxlcyA9ICExLCBpID0gMDsgaSA8IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHBlbmRpbmdQcmVhbWJsZXMgPVxuICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSB8fCBwZW5kaW5nUHJlYW1ibGVzO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcmVhbWJsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcmVhbWJsZSA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZSA9IGJvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICBpZiAobnVsbCA9PT0gcHJlYW1ibGUgfHwgbnVsbCA9PT0gZmFsbGJhY2tQcmVhbWJsZSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoIChib3VuZGFyeS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgaG9pc3RQcmVhbWJsZVN0YXRlKHJlcXVlc3QucmVuZGVyU3RhdGUsIHByZWFtYmxlKTtcbiAgICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgICAgICAgaWYgKCFzZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBDTElFTlRfUkVOREVSRUQ6XG4gICAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBob2lzdFByZWFtYmxlU3RhdGUocmVxdWVzdC5yZW5kZXJTdGF0ZSwgZmFsbGJhY2tQcmVhbWJsZSksXG4gICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkge1xuICAgICAgaWYgKFxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICYmXG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgKSB7XG4gICAgICAgIHZhciBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzID0gW10sXG4gICAgICAgICAgaGFzUGVuZGluZ1ByZWFtYmxlcyA9IHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwcmVhbWJsZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhMSA9PT0gaGFzUGVuZGluZ1ByZWFtYmxlcyB8fFxuICAgICAgICAgIChwcmVhbWJsZS5oZWFkQ2h1bmtzICYmIHByZWFtYmxlLmJvZHlDaHVua3MpXG4gICAgICAgIClcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBQRU5ESU5HOlxuICAgICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChob2lzdGFibGVTdGF0ZSA9IHNlZ21lbnQuaWQpLFxuICAgICAgICAgICAgKHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMSksXG4gICAgICAgICAgICAoc2VnbWVudC50ZXh0RW1iZWRkZWQgPSAhMSksXG4gICAgICAgICAgICAocmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwbGFjZWhvbGRlcjEpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KSxcbiAgICAgICAgICAgIChyZXF1ZXN0ID0gaG9pc3RhYmxlU3RhdGUudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBsYWNlaG9sZGVyMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEZMVVNIRUQ7XG4gICAgICAgICAgdmFyIHIgPSAhMCxcbiAgICAgICAgICAgIGNodW5rcyA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgY2h1bmtJZHggPSAwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkSWR4ID0gMDsgY2hpbGRJZHggPCBzZWdtZW50Lmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgICAgZm9yIChyID0gc2VnbWVudFtjaGlsZElkeF07IGNodW5rSWR4IDwgci5pbmRleDsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICAgIHIgPSBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHIsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAtIDE7IGNodW5rSWR4KyspXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAmJiAociA9IGRlc3RpbmF0aW9uLnB1c2goY2h1bmtzW2NodW5rSWR4XSkpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBYm9ydGVkLCBlcnJvcmVkIG9yIGFscmVhZHkgZmx1c2hlZCBib3VuZGFyaWVzIHNob3VsZCBub3QgYmUgZmx1c2hlZCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QucmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApIHtcbiAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBib3VuZGFyeS5lcnJvckRpZ2VzdCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjayA9IGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuICAgICAgICAgIGVycm9yRGlnZXN0ICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKSxcbiAgICAgICAgICAgIChlcnJvckRpZ2VzdCA9IGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yRGlnZXN0KSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goXG4gICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCKSxcbiAgICAgICAgICAgIChlcnJvck1lc3NhZ2UgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZXJyb3JNZXNzYWdlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goXG4gICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZXJyb3JTdGFjayAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyksXG4gICAgICAgICAgICAoZXJyb3JTdGFjayA9IGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yU3RhY2spKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZXJyb3JTdGFjayksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUQpLFxuICAgICAgICAgICAgKGVycm9yQ29tcG9uZW50U3RhY2sgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckNvbXBvbmVudFN0YWNrKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yQ29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXBcbiAgICAgICAgICA/IChkZXN0aW5hdGlvbiA9ICEwKVxuICAgICAgICAgIDogKChyZXF1ZXN0ID0gYm91bmRhcnkuZmFsbGJhY2tQcmVhbWJsZSkgJiZcbiAgICAgICAgICAgICAgd3JpdGVQcmVhbWJsZUNvbnRyaWJ1dGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdCksXG4gICAgICAgICAgICAoZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpKSk7XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgIT09IENPTVBMRVRFRClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcgJiZcbiAgICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIDAgPCBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICksXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkgPSBib3VuZGFyeS5mYWxsYmFja1N0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlc2hlZXRzLmZvckVhY2goXG4gICAgICAgICAgICAgIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBpZiAoYm91bmRhcnkuYnl0ZVNpemUgPiByZXF1ZXN0LnByb2dyZXNzaXZlQ2h1bmtTaXplKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAoKHNlZ21lbnQgPSBib3VuZGFyeS5jb250ZW50U3RhdGUpLFxuICAgICAgICBzZWdtZW50LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgc2VnbWVudC5zdHlsZXNoZWV0cy5mb3JFYWNoKGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSk7XG4gICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwIHx8XG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgIGlmICgxICE9PSBzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudFswXSwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cFxuICAgICAgICA/IChkZXN0aW5hdGlvbiA9ICEwKVxuICAgICAgICA6ICgocmVxdWVzdCA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSkgJiZcbiAgICAgICAgICAgIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHJlcXVlc3QpLFxuICAgICAgICAgIChkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uLnB1c2goZW5kU3VzcGVuc2VCb3VuZGFyeSkpKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgc2VnbWVudCxcbiAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgKSB7XG4gICAgICB3cml0ZVN0YXJ0U2VnbWVudChcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgc2VnbWVudC5pZFxuICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLCBpID0gMDtcbiAgICAgICAgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW2ldXG4gICAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGkgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlcXVlc3Quc3R5bGVzVG9Ib2lzdDtcbiAgICAgIHJlcXVlc3Quc3R5bGVzVG9Ib2lzdCA9ICExO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09XG4gICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zID1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHxcbiAgICAgICAgICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfFxuICAgICAgICAgICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGgpKVxuICAgICAgICAgIDogKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKSlcbiAgICAgICAgICAgIDogZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKVxuICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKSlcbiAgICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzID0gaS50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZWRTZWdtZW50cyk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgcmVxdWlyZXNTdHlsZUluc2VydGlvblxuICAgICAgICA/IChkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSksXG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnkpKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kKTtcbiAgICAgIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVxdWVzdCkgJiYgYm91bmRhcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgc2VnbWVudFxuICAgICkge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSByZXR1cm4gITA7XG4gICAgICB2YXIgaG9pc3RhYmxlU3RhdGUgPSBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG4gICAgICBpZiAoLTEgPT09IHNlZ21lbnRJRCkge1xuICAgICAgICBpZiAoLTEgPT09IChzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKVxuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICAoYm91bmRhcnkuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnRcbiAgICAgICAgPyAoKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnNlZ21lbnRQcmVmaXgpO1xuICAgICAgc2VnbWVudElEID0gc2VnbWVudElELnRvU3RyaW5nKDE2KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc2VnbWVudElEKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QucGxhY2Vob2xkZXJQcmVmaXgpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChzZWdtZW50SUQpO1xuICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoISgwIDwgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRSb290U2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBwcmVhbWJsZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlLFxuICAgICAgICAgICAgICBodG1sQ2h1bmtzID0gcHJlYW1ibGUuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyA9IHByZWFtYmxlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIGkkanNjb21wJDA7XG4gICAgICAgICAgICBpZiAoaHRtbENodW5rcykge1xuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaHRtbENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGh0bWxDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBpZiAoaGVhZENodW5rcylcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBzdGFydENodW5rRm9yVGFnKFwiaGVhZFwiKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoaSRqc2NvbXAkMCA9IDA7IGkkanNjb21wJDAgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSRqc2NvbXAkMCsrKVxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2YXIgY2hhcnNldENodW5rcyA9IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGNoYXJzZXRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaGFyc2V0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGNoYXJzZXRDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydENodW5rcyA9IHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCB2aWV3cG9ydENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHZpZXdwb3J0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVzSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaW1wb3J0TWFwQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhvaXN0YWJsZUNodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA9IGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA8IGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1tyZW5kZXJTdGF0ZV07XG4gICAgICAgICAgICAgIGZvciAocHJlYW1ibGUgPSAwOyBwcmVhbWJsZSA8IHNlZ21lbnRzLmxlbmd0aDsgcHJlYW1ibGUrKylcbiAgICAgICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnRzW3ByZWFtYmxlXSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlLnByZWFtYmxlLFxuICAgICAgICAgICAgICBoZWFkQ2h1bmtzJGpzY29tcCQwID0gcHJlYW1ibGUkanNjb21wJDAuaGVhZENodW5rcztcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMC5odG1sQ2h1bmtzIHx8IGhlYWRDaHVua3MkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQwID0gZW5kQ2h1bmtGb3JUYWcoXCJoZWFkXCIpO1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rJGpzY29tcCQwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBib2R5Q2h1bmtzID0gcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcztcbiAgICAgICAgICAgIGlmIChib2R5Q2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPCBib2R5Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYm9keUNodW5rc1tjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXSk7XG4gICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMC52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF0pO1xuICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChcbiAgICAgICAgICAgIGZsdXNoUmVzb3VyY2UsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDAuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdKTtcbiAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElELFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2gocmVuZGVyU3RhdGUkanNjb21wJDEuc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgICAgICA/ICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgICAgIDogcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKHJlbmRlclN0YXRlJGpzY29tcCQxLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgICAgICAgIHZhciBjaHVuayRqc2NvbXAkMSA9IGlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDEpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxQSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICBlcnJvclN0YWNrIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQyID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8IFwiXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQzID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fCBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQ0ID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yU3RhY2sgfHwgXCJcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNodW5rJGpzY29tcCQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDUgPVxuICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXNbaV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgYm91bmRhcnkgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5JGpzY29tcCQwID0gcGFydGlhbEJvdW5kYXJpZXNbaV0sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeSRqc2NvbXAkMC5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW0pTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrO1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucmVuZGVyU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbGFyZ2VCb3VuZGFyaWVzW2ldKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICAoaSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgIGkuaGFzQm9keSAmJlxuICAgICAgICAgICAgKChwYXJ0aWFsQm91bmRhcmllcyA9IGVuZENodW5rRm9yVGFnKFwiYm9keVwiKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBhcnRpYWxCb3VuZGFyaWVzKSksXG4gICAgICAgICAgaS5oYXNIdG1sICYmICgoaSA9IGVuZENodW5rRm9yVGFnKFwiaHRtbFwiKSksIGRlc3RpbmF0aW9uLnB1c2goaSkpLFxuICAgICAgICAgIDAgIT09IHJlcXVlc3QuYWJvcnRhYmxlVGFza3Muc2l6ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgICBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgIDEwID09PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSAxMSk7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgITEgPT09IHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgJiZcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgKSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICA/IGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKVxuICAgICAgICAgIDogKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKDEzID09PSByZXF1ZXN0LnN0YXR1cylcbiAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSwgZGVzdGluYXRpb24uZGVzdHJveShyZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCAmJiBudWxsID09PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgKGRlc3RpbmF0aW9uID0ge30pLFxuICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZGVzdGluYXRpb24sIG51bGwpLFxuICAgICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciwgZGVzdGluYXRpb24sIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0KHJlcXVlc3QsIHJlYXNvbikge1xuICAgICAgaWYgKDExID09PSByZXF1ZXN0LnN0YXR1cyB8fCAxMCA9PT0gcmVxdWVzdC5zdGF0dXMpIHJlcXVlc3Quc3RhdHVzID0gMTI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYWJvcnRhYmxlVGFza3MgPSByZXF1ZXN0LmFib3J0YWJsZVRhc2tzO1xuICAgICAgICBpZiAoMCA8IGFib3J0YWJsZVRhc2tzLnNpemUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPVxuICAgICAgICAgICAgdm9pZCAwID09PSByZWFzb25cbiAgICAgICAgICAgICAgPyBFcnJvcihcIlRoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLlwiKVxuICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVhc29uLnRoZW5cbiAgICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGggYSBwcm9taXNlLlwiKVxuICAgICAgICAgICAgICAgIDogcmVhc29uO1xuICAgICAgICAgIHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICAgIGFib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiAmJlxuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IkNCkge1xuICAgICAgICAocmVhc29uID0ge30pLFxuICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwgcmVhc29uLCBudWxsKSxcbiAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yJDQsIHJlYXNvbiwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7fVxuICAgIGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGdlbmVyYXRlU3RhdGljTWFya3VwLFxuICAgICAgYWJvcnRSZWFzb25cbiAgICApIHtcbiAgICAgIHZhciBkaWRGYXRhbCA9ICExLFxuICAgICAgICBmYXRhbEVycm9yID0gbnVsbCxcbiAgICAgICAgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgcmVhZHlUb1N0cmVhbSA9ICExO1xuICAgICAgb3B0aW9ucyA9IGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwXG4gICAgICApO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGUob3B0aW9ucywgZ2VuZXJhdGVTdGF0aWNNYXJrdXApLFxuICAgICAgICBjcmVhdGVGb3JtYXRDb250ZXh0KFJPT1RfSFRNTF9NT0RFLCBudWxsLCAwKSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlYWR5VG9TdHJlYW0gPSAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXJ0V29yayhjaGlsZHJlbik7XG4gICAgICBhYm9ydChjaGlsZHJlbiwgYWJvcnRSZWFzb24pO1xuICAgICAgc3RhcnRGbG93aW5nKGNoaWxkcmVuLCB7XG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIG51bGwgIT09IGNodW5rICYmIChyZXN1bHQgKz0gY2h1bmspO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgZGlkRmF0YWwgPSAhMDtcbiAgICAgICAgICBmYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZEZhdGFsICYmIGZhdGFsRXJyb3IgIT09IGFib3J0UmVhc29uKSB0aHJvdyBmYXRhbEVycm9yO1xuICAgICAgaWYgKCFyZWFkeVRvU3RyZWFtKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkEgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzIHdpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCB1cGRhdGVzIHRoYXQgc3VzcGVuZCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKSxcbiAgICAgIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSxcbiAgICAgIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnZpZXdfdHJhbnNpdGlvblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGpzeFByb3BzUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBqc3hDaGlsZHJlblBhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgQ0xJRU5UX1JFRkVSRU5DRV9UQUcgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IFJlZ0V4cChcbiAgICAgICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFxuICAgICAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IGFzcGVjdFJhdGlvIGJvcmRlckltYWdlT3V0c2V0IGJvcmRlckltYWdlU2xpY2UgYm9yZGVySW1hZ2VXaWR0aCBib3hGbGV4IGJveEZsZXhHcm91cCBib3hPcmRpbmFsR3JvdXAgY29sdW1uQ291bnQgY29sdW1ucyBmbGV4IGZsZXhHcm93IGZsZXhQb3NpdGl2ZSBmbGV4U2hyaW5rIGZsZXhOZWdhdGl2ZSBmbGV4T3JkZXIgZ3JpZEFyZWEgZ3JpZFJvdyBncmlkUm93RW5kIGdyaWRSb3dTcGFuIGdyaWRSb3dTdGFydCBncmlkQ29sdW1uIGdyaWRDb2x1bW5FbmQgZ3JpZENvbHVtblNwYW4gZ3JpZENvbHVtblN0YXJ0IGZvbnRXZWlnaHQgbGluZUNsYW1wIGxpbmVIZWlnaHQgb3BhY2l0eSBvcmRlciBvcnBoYW5zIHNjYWxlIHRhYlNpemUgd2lkb3dzIHpJbmRleCB6b29tIGZpbGxPcGFjaXR5IGZsb29kT3BhY2l0eSBzdG9wT3BhY2l0eSBzdHJva2VEYXNoYXJyYXkgc3Ryb2tlRGFzaG9mZnNldCBzdHJva2VNaXRlcmxpbWl0IHN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgTW96Qm94RmxleCBNb3pCb3hGbGV4R3JvdXAgTW96TGluZUNsYW1wIG1zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgbXNGbGV4IG1zWm9vbSBtc0ZsZXhHcm93IG1zRmxleE5lZ2F0aXZlIG1zRmxleE9yZGVyIG1zRmxleFBvc2l0aXZlIG1zRmxleFNocmluayBtc0dyaWRDb2x1bW4gbXNHcmlkQ29sdW1uU3BhbiBtc0dyaWRSb3cgbXNHcmlkUm93U3BhbiBXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCBXZWJraXRCb3hGbGV4IFdlYktpdEJveEZsZXhHcm91cCBXZWJraXRCb3hPcmRpbmFsR3JvdXAgV2Via2l0Q29sdW1uQ291bnQgV2Via2l0Q29sdW1ucyBXZWJraXRGbGV4IFdlYmtpdEZsZXhHcm93IFdlYmtpdEZsZXhQb3NpdGl2ZSBXZWJraXRGbGV4U2hyaW5rIFdlYmtpdExpbmVDbGFtcFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcbiAgICAgICAgW1wiaHRtbEZvclwiLCBcImZvclwiXSxcbiAgICAgICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICAgICAgW1wiY3Jvc3NPcmlnaW5cIiwgXCJjcm9zc29yaWdpblwiXSxcbiAgICAgICAgW1wiYWNjZW50SGVpZ2h0XCIsIFwiYWNjZW50LWhlaWdodFwiXSxcbiAgICAgICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImFyYWJpY0Zvcm1cIiwgXCJhcmFiaWMtZm9ybVwiXSxcbiAgICAgICAgW1wiYmFzZWxpbmVTaGlmdFwiLCBcImJhc2VsaW5lLXNoaWZ0XCJdLFxuICAgICAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJjbGlwUGF0aFwiLCBcImNsaXAtcGF0aFwiXSxcbiAgICAgICAgW1wiY2xpcFJ1bGVcIiwgXCJjbGlwLXJ1bGVcIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIl0sXG4gICAgICAgIFtcImNvbG9yUHJvZmlsZVwiLCBcImNvbG9yLXByb2ZpbGVcIl0sXG4gICAgICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJkb21pbmFudEJhc2VsaW5lXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImVuYWJsZUJhY2tncm91bmRcIiwgXCJlbmFibGUtYmFja2dyb3VuZFwiXSxcbiAgICAgICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZpbGxSdWxlXCIsIFwiZmlsbC1ydWxlXCJdLFxuICAgICAgICBbXCJmbG9vZENvbG9yXCIsIFwiZmxvb2QtY29sb3JcIl0sXG4gICAgICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZvbnRGYW1pbHlcIiwgXCJmb250LWZhbWlseVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVcIiwgXCJmb250LXNpemVcIl0sXG4gICAgICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICAgICAgW1wiZm9udFN0cmV0Y2hcIiwgXCJmb250LXN0cmV0Y2hcIl0sXG4gICAgICAgIFtcImZvbnRTdHlsZVwiLCBcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgICAgICBbXCJmb250V2VpZ2h0XCIsIFwiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgIFtcImdseXBoTmFtZVwiLCBcImdseXBoLW5hbWVcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIl0sXG4gICAgICAgIFtcImhvcml6QWR2WFwiLCBcImhvcml6LWFkdi14XCJdLFxuICAgICAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICAgICAgW1wiaW1hZ2VSZW5kZXJpbmdcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImxldHRlclNwYWNpbmdcIiwgXCJsZXR0ZXItc3BhY2luZ1wiXSxcbiAgICAgICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgICAgICBbXCJtYXJrZXJFbmRcIiwgXCJtYXJrZXItZW5kXCJdLFxuICAgICAgICBbXCJtYXJrZXJNaWRcIiwgXCJtYXJrZXItbWlkXCJdLFxuICAgICAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVQb3NpdGlvblwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJvdmVybGluZVRoaWNrbmVzc1wiLCBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgICAgICBbXCJwYW5vc2UtMVwiLCBcInBhbm9zZS0xXCJdLFxuICAgICAgICBbXCJwb2ludGVyRXZlbnRzXCIsIFwicG9pbnRlci1ldmVudHNcIl0sXG4gICAgICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgICAgIFtcInNoYXBlUmVuZGVyaW5nXCIsIFwic2hhcGUtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJzdG9wQ29sb3JcIiwgXCJzdG9wLWNvbG9yXCJdLFxuICAgICAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLCBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWNhcFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgICAgIFtcInN0cm9rZU1pdGVybGltaXRcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSxcbiAgICAgICAgW1wic3Ryb2tlT3BhY2l0eVwiLCBcInN0cm9rZS1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgICAgW1widGV4dEFuY2hvclwiLCBcInRleHQtYW5jaG9yXCJdLFxuICAgICAgICBbXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHQtZGVjb3JhdGlvblwiXSxcbiAgICAgICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVQb3NpdGlvblwiLCBcInVuZGVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1widW5pY29kZUJpZGlcIiwgXCJ1bmljb2RlLWJpZGlcIl0sXG4gICAgICAgIFtcInVuaWNvZGVSYW5nZVwiLCBcInVuaWNvZGUtcmFuZ2VcIl0sXG4gICAgICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgICAgIFtcInZBbHBoYWJldGljXCIsIFwidi1hbHBoYWJldGljXCJdLFxuICAgICAgICBbXCJ2SGFuZ2luZ1wiLCBcInYtaGFuZ2luZ1wiXSxcbiAgICAgICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICAgICAgW1widk1hdGhlbWF0aWNhbFwiLCBcInYtbWF0aGVtYXRpY2FsXCJdLFxuICAgICAgICBbXCJ2ZWN0b3JFZmZlY3RcIiwgXCJ2ZWN0b3ItZWZmZWN0XCJdLFxuICAgICAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5YXCIsIFwidmVydC1vcmlnaW4teFwiXSxcbiAgICAgICAgW1widmVydE9yaWdpbllcIiwgXCJ2ZXJ0LW9yaWdpbi15XCJdLFxuICAgICAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICAgICAgW1wid3JpdGluZ01vZGVcIiwgXCJ3cml0aW5nLW1vZGVcIl0sXG4gICAgICAgIFtcInhtbG5zWGxpbmtcIiwgXCJ4bWxuczp4bGlua1wiXSxcbiAgICAgICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gICAgICBdKSxcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgICAgIGJ1dHRvbjogITAsXG4gICAgICAgIGNoZWNrYm94OiAhMCxcbiAgICAgICAgaW1hZ2U6ICEwLFxuICAgICAgICBoaWRkZW46ICEwLFxuICAgICAgICByYWRpbzogITAsXG4gICAgICAgIHJlc2V0OiAhMCxcbiAgICAgICAgc3VibWl0OiAhMFxuICAgICAgfSxcbiAgICAgIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAgICAgICBcImFyaWEtY3VycmVudFwiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWRldGFpbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWludmFsaWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWtleXNob3J0Y3V0c1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jaGVja2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogMCxcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tb2RhbFwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogMCxcbiAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wbGFjZWhvbGRlclwiOiAwLFxuICAgICAgICBcImFyaWEtcHJlc3NlZFwiOiAwLFxuICAgICAgICBcImFyaWEtcmVhZG9ubHlcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc29ydFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdG9taWNcIjogMCxcbiAgICAgICAgXCJhcmlhLWJ1c3lcIjogMCxcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kcm9wZWZmZWN0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1ncmFiYmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xjb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29saW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbHNwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1mbG93dG9cIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLW93bnNcIjogMCxcbiAgICAgICAgXCJhcmlhLXBvc2luc2V0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3djb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd3NwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXNldHNpemVcIjogMFxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9LFxuICAgICAgckFSSUEkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gITEsXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzID0ge30sXG4gICAgICBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vLFxuICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS8sXG4gICAgICByQVJJQSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vLFxuICAgICAgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vLFxuICAgICAgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2csXG4gICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLyxcbiAgICAgIHdhcm5lZFN0eWxlTmFtZXMgPSB7fSxcbiAgICAgIHdhcm5lZFN0eWxlVmFsdWVzID0ge30sXG4gICAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9ICExLFxuICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICExLFxuICAgICAgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLyxcbiAgICAgIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nLFxuICAgICAgbXNQYXR0ZXJuID0gL15tcy0vLFxuICAgICAgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPVxuICAgICAgICAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qOi9pLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgICAgIGY6IHByZXZpb3VzRGlzcGF0Y2hlci5mLFxuICAgICAgcjogcHJldmlvdXNEaXNwYXRjaGVyLnIsXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9XG4gICAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgICAgXCI+OyByZWw9ZG5zLXByZWZldGNoXCIpLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5kbnNbaHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgoaGVhZGVyID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKGhlYWRlciwgeyBocmVmOiBocmVmLCByZWw6IFwiZG5zLXByZWZldGNoXCIgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gICAgICB9LFxuICAgICAgQzogZnVuY3Rpb24gKGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9XG4gICAgICAgICAgICAgIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgPyBcImNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyBcImFub255bW91c1wiXG4gICAgICAgICAgICAgICAgICA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF0uaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgIFwiPjsgcmVsPXByZWNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY3Jvc3NPcmlnaW5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wICs9XG4gICAgICAgICAgICAgICAgICAgICc7IGNyb3Nzb3JpZ2luPVwiJyArIGVzY2FwZWRDcm9zc09yaWdpbiArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuY29ubmVjdFtidWNrZXRdW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKGJ1Y2tldCA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChidWNrZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWNvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChidWNrZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuQyhocmVmLCBjcm9zc09yaWdpbik7XG4gICAgICB9LFxuICAgICAgTDogZnVuY3Rpb24gKGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoYXMgJiYgaHJlZikge1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAgICAgICAgICAgICAgdmFyIGZldGNoUHJpb3JpdHkgPSBvcHRpb25zLmZldGNoUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbWFnZVNyY1NldFxuICAgICAgICAgICAgICAgICAgPyBpbWFnZVNyY1NldCArIFwiXFxuXCIgKyAoaW1hZ2VTaXplcyB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgOiBocmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgaW1hZ2VTcmNTZXQgJiZcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBpbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMuc2V0KGtleSwgcmVzdW1hYmxlU3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChpbWFnZVNyY1NldCA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChpbWFnZVNyY1NldCA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdID0gaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzKSAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgICBcImZvbnRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICAgICgoa2V5ID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBrZXkubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5mb250W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIChocmVmID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgIHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYXMpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICB2YXIgYXMgPVxuICAgICAgICAgICAgICBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCI7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGFzID0gW107XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuc2V0KGhyZWYsIGFzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChyZXNvdXJjZXMgPSB7fSksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzW2FzXSA9IHJlc291cmNlcyk7XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZXNbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcIm1vZHVsZXByZWxvYWRcIiwgaHJlZjogaHJlZiB9LCBvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoYXMpO1xuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5tKGhyZWYsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIFg6IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXVxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbiAoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZilcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAoKHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKSksXG4gICAgICAgICAgICAgIChwcmVjZWRlbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhwcmVjZWRlbmNlLnByb3BzLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoaHJlZikpICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUubGVuZ3RoID0gMClcbiAgICAgICAgICAgICAgICAgIDogKHByZWNlZGVuY2Uuc3RhdGUgPSBQUkVMT0FERUQpKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGhyZWYsIHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID1cbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KHNyYylcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKFxuICAgICAgICAgICAgICAgIHsgc3JjOiBzcmMsIHR5cGU6IFwibW9kdWxlXCIsIGFzeW5jOiAhMCB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5NKHNyYywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgTm90aGluZ1NlbnQgPSAwLFxuICAgICAgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uID0gMSxcbiAgICAgIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24gPSAyLFxuICAgICAgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uID0gNCxcbiAgICAgIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uID0gOCxcbiAgICAgIEVYSVNUUyA9IG51bGwsXG4gICAgICBQUkVMT0FEX05PX0NSRURTID0gW107XG4gICAgT2JqZWN0LmZyZWV6ZShQUkVMT0FEX05PX0NSRURTKTtcbiAgICB2YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuICAgIHZhciBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWUgPSB7fTtcbiAgICB2YXIgTm9Db250cmlidXRpb24gPSAwLFxuICAgICAgUk9PVF9IVE1MX01PREUgPSAwLFxuICAgICAgSFRNTF9IVE1MX01PREUgPSAxLFxuICAgICAgSFRNTF9NT0RFID0gMixcbiAgICAgIEhUTUxfSEVBRF9NT0RFID0gMyxcbiAgICAgIFNWR19NT0RFID0gNCxcbiAgICAgIE1BVEhNTF9NT0RFID0gNSxcbiAgICAgIEhUTUxfVEFCTEVfTU9ERSA9IDYsXG4gICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSA9IDcsXG4gICAgICBIVE1MX1RBQkxFX1JPV19NT0RFID0gOCxcbiAgICAgIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDksXG4gICAgICBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQgPSAnIHN0eWxlPVwiJyxcbiAgICAgIHN0eWxlQXNzaWduID0gXCI6XCIsXG4gICAgICBzdHlsZVNlcGFyYXRvciA9IFwiO1wiLFxuICAgICAgYXR0cmlidXRlU2VwYXJhdG9yID0gXCIgXCIsXG4gICAgICBhdHRyaWJ1dGVBc3NpZ24gPSAnPVwiJyxcbiAgICAgIGF0dHJpYnV0ZUVuZCA9ICdcIicsXG4gICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9ICc9XCJcIicsXG4gICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiXG4gICAgICApLFxuICAgICAgZW5kT2ZTdGFydFRhZyA9IFwiPlwiLFxuICAgICAgZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nID0gXCIvPlwiLFxuICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSAhMSxcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITEsXG4gICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCA9XG4gICAgICAgICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLm93bmVyRG9jdW1lbnR8fGMsKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxkLGIpKX19KTsnLFxuICAgICAgc3R5bGVSZWdleCA9IC8oPFxcL3w8KShzKSh0eWxlKS9naSxcbiAgICAgIGxlYWRpbmdOZXdsaW5lID0gXCJcXG5cIixcbiAgICAgIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvLFxuICAgICAgdmFsaWRhdGVkVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBlbmRUYWdDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHBsYWNlaG9sZGVyMSA9ICc8dGVtcGxhdGUgaWQ9XCInLFxuICAgICAgcGxhY2Vob2xkZXIyID0gJ1wiPjwvdGVtcGxhdGU+JyxcbiAgICAgIHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSA9IFwiXFx4M2MhLS0kLS1cXHgzZVwiLFxuICAgICAgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSAnXFx4M2MhLS0kPy0tXFx4M2U8dGVtcGxhdGUgaWQ9XCInLFxuICAgICAgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIgPSAnXCI+PC90ZW1wbGF0ZT4nLFxuICAgICAgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkgPSBcIlxceDNjIS0tJCEtLVxceDNlXCIsXG4gICAgICBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gXCJcXHgzYyEtLS8kLS1cXHgzZVwiLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID0gXCI8dGVtcGxhdGVcIixcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9ICdcIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID0gJyBkYXRhLWRnc3Q9XCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9ICcgZGF0YS1tc2c9XCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9ICcgZGF0YS1zdGNrPVwiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUQgPSAnIGRhdGEtY3N0Y2s9XCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyID0gXCI+PC90ZW1wbGF0ZT5cIixcbiAgICAgIGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua1N0YXJ0ID0gXCJcXHgzYyEtLVwiLFxuICAgICAgYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rRW5kID0gXCItLVxceDNlXCIsXG4gICAgICBzdGFydFNlZ21lbnRIVE1MID0gJzxkaXYgaGlkZGVuIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudEhUTUwyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50SFRNTCA9IFwiPC9kaXY+XCIsXG4gICAgICBzdGFydFNlZ21lbnRTVkcgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudFNWRzIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRTVkcgPSBcIjwvc3ZnPlwiLFxuICAgICAgc3RhcnRTZWdtZW50TWF0aE1MID0gJzxtYXRoIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50TWF0aE1MMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudE1hdGhNTCA9IFwiPC9tYXRoPlwiLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUgPSAnPHRhYmxlIGhpZGRlbiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZTIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRUYWJsZSA9IFwiPC90YWJsZT5cIixcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9ICc8dGFibGUgaGlkZGVuPjx0Ym9keSBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZUJvZHkyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGVCb2R5ID0gXCI8L3Rib2R5PjwvdGFibGU+XCIsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZVJvdyA9ICc8dGFibGUgaGlkZGVuPjx0ciBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZVJvdzIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRUYWJsZVJvdyA9IFwiPC90cj48L3RhYmxlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50Q29sR3JvdXAgPSAnPHRhYmxlIGhpZGRlbj48Y29sZ3JvdXAgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50Q29sR3JvdXAyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50Q29sR3JvdXAgPSBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIixcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID1cbiAgICAgICAgJyRSUz1mdW5jdGlvbihhLGIpe2E9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7Yj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtmb3IoYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2EuZmlyc3RDaGlsZDspYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLmZpcnN0Q2hpbGQsYik7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfTskUlMoXCInLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSAnJFJTKFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSAnXCIsXCInLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gJ1wiKVxceDNjL3NjcmlwdD4nLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsID1cbiAgICAgICAgJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19OyRSQyhcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwgPSAnJFJDKFwiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoID1cbiAgICAgICAgJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19OyRSTT1uZXcgTWFwO1xcbiRSUj1mdW5jdGlvbih0LHUseSl7ZnVuY3Rpb24gdihuKXt0aGlzLl9wPW51bGw7bigpfWZvcih2YXIgdz0kUkMscD0kUk0scT1uZXcgTWFwLHI9ZG9jdW1lbnQsZyxiLGg9ci5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIikseD1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT94LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZwLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscS5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZT15W2IrK107aWYoIWUpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1lW20rK107aWYoYT1wLmdldChkKSl7dmFyIGY9YS5fcDtjPSEwfWVsc2V7YT1yLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1cXG5kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1sPWVbbSsrXTtmPWVbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZixlW20rK10pO2Y9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbihuLHope2Eub25sb2FkPXYuYmluZChhLG4pO2Eub25lcnJvcj12LmJpbmQoYSx6KX0pO3Auc2V0KGQsYSl9ZD1hLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpOyFmfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZik7aWYoYyljb250aW51ZX1lbHNle2E9eFtiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXEuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtxLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXIuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4ody5iaW5kKG51bGwsXFxudCx1LFwiXCIpLHcuYmluZChudWxsLHQsdSxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JFJSKFwiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID1cbiAgICAgICAgJyRSTT1uZXcgTWFwO1xcbiRSUj1mdW5jdGlvbih0LHUseSl7ZnVuY3Rpb24gdihuKXt0aGlzLl9wPW51bGw7bigpfWZvcih2YXIgdz0kUkMscD0kUk0scT1uZXcgTWFwLHI9ZG9jdW1lbnQsZyxiLGg9ci5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIikseD1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT94LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZwLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscS5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZT15W2IrK107aWYoIWUpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1lW20rK107aWYoYT1wLmdldChkKSl7dmFyIGY9YS5fcDtjPSEwfWVsc2V7YT1yLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1cXG5kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1sPWVbbSsrXTtmPWVbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZixlW20rK10pO2Y9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbihuLHope2Eub25sb2FkPXYuYmluZChhLG4pO2Eub25lcnJvcj12LmJpbmQoYSx6KX0pO3Auc2V0KGQsYSl9ZD1hLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpOyFmfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZik7aWYoYyljb250aW51ZX1lbHNle2E9eFtiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXEuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtxLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXIuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4ody5iaW5kKG51bGwsXFxudCx1LFwiXCIpLHcuYmluZChudWxsLHQsdSxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JFJSKFwiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwgPSAnJFJSKFwiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gJ1wiLFwiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9ICdcIiwnLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiID0gJ1wiJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBcIilcXHgzYy9zY3JpcHQ+XCIsXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUlg9ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTthJiYoYj1hLnByZXZpb3VzU2libGluZyxiLmRhdGE9XCIkIVwiLGE9YS5kYXRhc2V0LGMmJihhLmRnc3Q9YyksZCYmKGEubXNnPWQpLGUmJihhLnN0Y2s9ZSksZiYmKGEuY3N0Y2s9ZiksYi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpKX07OyRSWChcIicsXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCA9ICckUlgoXCInLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUEgPSAnXCInLFxuICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwgPSBcIixcIixcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdEVuZCA9IFwiKVxceDNjL3NjcmlwdD5cIixcbiAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSAnPHN0eWxlIG1lZGlhPVwibm90IGFsbFwiIGRhdGEtcHJlY2VkZW5jZT1cIicsXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gJ1wiIGRhdGEtaHJlZj1cIicsXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zID0gJ1wiPicsXG4gICAgICBsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlID0gXCI8L3N0eWxlPlwiLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITEsXG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITAsXG4gICAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSA9IFtdLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gJzxzdHlsZSBkYXRhLXByZWNlZGVuY2U9XCInLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gJ1wiIGRhdGEtaHJlZj1cIicsXG4gICAgICBzcGFjZVNlcGFyYXRvciA9IFwiIFwiLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4zID0gJ1wiPicsXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UgPSBcIjwvc3R5bGU+XCIsXG4gICAgICBhcnJheUZpcnN0T3BlbkJyYWNrZXQgPSBcIltcIixcbiAgICAgIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gXCIsW1wiLFxuICAgICAgYXJyYXlJbnRlcnN0aXRpYWwgPSBcIixcIixcbiAgICAgIGFycmF5Q2xvc2VCcmFja2V0ID0gXCJdXCIsXG4gICAgICBQRU5ESU5HJDEgPSAwLFxuICAgICAgUFJFTE9BREVEID0gMSxcbiAgICAgIFBSRUFNQkxFID0gMixcbiAgICAgIExBVEUgPSAzLFxuICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2csXG4gICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCA9IC9bXCInOyxcXHJcXG5dL2csXG4gICAgICBkb2N0eXBlQ2h1bmsgPSBcIlwiLFxuICAgICAgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuICAgIHZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGludGVybmFscyA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIG51bGwgPT09IGludGVybmFscy5xdWV1ZVxuICAgICAgICAgICAgPyB3YXJuTm9vcChpbnN0LCBcInNldFN0YXRlXCIpXG4gICAgICAgICAgICA6IChpbnRlcm5hbHMucXVldWUucHVzaChwYXlsb2FkKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICBpbnN0LnJlcGxhY2UgPSAhMDtcbiAgICAgICAgICBpbnN0LnF1ZXVlID0gW3BheWxvYWRdO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIG51bGwgPT09IGluc3QuX3JlYWN0SW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwiZm9yY2VVcGRhdGVcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW1wdHlUcmVlQ29udGV4dCA9IHsgaWQ6IDEsIG92ZXJmbG93OiBcIlwiIH0sXG4gICAgICBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWAuXCJcbiAgICAgICksXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0gbnVsbCxcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBpc1JlUmVuZGVyID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIgPSAwLFxuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTEsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGwsXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyA9IDAsXG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgSG9va3NEaXNwYXRjaGVyID0ge1xuICAgICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKVxuICAgICAgICAgICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vOiB1c2VNZW1vLFxuICAgICAgICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICAgICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZpb3VzUmVmXG4gICAgICAgICAgICA/ICgoaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksXG4gICAgICAgICAgICAgIE9iamVjdC5zZWFsKGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSkpXG4gICAgICAgICAgICA6IHByZXZpb3VzUmVmO1xuICAgICAgICB9LFxuICAgICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICAgIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AkMSxcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgfSwgZGVwcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AkMSxcbiAgICAgICAgdXNlRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZURlYnVnVmFsdWU6IG5vb3AkMSxcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaW5pdGlhbFZhbHVlID8gaW5pdGlhbFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFshMSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmVlSWQgPSBjdXJyZW50bHlSZW5kZXJpbmdUYXNrLnRyZWVDb250ZXh0O1xuICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHRyZWVJZC5vdmVyZmxvdztcbiAgICAgICAgICB0cmVlSWQgPSB0cmVlSWQuaWQ7XG4gICAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAgICh0cmVlSWQgJiB+KDEgPDwgKDMyIC0gY2x6MzIodHJlZUlkKSAtIDEpKSkudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG92ZXJmbG93ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgICB0cmVlSWQgPSBcIlxcdTAwYWJcIiArIHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgXCJSXCIgKyB0cmVlSWQ7XG4gICAgICAgICAgMCA8IG92ZXJmbG93ICYmICh0cmVlSWQgKz0gXCJIXCIgKyBvdmVyZmxvdy50b1N0cmluZygzMikpO1xuICAgICAgICAgIHJldHVybiB0cmVlSWQgKyBcIlxcdTAwYmJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUFjdGlvblN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlRm9ybVN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIE5vdFBlbmRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICBmb3IgKHZhciBkYXRhID0gQXJyYXkoc2l6ZSksIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgY3VycmVudFRhc2tJbkRFViA9IG51bGwsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVZcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBjYWxsQ29tcG9uZW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxSZW5kZXIgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxSZW5kZXJJbkRFViA9IGNhbGxSZW5kZXJbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsUmVuZGVyKSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICBsYXN0UmVzZXRUaW1lID0gMDtcbiAgICBpZiAoXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vd1xuICAgICkge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIHZhciBnZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgICAgIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIENMSUVOVF9SRU5ERVJFRCA9IDQsXG4gICAgICBQRU5ESU5HID0gMCxcbiAgICAgIENPTVBMRVRFRCA9IDEsXG4gICAgICBGTFVTSEVEID0gMixcbiAgICAgIFBPU1RQT05FRCA9IDUsXG4gICAgICBDTE9TRUQgPSAxNCxcbiAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9ICExO1xuICAgIGV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZW5kZXJUb1N0cmluZ0ltcGwoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAhMCxcbiAgICAgICAgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RhdGljTWFya3VwXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICExLFxuICAgICAgICAnVGhlIHNlcnZlciB1c2VkIFwicmVuZGVyVG9TdHJpbmdcIiB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFN1c3BlbnNlLiBJZiB5b3UgaW50ZW5kZWQgZm9yIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBjb250ZW50IG9uIHRoZSBzZXJ2ZXIgY29uc2lkZXIgdGhyb3dpbmcgYW4gRXJyb3Igc29tZXdoZXJlIHdpdGhpbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkuIElmIHlvdSBpbnRlbmRlZCB0byBoYXZlIHRoZSBzZXJ2ZXIgd2FpdCBmb3IgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcGxlYXNlIHN3aXRjaCB0byBcInJlbmRlclRvUmVhZGFibGVTdHJlYW1cIiB3aGljaCBzdXBwb3J0cyBTdXNwZW5zZSBvbiB0aGUgc2VydmVyJ1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMS4wXCI7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server.browser.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server.browser.development.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function scheduleWork(callback) {\n      taskQueue.push(callback);\n      channel.port2.postMessage(null);\n    }\n    function handleErrorInNextTick(error) {\n      setTimeout(function () {\n        throw error;\n      });\n    }\n    function writeChunk(destination, chunk) {\n      if (0 !== chunk.byteLength)\n        if (2048 < chunk.byteLength)\n          0 < writtenBytes &&\n            (destination.enqueue(\n              new Uint8Array(currentView.buffer, 0, writtenBytes)\n            ),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0)),\n            destination.enqueue(chunk);\n        else {\n          var allowableBytes = currentView.length - writtenBytes;\n          allowableBytes < chunk.byteLength &&\n            (0 === allowableBytes\n              ? destination.enqueue(currentView)\n              : (currentView.set(\n                  chunk.subarray(0, allowableBytes),\n                  writtenBytes\n                ),\n                destination.enqueue(currentView),\n                (chunk = chunk.subarray(allowableBytes))),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0));\n          currentView.set(chunk, writtenBytes);\n          writtenBytes += chunk.byteLength;\n        }\n    }\n    function writeChunkAndReturn(destination, chunk) {\n      writeChunk(destination, chunk);\n      return !0;\n    }\n    function completeWriting(destination) {\n      currentView &&\n        0 < writtenBytes &&\n        (destination.enqueue(\n          new Uint8Array(currentView.buffer, 0, writtenBytes)\n        ),\n        (currentView = null),\n        (writtenBytes = 0));\n    }\n    function stringToChunk(content) {\n      return textEncoder.encode(content);\n    }\n    function stringToPrecomputedChunk(content) {\n      content = textEncoder.encode(content);\n      2048 < content.byteLength &&\n        console.error(\n          \"precomputed chunks must be smaller than the view size configured for this host. This is a bug in React.\"\n        );\n      return content;\n    }\n    function closeWithError(destination, error) {\n      \"function\" === typeof destination.error\n        ? destination.error(error)\n        : destination.close();\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createRenderState(\n      resumableState,\n      nonce,\n      externalRuntimeConfig,\n      importMap,\n      onHeaders,\n      maxHeadersLength\n    ) {\n      var inlineScriptWithNonce =\n          void 0 === nonce\n            ? startInlineScript\n            : stringToPrecomputedChunk(\n                '<script nonce=\"' + escapeTextForBrowser(nonce) + '\">'\n              ),\n        idPrefix = resumableState.idPrefix;\n      externalRuntimeConfig = [];\n      var bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        externalRuntimeConfig.push(\n          inlineScriptWithNonce,\n          stringToChunk(\n            escapeEntireInlineScriptContent(bootstrapScriptContent)\n          ),\n          endInlineScript\n        );\n      bootstrapScriptContent = [];\n      void 0 !== importMap &&\n        (bootstrapScriptContent.push(importMapScriptStart),\n        bootstrapScriptContent.push(\n          stringToChunk(\n            escapeEntireInlineScriptContent(JSON.stringify(importMap))\n          )\n        ),\n        bootstrapScriptContent.push(importMapScriptEnd));\n      onHeaders &&\n        \"number\" === typeof maxHeadersLength &&\n        0 >= maxHeadersLength &&\n        console.error(\n          \"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\",\n          0 === maxHeadersLength ? \"zero\" : maxHeadersLength\n        );\n      importMap = onHeaders\n        ? {\n            preconnects: \"\",\n            fontPreloads: \"\",\n            highImagePreloads: \"\",\n            remainingCapacity:\n              2 +\n              (\"number\" === typeof maxHeadersLength ? maxHeadersLength : 2e3)\n          }\n        : null;\n      onHeaders = {\n        placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n        segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n        boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n        startInlineScript: inlineScriptWithNonce,\n        preamble: createPreambleState(),\n        externalRuntimeScript: null,\n        bootstrapChunks: externalRuntimeConfig,\n        importMapChunks: bootstrapScriptContent,\n        onHeaders: onHeaders,\n        headers: importMap,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: nonce,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {\n          maxHeadersLength = bootstrapScripts[importMap];\n          bootstrapScriptContent = idPrefix = void 0;\n          var props = {\n            rel: \"preload\",\n            as: \"script\",\n            fetchPriority: \"low\",\n            nonce: nonce\n          };\n          \"string\" === typeof maxHeadersLength\n            ? (props.href = inlineScriptWithNonce = maxHeadersLength)\n            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),\n              (props.integrity = bootstrapScriptContent =\n                \"string\" === typeof maxHeadersLength.integrity\n                  ? maxHeadersLength.integrity\n                  : void 0),\n              (props.crossOrigin = idPrefix =\n                \"string\" === typeof maxHeadersLength ||\n                null == maxHeadersLength.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === maxHeadersLength.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(\n            resumableState,\n            onHeaders,\n            inlineScriptWithNonce,\n            props\n          );\n          externalRuntimeConfig.push(\n            startScriptSrc,\n            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n          );\n          nonce &&\n            externalRuntimeConfig.push(\n              scriptNonce,\n              stringToChunk(escapeTextForBrowser(nonce))\n            );\n          \"string\" === typeof bootstrapScriptContent &&\n            externalRuntimeConfig.push(\n              scriptIntegirty,\n              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))\n            );\n          \"string\" === typeof idPrefix &&\n            externalRuntimeConfig.push(\n              scriptCrossOrigin,\n              stringToChunk(escapeTextForBrowser(idPrefix))\n            );\n          externalRuntimeConfig.push(endAsyncScript);\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (importMap = bootstrapModules[bootstrapScripts]),\n            (idPrefix = inlineScriptWithNonce = void 0),\n            (bootstrapScriptContent = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: nonce\n            }),\n            \"string\" === typeof importMap\n              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)\n              : ((bootstrapScriptContent.href = maxHeadersLength =\n                  importMap.src),\n                (bootstrapScriptContent.integrity = idPrefix =\n                  \"string\" === typeof importMap.integrity\n                    ? importMap.integrity\n                    : void 0),\n                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =\n                  \"string\" === typeof importMap || null == importMap.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === importMap.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              onHeaders,\n              maxHeadersLength,\n              bootstrapScriptContent\n            ),\n            externalRuntimeConfig.push(\n              startModuleSrc,\n              stringToChunk(escapeTextForBrowser(maxHeadersLength))\n            ),\n            nonce &&\n              externalRuntimeConfig.push(\n                scriptNonce,\n                stringToChunk(escapeTextForBrowser(nonce))\n              ),\n            \"string\" === typeof idPrefix &&\n              externalRuntimeConfig.push(\n                scriptIntegirty,\n                stringToChunk(escapeTextForBrowser(idPrefix))\n              ),\n            \"string\" === typeof inlineScriptWithNonce &&\n              externalRuntimeConfig.push(\n                scriptCrossOrigin,\n                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n              ),\n            externalRuntimeConfig.push(endAsyncScript);\n      return onHeaders;\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createPreambleState() {\n      return {\n        htmlChunks: null,\n        headChunks: null,\n        bodyChunks: null,\n        contribution: NoContribution\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function createRootFormatContext(namespaceURI) {\n      return createFormatContext(\n        \"http://www.w3.org/2000/svg\" === namespaceURI\n          ? SVG_MODE\n          : \"http://www.w3.org/1998/Math/MathML\" === namespaceURI\n            ? MATHML_MODE\n            : ROOT_HTML_MODE,\n        null,\n        0\n      );\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              parentContext.tagScope\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              parentContext.tagScope\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext;\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (\"\" === text) return textEmbedded;\n      textEmbedded && target.push(textSeparator);\n      target.push(stringToChunk(escapeTextForBrowser(text)));\n      return !0;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = stringToChunk(\n                escapeTextForBrowser((\"\" + styleValue).trim())\n              );\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = stringToPrecomputedChunk(\n                    escapeTextForBrowser(\n                      nameChunk\n                        .replace(uppercasePattern, \"-$1\")\n                        .toLowerCase()\n                        .replace(msPattern, \"-ms-\")\n                    )\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? stringToChunk(\"\" + styleValue)\n                      : stringToChunk(styleValue + \"px\"))\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = stringToChunk(\n                    escapeTextForBrowser((\"\" + styleValue).trim())\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeEmptyString\n        );\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value)),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push(startHiddenInputChunk);\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              stringToChunk(\"formAction\"),\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(name),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(\"xlink:href\"),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeEmptyString\n            );\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeEmptyString\n              )\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML),\n          target.push(stringToChunk(\"\" + innerHTML)));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          endInlineScript\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(stringToChunk(escapeTextForBrowser(\"\" + props)));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(stringToChunk(escapeEntireInlineScriptContent(children)));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(selectedMarkerAttribute);\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(selectedMarkerAttribute);\n          } else selected && target$jscomp$0.push(selectedMarkerAttribute);\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(\"\" + value$jscomp$0))\n            ));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$3))\n            );\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  stringToChunk(\"action\"),\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push(startHiddenInputChunk),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$4))\n            );\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      stringToChunk(\"data\"),\n                      attributeAssign,\n                      stringToChunk(escapeTextForBrowser(sanitizedValue)),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$5))\n            );\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(textSeparator);\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(textSeparator),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(\n                stringToChunk(escapeStyleTextContent(child$jscomp$1))\n              );\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    stringToChunk(escapeTextForBrowser(href$jscomp$0))\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: stringToChunk(\n                      escapeTextForBrowser(precedence$jscomp$0)\n                    ),\n                    rules: [],\n                    hrefs: [stringToChunk(escapeTextForBrowser(href$jscomp$0))],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(\n                  stringToChunk(escapeStyleTextContent(child$jscomp$2))\n                );\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(textSeparator),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, stringToChunk(html))\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(stringToChunk(\"\" + html))));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          stringToChunk(attributeName),\n                          attributeAssign,\n                          stringToChunk(\n                            escapeTextForBrowser(propValue$jscomp$11)\n                          ),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = stringToPrecomputedChunk(\"</\" + tag + \">\")),\n        endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        ((renderState.htmlChunks = preambleState.htmlChunks),\n        (preambleState.contribution |= 1));\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        ((renderState.headChunks = preambleState.headChunks),\n        (preambleState.contribution |= 4));\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        ((renderState.bodyChunks = preambleState.bodyChunks),\n        (preambleState.contribution |= 2));\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        writeChunk(destination, renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]),\n          (renderState.length = 0),\n          writeChunkAndReturn(destination, i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      writeChunk(destination, startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      writeChunk(destination, renderState.boundaryPrefix);\n      writeChunk(destination, stringToChunk(id.toString(16)));\n      return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n    }\n    function writePreambleContribution(destination, preambleState) {\n      preambleState = preambleState.contribution;\n      preambleState !== NoContribution &&\n        (writeChunk(destination, boundaryPreambleContributionChunkStart),\n        writeChunk(destination, stringToChunk(\"\" + preambleState)),\n        writeChunk(destination, boundaryPreambleContributionChunkEnd));\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            writeChunk(destination, startSegmentHTML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            writeChunk(destination, startSegmentSVG),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            writeChunk(destination, startSegmentMathML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            writeChunk(destination, startSegmentTable),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            writeChunk(destination, startSegmentTableBody),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            writeChunk(destination, startSegmentTableRow),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            writeChunk(destination, startSegmentColGroup),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return writeChunkAndReturn(destination, endSegmentHTML);\n        case SVG_MODE:\n          return writeChunkAndReturn(destination, endSegmentSVG);\n        case MATHML_MODE:\n          return writeChunkAndReturn(destination, endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return writeChunkAndReturn(destination, endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return writeChunkAndReturn(destination, endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        writeChunk(this, lateStyleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        for (\n          writeChunk(this, lateStyleTagResourceOpen2);\n          i < hrefs.length - 1;\n          i++\n        )\n          writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);\n        writeChunk(this, hrefs[i]);\n        writeChunk(this, lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);\n        destinationHasCapacity = writeChunkAndReturn(\n          this,\n          lateStyleTagTemplateClose\n        );\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        writeChunk(this, stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        writeChunk(this, styleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            writeChunk(this, styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            writeChunk(this, hrefs[styleQueue]),\n              writeChunk(this, spaceSeparator);\n          writeChunk(this, hrefs[styleQueue]);\n        }\n        writeChunk(this, styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          writeChunk(this, rules[styleQueue]);\n        writeChunk(this, styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          writeChunk(this, stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      writeChunk(destination, arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            writeChunk(destination, nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              writeChunk(\n                destination,\n                stringToChunk(\n                  escapeJSObjectForInstructionScripts(\"\" + resource)\n                )\n              ),\n              writeChunk(destination, arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            writeChunk(destination, nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))\n            );\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(precedence))\n            );\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            writeChunk(destination, arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      writeChunk(destination, arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(attributeName))\n      );\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(name))\n      );\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react-stack-bottom-frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"%c%s%c \" + error[0],\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            )\n          : error.splice(\n              0,\n              0,\n              \"%c%s%c \",\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            );\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var now = getCurrentTime();\n      1e3 < now - lastResetTime &&\n        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n        (lastResetTime = now));\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function createPrerenderRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      children = createRequest(\n        children,\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        void 0\n      );\n      children.trackedPostpones = {\n        workingMap: new Map(),\n        rootNodes: [],\n        rootSlots: null\n      };\n      return children;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        null !== request.trackedPostpones || 10 === request.status\n          ? scheduleMicrotask(function () {\n              return performWork(request);\n            })\n          : scheduleWork(function () {\n              return performWork(request);\n            }));\n    }\n    function createSuspenseBoundary(\n      request,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED),\n          closeWithError(request.destination, error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(formStateMarkerIsMatching)\n              : segment.push(formStateMarkerIsNotMatching);\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            var preambleTask = createRenderTask(\n              request,\n              null,\n              _children,\n              -1,\n              task.blockedBoundary,\n              preambleSegment,\n              task.blockedPreamble,\n              task.hoistableState,\n              request.abortableTasks,\n              task.keyPath,\n              task.formatContext,\n              task.context,\n              task.treeContext,\n              task.componentStack,\n              task.isFallback,\n              emptyContextObject,\n              task.debugTask\n            );\n            pushComponentStack(preambleTask);\n            request.pingedTasks.push(preambleTask);\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_ACTIVITY_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    boundarySegment.lastPushedText &&\n                      boundarySegment.textEmbedded &&\n                      boundarySegment.chunks.push(textSeparator),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    contentRootSegment.lastPushedText &&\n                      contentRootSegment.textEmbedded &&\n                      contentRootSegment.chunks.push(textSeparator),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    0 === request.pendingRootTasks &&\n                      task.blockedPreamble &&\n                      preparePreamble(request);\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue;\n              type._currentValue = value$jscomp$0;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            node = node[3];\n            name = task.node;\n            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (task.node === name && (task.replay = replay), x);\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = node;\n              node = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                node,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              type = node[5];\n              ref = node[2];\n              name = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              props.parentFlushed = !0;\n              props.rootSegmentID = type;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                !0,\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (key = null)\n            : ((type =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (key = \"function\" === typeof type ? type : null));\n          if (key && (type = key.call(node))) {\n            if (type === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !== Object.prototype.toString.call(type)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== key ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = type.next();\n            if (!node.done) {\n              key = [];\n              do key.push(node.value), (node = type.next());\n              while (!node.done);\n              renderChildrenArray(request, task, key, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        resumeSlots = request;\n        node = task;\n        error = childIndex;\n        if (\n          null !== error &&\n          \"object\" === typeof error &&\n          (error.$$typeof === REACT_ELEMENT_TYPE ||\n            error.$$typeof === REACT_PORTAL_TYPE) &&\n          error._store &&\n          ((!error._store.validated && null == error.key) ||\n            2 === error._store.validated)\n        ) {\n          if (\"object\" !== typeof error._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          error._store.validated = 1;\n          thrownInfo = resumeSlots.didWarnForKey;\n          null == thrownInfo &&\n            (thrownInfo = resumeSlots.didWarnForKey = new WeakSet());\n          resumeSlots = node.componentStack;\n          if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {\n            thrownInfo.add(resumeSlots);\n            var componentName = getComponentNameFromType(error.type);\n            thrownInfo = error._owner;\n            var parentOwner = resumeSlots.owner;\n            resumeSlots = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (resumeSlots =\n                  \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            resumeSlots ||\n              (componentName &&\n                (resumeSlots =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != thrownInfo &&\n              parentOwner !== thrownInfo &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof thrownInfo.type\n                ? (parentOwner = getComponentNameFromType(thrownInfo.type))\n                : \"string\" === typeof thrownInfo.name &&\n                  (parentOwner = thrownInfo.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            thrownInfo = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: error.type,\n              owner: error._owner,\n              stack: error._debugStack\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              resumeSlots,\n              componentName\n            );\n            node.componentStack = thrownInfo;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment, null);\n            fatalError(request, error, segment, null);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment, null)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear(),\n                  0 === request.pendingRootTasks &&\n                    null === request.trackedPostpones &&\n                    null !== boundary.contentPreamble &&\n                    preparePreamble(request)))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  request$jscomp$1.lastPushedText &&\n                    request$jscomp$1.textEmbedded &&\n                    request$jscomp$1.chunks.push(textSeparator),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState = getThenableStateAfterSuspending();\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = 4;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    debugTask = errorDigest.debugTask;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  null === boundary$jscomp$0\n                    ? fatalError(\n                        request,\n                        x$jscomp$0,\n                        errorInfo$jscomp$1,\n                        debugTask\n                      )\n                    : (boundary$jscomp$0.pendingTasks--,\n                      boundary$jscomp$0.status !== CLIENT_RENDERED &&\n                        ((boundary$jscomp$0.status = CLIENT_RENDERED),\n                        encodeErrorForBoundary(\n                          boundary$jscomp$0,\n                          prevTaskInDEV,\n                          x$jscomp$0,\n                          errorInfo$jscomp$1,\n                          !1\n                        ),\n                        untrackBoundary(request, boundary$jscomp$0),\n                        boundary$jscomp$0.parentFlushed &&\n                          request.clientRenderedBoundaries.push(\n                            boundary$jscomp$0\n                          ),\n                        0 === request.pendingRootTasks &&\n                          null === request.trackedPostpones &&\n                          null !== boundary$jscomp$0.contentPreamble &&\n                          preparePreamble(request)));\n                  request.allPendingTasks--;\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        if (\n          !1 === hasPendingPreambles ||\n          (preamble.headChunks && preamble.bodyChunks)\n        )\n          request.completedPreambleSegments = collectedPreambleSegments;\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            writeChunk(destination, placeholder1),\n            writeChunk(destination, request.placeholderPrefix),\n            (request = stringToChunk(hoistableState.toString(16))),\n            writeChunk(destination, request),\n            writeChunkAndReturn(destination, placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              writeChunk(destination, chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            writeChunk(destination, chunks[chunkIdx]);\n          chunkIdx < chunks.length &&\n            (r = writeChunkAndReturn(destination, chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        var errorDigest = boundary.errorDigest,\n          errorMessage = boundary.errorMessage,\n          errorStack = boundary.errorStack,\n          errorComponentStack = boundary.errorComponentStack;\n        writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n        writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n        errorDigest &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1A),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorDigest))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorMessage &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1B),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorMessage))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1C),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorStack))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorComponentStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1D),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorComponentStack))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n        flushSubtree(request, destination, segment, hoistableState);\n        (request = boundary.fallbackPreamble) &&\n          writePreambleContribution(destination, request);\n        return writeChunkAndReturn(destination, endSuspenseBoundary);\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((boundary = boundary.fallbackState),\n            boundary.styles.forEach(hoistStyleQueueDependency, hoistableState),\n            boundary.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState),\n          writeChunkAndReturn(destination, endSuspenseBoundary)\n        );\n      if (boundary.byteSize > request.progressiveChunkSize)\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          writeChunkAndReturn(destination, endSuspenseBoundary)\n        );\n      hoistableState &&\n        ((segment = boundary.contentState),\n        segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n        segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n      writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      (request = boundary.contentPreamble) &&\n        writePreambleContribution(destination, request);\n      return writeChunkAndReturn(destination, endSuspenseBoundary);\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      writeChunk(destination, request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              writeChunk(\n                destination,\n                completeBoundaryWithStylesScript1FullPartial\n              ))\n            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryScript1Full))\n          : writeChunk(destination, completeBoundaryScript1Partial);\n      completedSegments = stringToChunk(i.toString(16));\n      writeChunk(destination, request.boundaryPrefix);\n      writeChunk(destination, completedSegments);\n      writeChunk(destination, completeBoundaryScript2);\n      writeChunk(destination, request.segmentPrefix);\n      writeChunk(destination, completedSegments);\n      requiresStyleInsertion\n        ? (writeChunk(destination, completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : writeChunk(destination, completeBoundaryScript3b);\n      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      writeChunk(destination, request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          writeChunk(destination, completeSegmentScript1Full))\n        : writeChunk(destination, completeSegmentScript1Partial);\n      writeChunk(destination, request.segmentPrefix);\n      segmentID = stringToChunk(segmentID.toString(16));\n      writeChunk(destination, segmentID);\n      writeChunk(destination, completeSegmentScript2);\n      writeChunk(destination, request.placeholderPrefix);\n      writeChunk(destination, segmentID);\n      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      currentView = new Uint8Array(2048);\n      writtenBytes = 0;\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            var renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                writeChunk(destination, htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  writeChunk(destination, headChunks[i$jscomp$0]);\n              else\n                writeChunk(destination, startChunkForTag(\"head\")),\n                  writeChunk(destination, endOfStartTag);\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                writeChunk(destination, headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, hoistableChunks[i$jscomp$0]);\n            for (\n              renderState = hoistableChunks.length = 0;\n              renderState < completedPreambleSegments.length;\n              renderState++\n            ) {\n              var segments = completedPreambleSegments[renderState];\n              for (preamble = 0; preamble < segments.length; preamble++)\n                flushSegment(request, destination, segments[preamble], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&\n              writeChunk(destination, endChunkForTag(\"head\"));\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                writeChunk(destination, bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              viewportChunks$jscomp$0[completedRootSegment]\n            );\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              hoistableChunks$jscomp$0[completedRootSegment]\n            );\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.startInlineScript\n            );\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                writeChunk(renderState$jscomp$0, clientRenderScript1Full))\n              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.boundaryPrefix\n            );\n            writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));\n            writeChunk(renderState$jscomp$0, clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            )\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorDigest || \"\")\n                  )\n                );\n            if (errorMessage || errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorMessage || \"\")\n                  )\n                );\n            if (errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorStack || \"\")\n                  )\n                );\n            errorComponentStack &&\n              (writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n              writeChunk(\n                renderState$jscomp$0,\n                stringToChunk(\n                  escapeJSStringsForInstructionScripts(errorComponentStack)\n                )\n              ));\n            var JSCompiler_inline_result = writeChunkAndReturn(\n              renderState$jscomp$0,\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          completeWriting(destination);\n          currentView = new Uint8Array(2048);\n          writtenBytes = 0;\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n        0 === request.pingedTasks.length &&\n        0 === request.clientRenderedBoundaries.length &&\n        0 === request.completedBoundaries.length\n          ? ((request.flushScheduled = !1),\n            (i = request.resumableState),\n            i.hasBody && writeChunk(destination, endChunkForTag(\"body\")),\n            i.hasHtml && writeChunk(destination, endChunkForTag(\"html\")),\n            completeWriting(destination),\n            0 !== request.abortableTasks.size &&\n              console.error(\n                \"There was still abortable task at the root when we closed. This is a bug in React.\"\n              ),\n            (request.status = CLOSED),\n            destination.close(),\n            (request.destination = null))\n          : completeWriting(destination);\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      scheduleMicrotask(function () {\n        return performWork(request);\n      });\n      scheduleWork(function () {\n        10 === request.status && (request.status = 11);\n        null === request.trackedPostpones &&\n          safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n      });\n    }\n    function enqueueFlush(request) {\n      !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination &&\n        ((request.flushScheduled = !0),\n        scheduleWork(function () {\n          var destination = request.destination;\n          destination\n            ? flushCompletedQueues(request, destination)\n            : (request.flushScheduled = !1);\n        }));\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED),\n          closeWithError(destination, request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function ensureCorrectIsomorphicReactVersion() {\n      var isomorphicReactPackageVersion = React.version;\n      if (\"19.1.0\" !== isomorphicReactPackageVersion)\n        throw Error(\n          'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n            (isomorphicReactPackageVersion +\n              \"\\n  - react-dom:  19.1.0\\nLearn more: https://react.dev/warnings/version-mismatch\")\n        );\n    }\n    var React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! react-dom */ \"(pages-dir-browser)/./node_modules/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      channel = new MessageChannel(),\n      taskQueue = [];\n    channel.port1.onmessage = function () {\n      var task = taskQueue.shift();\n      task && task();\n    };\n    var LocalPromise = Promise,\n      scheduleMicrotask =\n        \"function\" === typeof queueMicrotask\n          ? queueMicrotask\n          : function (callback) {\n              LocalPromise.resolve(null)\n                .then(callback)\n                .catch(handleErrorInNextTick);\n            },\n      currentView = null,\n      writtenBytes = 0,\n      textEncoder = new TextEncoder(),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    stringToPrecomputedChunk('\"></template>');\n    var startInlineScript = stringToPrecomputedChunk(\"<script>\"),\n      endInlineScript = stringToPrecomputedChunk(\"\\x3c/script>\"),\n      startScriptSrc = stringToPrecomputedChunk('<script src=\"'),\n      startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"'),\n      scriptNonce = stringToPrecomputedChunk('\" nonce=\"'),\n      scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"'),\n      scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"'),\n      endAsyncScript = stringToPrecomputedChunk('\" async=\"\">\\x3c/script>'),\n      scriptRegex = /(<\\/|<)(s)(cript)/gi,\n      importMapScriptStart = stringToPrecomputedChunk(\n        '<script type=\"importmap\">'\n      ),\n      importMapScriptEnd = stringToPrecomputedChunk(\"\\x3c/script>\");\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var NoContribution = 0,\n      ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      textSeparator = stringToPrecomputedChunk(\"\\x3c!-- --\\x3e\"),\n      styleNameCache = new Map(),\n      styleAttributeStart = stringToPrecomputedChunk(' style=\"'),\n      styleAssign = stringToPrecomputedChunk(\":\"),\n      styleSeparator = stringToPrecomputedChunk(\";\"),\n      attributeSeparator = stringToPrecomputedChunk(\" \"),\n      attributeAssign = stringToPrecomputedChunk('=\"'),\n      attributeEnd = stringToPrecomputedChunk('\"'),\n      attributeEmptyString = stringToPrecomputedChunk('=\"\"'),\n      actionJavaScriptURL = stringToPrecomputedChunk(\n        escapeTextForBrowser(\n          \"javascript:throw new Error('React form unexpectedly submitted.')\"\n        )\n      ),\n      startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"'),\n      endOfStartTag = stringToPrecomputedChunk(\">\"),\n      endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\"),\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"'),\n      formReplayingRuntimeScript = stringToPrecomputedChunk(\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'\n      ),\n      formStateMarkerIsMatching = stringToPrecomputedChunk(\"\\x3c!--F!--\\x3e\"),\n      formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"\\x3c!--F--\\x3e\"),\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = stringToPrecomputedChunk(\"\\n\"),\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\"),\n      endTagCache = new Map(),\n      placeholder1 = stringToPrecomputedChunk('<template id=\"'),\n      placeholder2 = stringToPrecomputedChunk('\"></template>'),\n      startCompletedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$--\\x3e\"),\n      startPendingSuspenseBoundary1 = stringToPrecomputedChunk(\n        '\\x3c!--$?--\\x3e<template id=\"'\n      ),\n      startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>'),\n      startClientRenderedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$!--\\x3e\"),\n      endSuspenseBoundary = stringToPrecomputedChunk(\"\\x3c!--/$--\\x3e\"),\n      clientRenderedSuspenseBoundaryError1 =\n        stringToPrecomputedChunk(\"<template\"),\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial =\n        stringToPrecomputedChunk('\"'),\n      clientRenderedSuspenseBoundaryError1A =\n        stringToPrecomputedChunk(' data-dgst=\"'),\n      clientRenderedSuspenseBoundaryError1B =\n        stringToPrecomputedChunk(' data-msg=\"'),\n      clientRenderedSuspenseBoundaryError1C =\n        stringToPrecomputedChunk(' data-stck=\"'),\n      clientRenderedSuspenseBoundaryError1D =\n        stringToPrecomputedChunk(' data-cstck=\"'),\n      clientRenderedSuspenseBoundaryError2 =\n        stringToPrecomputedChunk(\"></template>\"),\n      boundaryPreambleContributionChunkStart =\n        stringToPrecomputedChunk(\"\\x3c!--\"),\n      boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk(\"--\\x3e\"),\n      startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"'),\n      startSegmentHTML2 = stringToPrecomputedChunk('\">'),\n      endSegmentHTML = stringToPrecomputedChunk(\"</div>\"),\n      startSegmentSVG = stringToPrecomputedChunk(\n        '<svg aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentSVG2 = stringToPrecomputedChunk('\">'),\n      endSegmentSVG = stringToPrecomputedChunk(\"</svg>\"),\n      startSegmentMathML = stringToPrecomputedChunk(\n        '<math aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentMathML2 = stringToPrecomputedChunk('\">'),\n      endSegmentMathML = stringToPrecomputedChunk(\"</math>\"),\n      startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"'),\n      startSegmentTable2 = stringToPrecomputedChunk('\">'),\n      endSegmentTable = stringToPrecomputedChunk(\"</table>\"),\n      startSegmentTableBody = stringToPrecomputedChunk(\n        '<table hidden><tbody id=\"'\n      ),\n      startSegmentTableBody2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\"),\n      startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"'),\n      startSegmentTableRow2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\"),\n      startSegmentColGroup = stringToPrecomputedChunk(\n        '<table hidden><colgroup id=\"'\n      ),\n      startSegmentColGroup2 = stringToPrecomputedChunk('\">'),\n      endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\"),\n      completeSegmentScript1Full = stringToPrecomputedChunk(\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n      ),\n      completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"'),\n      completeSegmentScript2 = stringToPrecomputedChunk('\",\"'),\n      completeSegmentScriptEnd = stringToPrecomputedChunk('\")\\x3c/script>');\n    stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-pid=\"');\n    var completeBoundaryScript1Full = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"'\n      ),\n      completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"'),\n      completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1Partial =\n        stringToPrecomputedChunk('$RR(\"'),\n      completeBoundaryScript2 = stringToPrecomputedChunk('\",\"'),\n      completeBoundaryScript3a = stringToPrecomputedChunk('\",'),\n      completeBoundaryScript3b = stringToPrecomputedChunk('\"'),\n      completeBoundaryScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n    stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-sty=\"');\n    var clientRenderScript1Full = stringToPrecomputedChunk(\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n      ),\n      clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"'),\n      clientRenderScript1A = stringToPrecomputedChunk('\"'),\n      clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\"),\n      clientRenderScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-dgst=\"');\n    stringToPrecomputedChunk('\" data-msg=\"');\n    stringToPrecomputedChunk('\" data-stck=\"');\n    stringToPrecomputedChunk('\" data-cstck=\"');\n    var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style media=\"not all\" data-precedence=\"'\n      ),\n      lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"),\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style data-precedence=\"'\n      ),\n      styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      spaceSeparator = stringToPrecomputedChunk(\" \"),\n      styleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      styleTagResourceClose = stringToPrecomputedChunk(\"</style>\"),\n      arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\"),\n      arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\"),\n      arrayInterstitial = stringToPrecomputedChunk(\",\"),\n      arrayCloseBracket = stringToPrecomputedChunk(\"]\"),\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"\\u00ab\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"\\u00bb\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      lastResetTime = 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      var getCurrentTime = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      getCurrentTime = function () {\n        return localDate.now();\n      };\n    }\n    var CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    ensureCorrectIsomorphicReactVersion();\n    ensureCorrectIsomorphicReactVersion();\n    exports.prerender = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resources = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createPrerenderRequest(\n            children,\n            resources,\n            createRenderState(\n              resources,\n              void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            function () {\n              var result = {\n                prelude: new ReadableStream(\n                  {\n                    type: \"bytes\",\n                    pull: function (controller) {\n                      startFlowing(request, controller);\n                    },\n                    cancel: function (reason) {\n                      request.destination = null;\n                      abort(request, reason);\n                    }\n                  },\n                  { highWaterMark: 0 }\n                )\n              };\n              resolve(result);\n            },\n            void 0,\n            void 0,\n            reject,\n            options ? options.onPostpone : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.renderToReadableStream = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onFatalError,\n          onAllReady,\n          allReady = new Promise(function (res, rej) {\n            onAllReady = res;\n            onFatalError = rej;\n          }),\n          onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resumableState = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createRequest(\n            children,\n            resumableState,\n            createRenderState(\n              resumableState,\n              options ? options.nonce : void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            onAllReady,\n            function () {\n              var stream = new ReadableStream(\n                {\n                  type: \"bytes\",\n                  pull: function (controller) {\n                    startFlowing(request, controller);\n                  },\n                  cancel: function (reason) {\n                    request.destination = null;\n                    abort(request, reason);\n                  }\n                },\n                { highWaterMark: 0 }\n              );\n              stream.allReady = allReady;\n              resolve(stream);\n            },\n            function (error) {\n              allReady.catch(function () {});\n              reject(error);\n            },\n            onFatalError,\n            options ? options.onPostpone : void 0,\n            options ? options.formState : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.version = \"19.1.0\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osaUJBQWlCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQixtREFBbUQsbUJBQW1CLFdBQVcsK0JBQStCO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCLFdBQVcsZUFBZSxtQkFBbUI7QUFDbEUsbUJBQW1CO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qiw0QkFBNEIsV0FBVyxlQUFlLG1CQUFtQjtBQUN6RSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDhCQUE4QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2ZBQXNmLFdBQVcsMExBQTBMLFNBQVMsV0FBVyxFQUFFO0FBQ2p0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBZ0UsZUFBZSxvQ0FBb0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQWdFLGVBQWUsb0NBQW9DO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVELHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLDRDQUE0QyxNQUFNLG1DQUFtQyxzQkFBc0Isa1ZBQWtWLEVBQUU7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsZ0NBQWdDLGFBQWEsMkNBQTJDLDZCQUE2QjtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkIsNEJBQTRCLGlDQUFpQyxNQUFNLG9CQUFvQiwrQ0FBK0MsS0FBSyxlQUFlLGdCQUFnQixRQUFRLEdBQUcsc0JBQXNCLGFBQWEsMkJBQTJCLFNBQVMscUNBQXFDLGdCQUFnQixpQkFBaUIsSUFBSSxTQUFTLEtBQUssYUFBYSxnQ0FBZ0MsV0FBVyxpQ0FBaUM7QUFDdmU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2Qiw0QkFBNEIsaUNBQWlDLE1BQU0sb0JBQW9CLCtDQUErQyxLQUFLLGVBQWUsZ0JBQWdCLFFBQVEsR0FBRyxzQkFBc0IsYUFBYSwyQkFBMkIsU0FBUyxxQ0FBcUMsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLGlDQUFpQyxZQUFZLHNCQUFzQixjQUFjLGFBQWEsSUFBSSwySEFBMkgsU0FBUyxxSUFBcUksSUFBSSxLQUFLLFFBQVEsVUFBVSxFQUFFLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLGFBQWEsYUFBYSxlQUFlLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixXQUFXLG1CQUFtQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxXQUFXLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Rix1RkFBdUY7QUFDNWdEO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM5aUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQywwSUFBMEk7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMscURBQXFEO0FBQ3JELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksOEJBQThCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJLGVBQWU7QUFDbkIsR0FBRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1kb21cXGNqc1xccmVhY3QtZG9tLXNlcnZlci5icm93c2VyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcblxuXG4gSlMgSW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMgKHIxMzYpIChhcyBvZiBNYXkgMjAsIDIwMTEpXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTEgR2FyeSBDb3VydFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIFNPRlRXQVJFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gc3R5bGVSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcNzMgXCIgOiBcIlxcXFw1MyBcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjcmlwdFJlcGxhY2VyKG1hdGNoLCBwcmVmaXgsIHMsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAoXCJzXCIgPT09IHMgPyBcIlxcXFx1MDA3M1wiIDogXCJcXFxcdTAwNTNcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmplY3QpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgICAgICAgcmV0dXJuIHAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2Uoa2V5KSB7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGtleSArICdcIicgPT09IGVuY29kZWRLZXkgPyBrZXkgOiBlbmNvZGVkS2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgMTAgPj0gdmFsdWUubGVuZ3RoID8gdmFsdWUgOiB2YWx1ZS5zbGljZSgwLCAxMCkgKyBcIi4uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHZhbHVlICYmIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRylcbiAgICAgICAgICAgIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICAgIHZhbHVlID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHZhbHVlID8gXCJ7Li4ufVwiIDogdmFsdWU7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUdcbiAgICAgICAgICAgID8gXCJjbGllbnRcIlxuICAgICAgICAgICAgOiAodmFsdWUgPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyB2YWx1ZVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS50eXBlKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2Uob2JqZWN0T3JBcnJheSwgZXhwYW5kZWROYW1lKSB7XG4gICAgICB2YXIgb2JqS2luZCA9IG9iamVjdE5hbWUob2JqZWN0T3JBcnJheSk7XG4gICAgICBpZiAoXCJPYmplY3RcIiAhPT0gb2JqS2luZCAmJiBcIkFycmF5XCIgIT09IG9iaktpbmQpIHJldHVybiBvYmpLaW5kO1xuICAgICAgdmFyIHN0YXJ0ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBpZiAoaXNBcnJheUltcGwob2JqZWN0T3JBcnJheSkpXG4gICAgICAgIGlmIChqc3hDaGlsZHJlblBhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdE9yQXJyYXlbaV07XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiXG4gICAgICAgICAgICAgICAgICA6IFwie1wiICsgZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIjtcbiAgICAgICAgICAgIFwiXCIgKyBpID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSB2YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IHZhbHVlKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxNSA+IHZhbHVlLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiey4uLn1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI8L1wiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIltcIjtcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgICAgIDAgPCB0eXBlICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChpID0gb2JqZWN0T3JBcnJheVt0eXBlXSksXG4gICAgICAgICAgICAgIChpID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaSAmJiBudWxsICE9PSBpXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGkpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoaSkpLFxuICAgICAgICAgICAgICBcIlwiICsgdHlwZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IGkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IGkpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IGkubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIGlcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwiXVwiO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUob2JqZWN0T3JBcnJheS50eXBlKSArIFwiLz5cIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICBpZiAoanN4UHJvcHNQYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIG9iaktpbmQgPSBqc3hQcm9wc1BhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIChkZXNjcmliZUVsZW1lbnRUeXBlKG9iaktpbmQpIHx8IFwiLi4uXCIpO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqS2luZCArPSBcIiBcIjtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZVtpXTtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI9XCI7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdO1xuICAgICAgICAgICAgdmFyIF9zdWJzdHIyID1cbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZSAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBfdmFsdWUyICYmIChfc3Vic3RyMiA9IFwie1wiICsgX3N1YnN0cjIgKyBcIn1cIik7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfc3Vic3RyMikpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTAgPiBfc3Vic3RyMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF9zdWJzdHIyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfc3Vic3RyMlxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJ7XCI7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgMCA8IGkgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gdHlwZVtpXSksXG4gICAgICAgICAgICAgIChvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiOiBcIiksXG4gICAgICAgICAgICAgIChfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV0pLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiYgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpKSxcbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBfdmFsdWUyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfdmFsdWUyKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBfdmFsdWUyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3ZhbHVlMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgID8gb2JqS2luZFxuICAgICAgICA6IC0xIDwgc3RhcnQgJiYgMCA8IGxlbmd0aFxuICAgICAgICAgID8gKChvYmplY3RPckFycmF5ID0gXCIgXCIucmVwZWF0KHN0YXJ0KSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKSxcbiAgICAgICAgICAgIFwiXFxuICBcIiArIG9iaktpbmQgKyBcIlxcbiAgXCIgKyBvYmplY3RPckFycmF5KVxuICAgICAgICAgIDogXCJcXG4gIFwiICsgb2JqS2luZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbXVybXVyaGFzaDNfMzJfZ2Moa2V5LCBzZWVkKSB7XG4gICAgICB2YXIgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7XG4gICAgICB2YXIgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICAgICAgdmFyIGgxID0gc2VlZDtcbiAgICAgIGZvciAoc2VlZCA9IDA7IHNlZWQgPCBieXRlczsgKSB7XG4gICAgICAgIHZhciBrMSA9XG4gICAgICAgICAgKGtleS5jaGFyQ29kZUF0KHNlZWQpICYgMjU1KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCA4KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCAxNikgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgMjQpO1xuICAgICAgICArK3NlZWQ7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCgzNDMyOTE4MzUzICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgICAgICBrMSA9XG4gICAgICAgICAgKDQ2MTg0NTkwNyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCg0NjE4NDU5MDcgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gKGgxIDw8IDEzKSB8IChoMSA+Pj4gMTkpO1xuICAgICAgICBoMSA9XG4gICAgICAgICAgKDUgKiAoaDEgJiA2NTUzNSkgKyAoKCg1ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJiA0Mjk0OTY3Mjk1O1xuICAgICAgICBoMSA9IChoMSAmIDY1NTM1KSArIDI3NDkyICsgKCgoKGgxID4+PiAxNikgKyA1ODk2NCkgJiA2NTUzNSkgPDwgMTYpO1xuICAgICAgfVxuICAgICAgazEgPSAwO1xuICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChzZWVkICsgMikgJiAyNTUpIDw8IDE2O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KHNlZWQgKyAxKSAmIDI1NSkgPDwgODtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIChrMSBePSBrZXkuY2hhckNvZGVBdChzZWVkKSAmIDI1NSksXG4gICAgICAgICAgICAoazEgPVxuICAgICAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAgICAgKCgoMzQzMjkxODM1MyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSksXG4gICAgICAgICAgICAoazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNykpLFxuICAgICAgICAgICAgKGgxIF49XG4gICAgICAgICAgICAgICg0NjE4NDU5MDcgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgICAgICgoKDQ2MTg0NTkwNyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSk7XG4gICAgICB9XG4gICAgICBoMSBePSBrZXkubGVuZ3RoO1xuICAgICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgICAgaDEgPVxuICAgICAgICAoMjI0NjgyMjUwNyAqIChoMSAmIDY1NTM1KSArXG4gICAgICAgICAgKCgoMjI0NjgyMjUwNyAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgIGgxIF49IGgxID4+PiAxMztcbiAgICAgIGgxID1cbiAgICAgICAgKDMyNjY0ODk5MDkgKiAoaDEgJiA2NTUzNSkgK1xuICAgICAgICAgICgoKDMyNjY0ODk5MDkgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICByZXR1cm4gKGgxIF4gKGgxID4+PiAxNikpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoY2FsbGJhY2spIHtcbiAgICAgIHRhc2tRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKSB7XG4gICAgICBpZiAoMCAhPT0gY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgICAgaWYgKDIwNDggPCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5lbnF1ZXVlKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShjdXJyZW50Vmlldy5idWZmZXIsIDAsIHdyaXR0ZW5CeXRlcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcbiAgICAgICAgICBhbGxvd2FibGVCeXRlcyA8IGNodW5rLmJ5dGVMZW5ndGggJiZcbiAgICAgICAgICAgICgwID09PSBhbGxvd2FibGVCeXRlc1xuICAgICAgICAgICAgICA/IGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnRWaWV3LnNldChcbiAgICAgICAgICAgICAgICAgIGNodW5rLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgIHdyaXR0ZW5CeXRlc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjdXJyZW50VmlldyksXG4gICAgICAgICAgICAgICAgKGNodW5rID0gY2h1bmsuc3ViYXJyYXkoYWxsb3dhYmxlQnl0ZXMpKSksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgICAgICAgIGN1cnJlbnRWaWV3LnNldChjaHVuaywgd3JpdHRlbkJ5dGVzKTtcbiAgICAgICAgICB3cml0dGVuQnl0ZXMgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgICAgIGN1cnJlbnRWaWV3ICYmXG4gICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgKGRlc3RpbmF0aW9uLmVucXVldWUoXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY3VycmVudFZpZXcuYnVmZmVyLCAwLCB3cml0dGVuQnl0ZXMpXG4gICAgICAgICksXG4gICAgICAgIChjdXJyZW50VmlldyA9IG51bGwpLFxuICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0NodW5rKGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuICAgICAgMjA0OCA8IGNvbnRlbnQuYnl0ZUxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicHJlY29tcHV0ZWQgY2h1bmtzIG11c3QgYmUgc21hbGxlciB0aGFuIHRoZSB2aWV3IHNpemUgY29uZmlndXJlZCBmb3IgdGhpcyBob3N0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIGVycm9yKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXN0aW5hdGlvbi5lcnJvclxuICAgICAgICA/IGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICBcIk9iamVjdFwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSksICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMCk7XG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYFwiLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICAgICAgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fFxuICAgICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5vbklucHV0IHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgKFwic2VsZWN0XCIgPT09IHRhZ05hbWVcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgYG9uQ2hhbmdlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMuY2hlY2tlZCB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IFwiYXJpYS1cIiArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSkgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBuYW1lICE9PSB0YWdOYW1lICYmXG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlVua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gICAgICB2YXIgaW52YWxpZFByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KSB8fCBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSBpbnZhbGlkUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IGludmFsaWRQcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCBpbnZhbGlkUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoXCJvbmZvY3VzaW5cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJvbmZvY3Vzb3V0XCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiBBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0IGFyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgKChcImZvcm1cIiA9PT0gdGFnTmFtZSAmJiBcImFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImlucHV0XCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiYnV0dG9uXCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRhZ05hbWUgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG4gICAgICAgIGlmIChldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBldmVudFJlZ2lzdHJ5ID0gdGFnTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICA/IHRhZ05hbWVbbG93ZXJDYXNlZE5hbWVdXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRSZWdpc3RyeVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIFJlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHJldHVybiAhMDtcbiAgICAgIGlmIChcImlubmVyaHRtbFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwiYXJpYVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImlzXCIgPT09IGxvd2VyQ2FzZWROYW1lICYmXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIHZvaWQgMCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlICYmIGlzTmFOKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgobG93ZXJDYXNlZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdKSxcbiAgICAgICAgICBsb3dlckNhc2VkTmFtZSAhPT0gbmFtZSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91IGludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuIElmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwiYXJpYS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbklmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCBwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGlmIChcImZhbHNlXCIgPT09IHZhbHVlIHx8IFwidHJ1ZVwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAlcyBEaWQgeW91IG1lYW4gJXM9eyVzfT9cIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIFwiZmFsc2VcIiA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IFwiVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuXCJcbiAgICAgICAgICAgICAgICA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgdW5rbm93blByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSkgfHxcbiAgICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSB1bmtub3duUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IHVua25vd25Qcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgdW5rbm93blByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICAgICAgaWYgKFxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHRleHRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0ZXh0O1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odGV4dCk7XG4gICAgICB0ZXh0ID0gXCJcIiArIHRleHQ7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyh0ZXh0KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgaHRtbCA9IFwiXCIsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc3dpdGNoICh0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZhbXA7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiYjeDI3O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImbHQ7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZndDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEluZGV4ICE9PSBpbmRleCAmJiAoaHRtbCArPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgaHRtbCArPSBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgICAgIHJldHVybiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KFwiXCIgKyB1cmwpXG4gICAgICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICAgICAgOiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzY3JpcHRUZXh0KS5yZXBsYWNlKHNjcmlwdFJlZ2V4LCBzY3JpcHRSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICBub25jZSxcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgIGltcG9ydE1hcCxcbiAgICAgIG9uSGVhZGVycyxcbiAgICAgIG1heEhlYWRlcnNMZW5ndGhcbiAgICApIHtcbiAgICAgIHZhciBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPVxuICAgICAgICAgIHZvaWQgMCA9PT0gbm9uY2VcbiAgICAgICAgICAgID8gc3RhcnRJbmxpbmVTY3JpcHRcbiAgICAgICAgICAgIDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAgICAgICAgICc8c2NyaXB0IG5vbmNlPVwiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSArICdcIj4nXG4gICAgICAgICAgICAgICksXG4gICAgICAgIGlkUHJlZml4ID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXg7XG4gICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcgPSBbXTtcbiAgICAgIHZhciBib290c3RyYXBTY3JpcHRDb250ZW50ID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBNb2R1bGVzO1xuICAgICAgdm9pZCAwICE9PSBib290c3RyYXBTY3JpcHRDb250ZW50ICYmXG4gICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgIGlubGluZVNjcmlwdFdpdGhOb25jZSxcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChib290c3RyYXBTY3JpcHRDb250ZW50KVxuICAgICAgICAgICksXG4gICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICk7XG4gICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gW107XG4gICAgICB2b2lkIDAgIT09IGltcG9ydE1hcCAmJlxuICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKGltcG9ydE1hcFNjcmlwdFN0YXJ0KSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKFxuICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KEpTT04uc3RyaW5naWZ5KGltcG9ydE1hcCkpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50LnB1c2goaW1wb3J0TWFwU2NyaXB0RW5kKSk7XG4gICAgICBvbkhlYWRlcnMgJiZcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggJiZcbiAgICAgICAgMCA+PSBtYXhIZWFkZXJzTGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCBhIHBvc2l0aXZlIG5vbi16ZXJvIGBtYXhIZWFkZXJzTGVuZ3RoYCBvcHRpb24gYnV0IGZvdW5kICVzIGluc3RlYWQuIFdoZW4gdXNpbmcgdGhlIGBvbkhlYWRlcnNgIG9wdGlvbiB5b3UgbWF5IHN1cHBseSBhbiBvcHRpb25hbCBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGFzIHdlbGwgaG93ZXZlciwgd2hlbiBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gemVybyBvciBsZXNzIG5vIGhlYWRlcnMgd2lsbCBiZSBjYXB0dXJlZC5cIixcbiAgICAgICAgICAwID09PSBtYXhIZWFkZXJzTGVuZ3RoID8gXCJ6ZXJvXCIgOiBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICBpbXBvcnRNYXAgPSBvbkhlYWRlcnNcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBwcmVjb25uZWN0czogXCJcIixcbiAgICAgICAgICAgIGZvbnRQcmVsb2FkczogXCJcIixcbiAgICAgICAgICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBcIlwiLFxuICAgICAgICAgICAgcmVtYWluaW5nQ2FwYWNpdHk6XG4gICAgICAgICAgICAgIDIgK1xuICAgICAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggPyBtYXhIZWFkZXJzTGVuZ3RoIDogMmUzKVxuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgICAgb25IZWFkZXJzID0ge1xuICAgICAgICBwbGFjZWhvbGRlclByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgXCJQOlwiKSxcbiAgICAgICAgc2VnbWVudFByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgXCJTOlwiKSxcbiAgICAgICAgYm91bmRhcnlQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiQjpcIiksXG4gICAgICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgICAgIHByZWFtYmxlOiBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdDogbnVsbCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzOiBleHRlcm5hbFJ1bnRpbWVDb25maWcsXG4gICAgICAgIGltcG9ydE1hcENodW5rczogYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgb25IZWFkZXJzOiBvbkhlYWRlcnMsXG4gICAgICAgIGhlYWRlcnM6IGltcG9ydE1hcCxcbiAgICAgICAgcmVzZXRzOiB7XG4gICAgICAgICAgZm9udDoge30sXG4gICAgICAgICAgZG5zOiB7fSxcbiAgICAgICAgICBjb25uZWN0OiB7IGRlZmF1bHQ6IHt9LCBhbm9ueW1vdXM6IHt9LCBjcmVkZW50aWFsczoge30gfSxcbiAgICAgICAgICBpbWFnZToge30sXG4gICAgICAgICAgc3R5bGU6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJzZXRDaHVua3M6IFtdLFxuICAgICAgICB2aWV3cG9ydENodW5rczogW10sXG4gICAgICAgIGhvaXN0YWJsZUNodW5rczogW10sXG4gICAgICAgIHByZWNvbm5lY3RzOiBuZXcgU2V0KCksXG4gICAgICAgIGZvbnRQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBzdHlsZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBzY3JpcHRzOiBuZXcgU2V0KCksXG4gICAgICAgIGJ1bGtQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBwcmVsb2Fkczoge1xuICAgICAgICAgIGltYWdlczogbmV3IE1hcCgpLFxuICAgICAgICAgIHN0eWxlc2hlZXRzOiBuZXcgTWFwKCksXG4gICAgICAgICAgc2NyaXB0czogbmV3IE1hcCgpLFxuICAgICAgICAgIG1vZHVsZVNjcmlwdHM6IG5ldyBNYXAoKVxuICAgICAgICB9LFxuICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgIGhvaXN0YWJsZVN0YXRlOiBudWxsLFxuICAgICAgICBzdHlsZXNUb0hvaXN0OiAhMVxuICAgICAgfTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdHMpXG4gICAgICAgIGZvciAoaW1wb3J0TWFwID0gMDsgaW1wb3J0TWFwIDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7IGltcG9ydE1hcCsrKSB7XG4gICAgICAgICAgbWF4SGVhZGVyc0xlbmd0aCA9IGJvb3RzdHJhcFNjcmlwdHNbaW1wb3J0TWFwXTtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gaWRQcmVmaXggPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgIGFzOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogXCJsb3dcIixcbiAgICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGhcbiAgICAgICAgICAgID8gKHByb3BzLmhyZWYgPSBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBtYXhIZWFkZXJzTGVuZ3RoKVxuICAgICAgICAgICAgOiAoKHByb3BzLmhyZWYgPSBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBtYXhIZWFkZXJzTGVuZ3RoLnNyYyksXG4gICAgICAgICAgICAgIChwcm9wcy5pbnRlZ3JpdHkgPSBib290c3RyYXBTY3JpcHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgID8gbWF4SGVhZGVyc0xlbmd0aC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwKSxcbiAgICAgICAgICAgICAgKHByb3BzLmNyb3NzT3JpZ2luID0gaWRQcmVmaXggPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PSBtYXhIZWFkZXJzTGVuZ3RoLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgOiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBtYXhIZWFkZXJzTGVuZ3RoLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKTtcbiAgICAgICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUoXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIG9uSGVhZGVycyxcbiAgICAgICAgICAgIGlubGluZVNjcmlwdFdpdGhOb25jZSxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgIHN0YXJ0U2NyaXB0U3JjLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbmxpbmVTY3JpcHRXaXRoTm9uY2UpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbm9uY2UgJiZcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICBzY3JpcHROb25jZSxcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRDb250ZW50ICYmXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgc2NyaXB0SW50ZWdpcnR5LFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaWRQcmVmaXggJiZcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICBzY3JpcHRDcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpZFByZWZpeCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgaWYgKHZvaWQgMCAhPT0gYm9vdHN0cmFwTW9kdWxlcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRzID0gMDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRzIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cysrXG4gICAgICAgIClcbiAgICAgICAgICAoaW1wb3J0TWFwID0gYm9vdHN0cmFwTW9kdWxlc1tib290c3RyYXBTY3JpcHRzXSksXG4gICAgICAgICAgICAoaWRQcmVmaXggPSBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSB2b2lkIDApLFxuICAgICAgICAgICAgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSB7XG4gICAgICAgICAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW1wb3J0TWFwXG4gICAgICAgICAgICAgID8gKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuaHJlZiA9IG1heEhlYWRlcnNMZW5ndGggPSBpbXBvcnRNYXApXG4gICAgICAgICAgICAgIDogKChib290c3RyYXBTY3JpcHRDb250ZW50LmhyZWYgPSBtYXhIZWFkZXJzTGVuZ3RoID1cbiAgICAgICAgICAgICAgICAgIGltcG9ydE1hcC5zcmMpLFxuICAgICAgICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50LmludGVncml0eSA9IGlkUHJlZml4ID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbXBvcnRNYXAuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gaW1wb3J0TWFwLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgICAgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuY3Jvc3NPcmlnaW4gPSBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGltcG9ydE1hcCB8fCBudWxsID09IGltcG9ydE1hcC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGltcG9ydE1hcC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIikpLFxuICAgICAgICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgb25IZWFkZXJzLFxuICAgICAgICAgICAgICBtYXhIZWFkZXJzTGVuZ3RoLFxuICAgICAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICAgIHN0YXJ0TW9kdWxlU3JjLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG1heEhlYWRlcnNMZW5ndGgpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5vbmNlICYmXG4gICAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdE5vbmNlLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlkUHJlZml4ICYmXG4gICAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdEludGVnaXJ0eSxcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGlkUHJlZml4KSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgJiZcbiAgICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICAgICAgc2NyaXB0Q3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbmxpbmVTY3JpcHRXaXRoTm9uY2UpKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgICAgcmV0dXJuIG9uSGVhZGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICBib290c3RyYXBNb2R1bGVzXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZFByZWZpeDogdm9pZCAwID09PSBpZGVudGlmaWVyUHJlZml4ID8gXCJcIiA6IGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG5leHRGb3JtSUQ6IDAsXG4gICAgICAgIHN0cmVhbWluZ0Zvcm1hdDogMCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudDogYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlczogYm9vdHN0cmFwTW9kdWxlcyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBOb3RoaW5nU2VudCxcbiAgICAgICAgaGFzQm9keTogITEsXG4gICAgICAgIGhhc0h0bWw6ICExLFxuICAgICAgICB1bmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgZG5zUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgY29ubmVjdFJlc291cmNlczogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgIGltYWdlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc3R5bGVSZXNvdXJjZXM6IHt9LFxuICAgICAgICBzY3JpcHRSZXNvdXJjZXM6IHt9LFxuICAgICAgICBtb2R1bGVVbmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlU2NyaXB0UmVzb3VyY2VzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJlYW1ibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGh0bWxDaHVua3M6IG51bGwsXG4gICAgICAgIGhlYWRDaHVua3M6IG51bGwsXG4gICAgICAgIGJvZHlDaHVua3M6IG51bGwsXG4gICAgICAgIGNvbnRyaWJ1dGlvbjogTm9Db250cmlidXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdENvbnRleHQoaW5zZXJ0aW9uTW9kZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnU2NvcGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHRhZ1Njb3BlOiB0YWdTY29wZVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdEZvcm1hdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiID09PSBuYW1lc3BhY2VVUklcbiAgICAgICAgICA/IFNWR19NT0RFXG4gICAgICAgICAgOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiA9PT0gbmFtZXNwYWNlVVJJXG4gICAgICAgICAgICA/IE1BVEhNTF9NT0RFXG4gICAgICAgICAgICA6IFJPT1RfSFRNTF9NT0RFLFxuICAgICAgICBudWxsLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMudmFsdWUgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCAyXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJmb3JlaWduT2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX0NPTEdST1VQX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIEhUTUxfSEVBRF9NT0RFLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIEhUTUxfSFRNTF9NT0RFLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUgfHxcbiAgICAgICAgcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFXG4gICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgIDogcGFyZW50Q29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRleHRJbnN0YW5jZSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIGlmIChcIlwiID09PSB0ZXh0KSByZXR1cm4gdGV4dEVtYmVkZGVkO1xuICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSkpO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCBzdHlsZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpc0ZpcnN0ID0gITAsXG4gICAgICAgIHN0eWxlTmFtZTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIHN0eWxlKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgc3R5bGVOYW1lKSkge1xuICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVbc3R5bGVOYW1lXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9IHN0eWxlVmFsdWUgJiZcbiAgICAgICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2Ygc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJcIiAhPT0gc3R5bGVWYWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIikpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3R5bGVOYW1lKSk7XG4gICAgICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICAgICAgICBzdHlsZVZhbHVlID0gc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcigoXCJcIiArIHN0eWxlVmFsdWUpLnRyaW0oKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKC0xIDwgbmFtZUNodW5rLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgXCJtcy1cIikpXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lQ2h1bmspKVxuICAgICAgICAgICAgICAgIChuYW1lID0gbmFtZUNodW5rKSxcbiAgICAgICAgICAgICAgICAgICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWUkanNjb21wJDBdKSB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uIFRyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoaXNOYU4odmFsdWUpXG4gICAgICAgICAgICAgICAgICA/IHdhcm5lZEZvck5hTlZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9yTmFOVmFsdWUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IGlzRmluaXRlKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHlsZU5hbWVDYWNoZS5nZXQobmFtZUNodW5rKTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gKG5hbWVDaHVuayA9IHZhbHVlKVxuICAgICAgICAgICAgICAgIDogKCh2YWx1ZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCBcIi0kMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG1zUGF0dGVybiwgXCItbXMtXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgc3R5bGVOYW1lQ2FjaGUuc2V0KG5hbWVDaHVuaywgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgKG5hbWVDaHVuayA9IHZhbHVlKSk7XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgPyAoc3R5bGVWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHN0eWxlVmFsdWUgfHwgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmdUb0NodW5rKFwiXCIgKyBzdHlsZVZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgIDogc3RyaW5nVG9DaHVuayhzdHlsZVZhbHVlICsgXCJweFwiKSlcbiAgICAgICAgICAgICAgICA6IChjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgIChzdHlsZVZhbHVlID0gc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoKFwiXCIgKyBzdHlsZVZhbHVlKS50cmltKCkpXG4gICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0ZpcnN0XG4gICAgICAgICAgICAgID8gKChpc0ZpcnN0ID0gITEpLFxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgICAgc3R5bGVBdHRyaWJ1dGVTdGFydCxcbiAgICAgICAgICAgICAgICAgIG5hbWVDaHVuayxcbiAgICAgICAgICAgICAgICAgIHN0eWxlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogdGFyZ2V0LnB1c2goc3R5bGVTZXBhcmF0b3IsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHN0eWxlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaXNGaXJzdCB8fCB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgYXR0cmlidXRlRW1wdHlTdHJpbmdcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLFxuICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgICB0aGlzLnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcbiAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0aGlzLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgIHRoaXMucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuIFdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IGh5ZHJhdGlvbi5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKSB7XG4gICAgICAgIHZhciBpZCA9IHJlc3VtYWJsZVN0YXRlLm5leHRGb3JtSUQrKztcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIGlmIChjdXN0b21GaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJiBmb3JtRGF0YS5mb3JFYWNoKHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXN0b21GaWVsZHM7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gc2VyaWFsaXplIGFuIGFjdGlvbiBmb3IgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQ6XFxuJXNcIixcbiAgICAgICAgICAgIHhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICB0YXJnZXQsXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1UYXJnZXQsXG4gICAgICBuYW1lXG4gICAgKSB7XG4gICAgICB2YXIgZm9ybURhdGEgPSBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24pIHtcbiAgICAgICAgbnVsbCA9PT0gbmFtZSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IHNwZWNpZnkgYSBcIm5hbWVcIiBwcm9wIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgbmVlZHMgaXQgdG8gZW5jb2RlIHdoaWNoIGFjdGlvbiBzaG91bGQgYmUgaW52b2tlZC4gSXQgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nXG4gICAgICAgICAgKSk7XG4gICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSAmJiBudWxsID09PSBmb3JtTWV0aG9kKSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1FbmNUeXBlIG9yIGZvcm1NZXRob2QgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1UYXJnZXQgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgd2luZG93LlwiXG4gICAgICAgICAgKSk7XG4gICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKTtcbiAgICAgICAgbnVsbCAhPT0gY3VzdG9tRmllbGRzXG4gICAgICAgICAgPyAoKG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZSksXG4gICAgICAgICAgICAoZm9ybUFjdGlvbiA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAoZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZSksXG4gICAgICAgICAgICAoZm9ybU1ldGhvZCA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgKGZvcm1UYXJnZXQgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgIChmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhKSlcbiAgICAgICAgICA6ICh0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFwiZm9ybUFjdGlvblwiKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGZvcm1NZXRob2QgPSBmb3JtRW5jVHlwZSA9IGZvcm1BY3Rpb24gPSBuYW1lID0gbnVsbCksXG4gICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT0gbmFtZSAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1BY3Rpb25cIiwgZm9ybUFjdGlvbik7XG4gICAgICBudWxsICE9IGZvcm1FbmNUeXBlICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1FbmNUeXBlXCIsIGZvcm1FbmNUeXBlKTtcbiAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtTWV0aG9kXCIsIGZvcm1NZXRob2QpO1xuICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0ICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1UYXJnZXRcIiwgZm9ybVRhcmdldCk7XG4gICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJjbGFzc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0YWJJbmRleFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInRhYmluZGV4XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwicm9sZVwiOlxuICAgICAgICBjYXNlIFwidmlld0JveFwiOlxuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIGlmIChcIlwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgXCJzcmNcIiA9PT0gbmFtZVxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRoaXMgbWF5IGNhdXNlIHRoZSBicm93c2VyIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBwYWdlIGFnYWluIG92ZXIgdGhlIG5ldHdvcmsuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0hyZWZcIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcInhsaW5rOmhyZWZcIiksXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgXCJcIiAhPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIGVtcHR5IHN0cmluZyBmb3IgYSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiBUaGlzIHdpbGwgdHJlYXQgdGhlIGF0dHJpYnV0ZSBhcyBpZiBpdCB3ZXJlIGZhbHNlLiBFaXRoZXIgcGFzcyBgZmFsc2VgIHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLCBvciBwYXNzIGB0cnVlYCBpZiB5b3UgdXNlZCBhbiBlbXB0eSBzdHJpbmcgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBSZWFjdCB0byBpbmRpY2F0ZSB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgITAgPT09IHZhbHVlXG4gICAgICAgICAgICA/IHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVtcHR5U3RyaW5nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogITEgIT09IHZhbHVlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29sc1wiOlxuICAgICAgICBjYXNlIFwicm93c1wiOlxuICAgICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZSkgJiZcbiAgICAgICAgICAgIDEgPD0gdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyb3dTcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIGlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rQWN0dWF0ZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOmFjdHVhdGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBcmNyb2xlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YXJjcm9sZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazpyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rU2hvd1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnNob3dcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUaXRsZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnRpdGxlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rVHlwZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnR5cGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sQmFzZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpiYXNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbExhbmdcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6bGFuZ1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxTcGFjZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpzcGFjZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgISgyIDwgbmFtZS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoXCJvXCIgIT09IG5hbWVbMF0gJiYgXCJPXCIgIT09IG5hbWVbMF0pIHx8XG4gICAgICAgICAgICAoXCJuXCIgIT09IG5hbWVbMV0gJiYgXCJOXCIgIT09IG5hbWVbMV0pXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKG5hbWUgPSBhbGlhc2VzLmdldChuYW1lKSB8fCBuYW1lKSwgaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgIT09IHByZWZpeCAmJiBcImFyaWEtXCIgIT09IHByZWZpeCkgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCAhPSBpbm5lckhUTUwpIHtcbiAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbm5lckhUTUwgfHwgIShcIl9faHRtbFwiIGluIGlubmVySFRNTCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaW5uZXJIVE1MID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgICAgbnVsbCAhPT0gaW5uZXJIVE1MICYmXG4gICAgICAgICAgdm9pZCAwICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICAoY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaW5uZXJIVE1MKSxcbiAgICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKFwiXCIgKyBpbm5lckhUTUwpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgKCh2YWx1ZSA9IGlzQXJyYXlJbXBsKHZhbHVlKSksXG4gICAgICAgIHByb3BzLm11bHRpcGxlICYmICF2YWx1ZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgYG11bHRpcGxlYCBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogIXByb3BzLm11bHRpcGxlICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgdmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS5cIixcbiAgICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgKChjb250ZW50ICs9IGNoaWxkKSxcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbm5vdCBpbmZlciB0aGUgb3B0aW9uIHZhbHVlIG9mIGNvbXBsZXggY2hpbGRyZW4uIFBhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LlwiXG4gICAgICAgICAgICApKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiAxNikgPT09IE5vdGhpbmdTZW50ICYmXG4gICAgICAgICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IDE2KSxcbiAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQoXG4gICAgICAgICAgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsXG4gICAgICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQsXG4gICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImxpbmtcIikpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcImxpbmsgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3R5bGVUZXh0Q29udGVudChzdHlsZVRleHQpIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHN0eWxlVGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzdHlsZVRleHQpLnJlcGxhY2Uoc3R5bGVSZWdleCwgc3R5bGVSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRpdGxlXCIpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwcm9wcyA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gMiA+IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgID8gY2hpbGRyZW5bMF1cbiAgICAgICAgICA6IG51bGxcbiAgICAgICAgOiBjaGlsZHJlbjtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBwcm9wcyAmJlxuICAgICAgICB2b2lkIDAgIT09IHByb3BzICYmXG4gICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHByb3BzKSkpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInNjcmlwdFwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgbnVsbCAhPSBjaGlsZHJlbiAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgKChwcm9wcyA9XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkcmVuXG4gICAgICAgICAgICA/IFwiYSBudW1iZXIgZm9yIGNoaWxkcmVuXCJcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgICAgPyBcImFuIGFycmF5IGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICAgIDogXCJzb21ldGhpbmcgdW5leHBlY3RlZCBmb3IgY2hpbGRyZW5cIiksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuIENvbnNpZGVyIHVzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIG9yIHBhc3NpbmcgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4uXCIsXG4gICAgICAgICAgcHJvcHNcbiAgICAgICAgKSk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KGNoaWxkcmVuKSkpO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0YWdcbiAgICAgICAgPyAodGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0YWcpKSksIG51bGwpXG4gICAgICAgIDogdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHRhZ1N0YXJ0Q2h1bmspIHtcbiAgICAgICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB0aHJvdyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8XCIgKyB0YWcpO1xuICAgICAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWdTdGFydENodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBwcmVhbWJsZVN0YXRlLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkLFxuICAgICAgaXNGYWxsYmFja1xuICAgICkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIGI6IGlmICgtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSkgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuICAgICAgIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJlxuICAgICAgICBwcm9wcy5jb250ZW50RWRpdGFibGUgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmXG4gICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUgJiZcbiAgICAgICAgLTEgPT09IHR5cGUuaW5kZXhPZihcIi1cIikgJiZcbiAgICAgICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImFcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBwcm9wVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImhyZWZcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihjaGlsZHJlbikpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBjaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsIFwiZGVmYXVsdFZhbHVlXCIpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITApKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic2VsZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMCwgY2hpbGRyZW4kanNjb21wJDApO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMDtcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvcHRpb25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDFdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiBzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgPT09IGlubmVySFRNTCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoc2VsZWN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sIFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZVtpXSA9PT0gc3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCBcInNlbGVjdC52YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZSA9PT0gc3RyaW5nVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZWN0ZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwkanNjb21wJDEsIGNoaWxkcmVuJGpzY29tcCQxKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDE7XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJ0ZXh0YXJlYVwiLCBwcm9wcyk7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQyO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMiBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQyKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQyID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMl07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDIpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IHZhbHVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBkZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZSRqc2NvbXAkMCA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4kanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIGlmICgxIDwgY2hpbGRyZW4kanNjb21wJDIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDJbMF0pO1xuICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IFwiXCIgKyBjaGlsZHJlbiRqc2NvbXAkMlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuJGpzY29tcCQyKTtcbiAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IHZhbHVlJGpzY29tcCQwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlJGpzY29tcCQwLCBcInZhbHVlXCIpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHZhbHVlJGpzY29tcCQwKSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgdmFsdWUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDMpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0IGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkM1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uIHx8XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBudWxsID09PSBjaGVja2VkIHx8XG4gICAgICAgICAgICBudWxsID09PSBkZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDEgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIG51bGwgIT09IGNoZWNrZWRcbiAgICAgICAgICAgID8gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgY2hlY2tlZClcbiAgICAgICAgICAgIDogbnVsbCAhPT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgZGVmYXVsdENoZWNrZWQpO1xuICAgICAgICAgIG51bGwgIT09IHZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICA/IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcInZhbHVlXCIsIHZhbHVlJGpzY29tcCQxKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0VmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgZGVmYXVsdFZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYnV0dG9uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDMgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDRdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDQpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBuYW1lJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1FbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1UYXJnZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEkanNjb21wJDAgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDAgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhJGpzY29tcCQwLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMiwgY2hpbGRyZW4kanNjb21wJDMpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDMpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gY2hpbGRyZW4kanNjb21wJDM7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiZm9ybVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ1O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ1KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ1ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ1XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24kanNjb21wJDEpIHtcbiAgICAgICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJiBudWxsID09PSBmb3JtTWV0aG9kJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICAgICAgPyAoKGZvcm1BY3Rpb24kanNjb21wJDEgPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIChmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgICAgICAoZm9ybU1ldGhvZCRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgICAgIChmb3JtVGFyZ2V0JGpzY29tcCQxID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAgICAgKGZvcm1EYXRhJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmRhdGEpLFxuICAgICAgICAgICAgICAgIChmb3JtQWN0aW9uTmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSlcbiAgICAgICAgICAgICAgOiAodGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFwiYWN0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCksXG4gICAgICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiYWN0aW9uXCIsIGZvcm1BY3Rpb24kanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImVuY1R5cGVcIiwgZm9ybUVuY1R5cGUkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibWV0aG9kXCIsIGZvcm1NZXRob2QkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybVRhcmdldCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidGFyZ2V0XCIsIGZvcm1UYXJnZXQkanNjb21wJDEpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1BY3Rpb25OYW1lICYmXG4gICAgICAgICAgICAodGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKSxcbiAgICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcIm5hbWVcIiwgZm9ybUFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKSxcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMywgY2hpbGRyZW4kanNjb21wJDQpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDQpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ0KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gY2hpbGRyZW4kanNjb21wJDQ7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjtcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm1lbnVpdGVtXCIpKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5JGpzY29tcCQ2IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDYpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDYgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ2XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwib2JqZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDc7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ3IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDcpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDcgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ3XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wVmFsdWUkanNjb21wJDcsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHByb3BWYWx1ZSRqc2NvbXAkNyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09PSBzYW5pdGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXCJkYXRhXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHNhbml0aXplZFZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkNCwgY2hpbGRyZW4kanNjb21wJDUpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDUpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ1KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gY2hpbGRyZW4kanNjb21wJDU7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgdmFyIGluc2VydGlvbk1vZGUgPSBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgICAgICBub3NjcmlwdFRhZ0luU2NvcGUgPSAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSk7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiY2hpbGRyZW5cIikpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDYpXG4gICAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ2WzBdXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ2O1xuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNikgJiYgMSA8IGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBBcnJheSB3aXRoIGxlbmd0aCAlcyBpbnN0ZWFkLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSBBcnJheXMgb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3Qgc3VwcG9ydGVkLiBXaGVuIHVzaW5nIEpTWCBpdCBjYW4gYmUgY29tbW9uIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkIHx8IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZFxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkID8gXCJhIEZ1bmN0aW9uXCIgOiBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChudWxsICE9IGNoaWxkLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPiBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgcmVsID0gcHJvcHMucmVsLFxuICAgICAgICAgICAgaHJlZiA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcykpKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1O1xuICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkVycm9yIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDYgPSBwdXNoU2NyaXB0SW1wbChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wcy5zcmM7XG4gICAgICAgICAgICBpZiAoXCJtb2R1bGVcIiA9PT0gcHJvcHMudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzO1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIChyZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMpLFxuICAgICAgICAgICAgICAgIChwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMpO1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUkanNjb21wJDAgPSByZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICA/IHJlc291cmNlc1trZXldXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDAgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgMiA9PT0gcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICgoc2NyaXB0UHJvcHMgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhzY3JpcHRQcm9wcywgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgPSBwcmVsb2Fkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAubGVuZ3RoID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlJGpzY29tcCQwID0gW107XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UkanNjb21wJDAsIHNjcmlwdFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDcgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQkanNjb21wJDAgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ3Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkN1swXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNztcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZCRqc2NvbXAkMCkpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEluIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICA/IFwiYSBGdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICA6IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICA/IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYW4gQXJyYXlcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZSRqc2NvbXAkMCA9IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmJGpzY29tcCQwID0gcHJvcHMuaHJlZjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWYkanNjb21wJDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4O1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ4IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ4ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOF07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ4KVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDhcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDgpXG4gICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDhbMF1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkODtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRDaHVua0ZvclRhZyhcInN0eWxlXCIpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmJGpzY29tcCQwLmluY2x1ZGVzKFwiIFwiKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdSZWFjdCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgZm9yIGEgPHN0eWxlPiB0YWcgb3B0aW5nIGludG8gaG9pc3Rpbmcgc2VtYW50aWNzIHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCB0byBub3QgaGF2ZSBhbnkgc3BhY2VzIGJ1dCBlY291bnRlcmVkIHNwYWNlcyBpbnN0ZWFkLiB1c2luZyBzcGFjZXMgaW4gdGhpcyBwcm9wIHdpbGwgY2F1c2UgaHlkcmF0aW9uIG9mIHRoaXMgc3R5bGUgdG8gZmFpbCBvbiB0aGUgY2xpZW50LiBUaGUgaHJlZiBmb3IgdGhlIDxzdHlsZT4gd2hlcmUgdGhpcyBvY3VycmVkIGlzIFwiJXNcIi4nLFxuICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBzdHlsZVF1ZXVlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UkanNjb21wJDApLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmJGpzY29tcCQwXVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIGhvaXN0YWJsZSBzdHlsZSB0YWcgZm9yIHRoZSBzYW1lIGhyZWYgYXMgYSBwcmVsb2FkOiBcIiVzXCIuIFdoZW4gdXNpbmcgYSBzdHlsZSB0YWcgdG8gaW5saW5lIHN0eWxlcyB5b3Ugc2hvdWxkIG5vdCBhbHNvIHByZWxvYWQgaXQgYXMgYSBzdHlsc2hlZXQuJyxcbiAgICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyBzdHlsZVF1ZXVlJGpzY29tcCQwLmhyZWZzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoKHN0eWxlUXVldWUkanNjb21wJDAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBocmVmczogW3N0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMCkpXSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHlsZVF1ZXVlJGpzY29tcCQwLnJ1bGVzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ5ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDYgPSBudWxsLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDk7XG4gICAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDkgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ5XTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gcHJvcFZhbHVlJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDIgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ5KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkOVswXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMiAmJlxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMikpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCRqc2NvbXAkNiwgY2hpbGRyZW4kanNjb21wJDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuYWRkKHN0eWxlUXVldWUkanNjb21wJDApO1xuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3O1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4ID0gaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoYXJTZXRcbiAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCBcIm1ldGFcIilcbiAgICAgICAgICAgICAgICAgIDogXCJ2aWV3cG9ydFwiID09PSBwcm9wcy5uYW1lXG4gICAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICAgIDogcHVzaFNlbGZDbG9zaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFcIlxuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDg7XG4gICAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDEwID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDEwKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDEwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEwID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ3ID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDEwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCRqc2NvbXAkNykge1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDEwKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbm5lckhUTUwkanNjb21wJDcgfHxcbiAgICAgICAgICAgICAgIShcIl9faHRtbFwiIGluIGlubmVySFRNTCRqc2NvbXAkNylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBpbm5lckhUTUwkanNjb21wJDcuX19odG1sO1xuICAgICAgICAgICAgbnVsbCAhPT0gaHRtbCAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBodG1sICYmIDAgPCBodG1sLmxlbmd0aCAmJiBcIlxcblwiID09PSBodG1sWzBdXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSwgc3RyaW5nVG9DaHVuayhodG1sKSlcbiAgICAgICAgICAgICAgICA6IChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0cmluZ1RvQ2h1bmsoXCJcIiArIGh0bWwpKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDEwICYmXG4gICAgICAgICAgICBcIlxcblwiID09PSBjaGlsZHJlbiRqc2NvbXAkMTBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDEwO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgdmFyIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgICAgICAgIHNyY1NldCA9IHByb3BzLnNyY1NldDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBcImxhenlcIiA9PT0gcHJvcHMubG9hZGluZyB8fFxuICAgICAgICAgICAgICAoIXNyYyAmJiAhc3JjU2V0KSB8fFxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyAmJiBudWxsICE9IHNyYykgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgJiYgbnVsbCAhPSBzcmNTZXQpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBcImxvd1wiICE9PSBwcm9wcy5mZXRjaFByaW9yaXR5ICYmXG4gICAgICAgICAgICAhMSA9PT0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDMpICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyB8fFxuICAgICAgICAgICAgICBcIjpcIiAhPT0gc3JjWzRdIHx8XG4gICAgICAgICAgICAgIChcImRcIiAhPT0gc3JjWzBdICYmIFwiRFwiICE9PSBzcmNbMF0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzFdICYmIFwiQVwiICE9PSBzcmNbMV0pIHx8XG4gICAgICAgICAgICAgIChcInRcIiAhPT0gc3JjWzJdICYmIFwiVFwiICE9PSBzcmNbMl0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzNdICYmIFwiQVwiICE9PSBzcmNbM10pKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1NldFs0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1NldFswXSAmJiBcIkRcIiAhPT0gc3JjU2V0WzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFsxXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1NldFsyXSAmJiBcIlRcIiAhPT0gc3JjU2V0WzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFszXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzNdKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzaXplcyA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5zaXplcyA/IHByb3BzLnNpemVzIDogdm9pZCAwLFxuICAgICAgICAgICAgICBrZXkkanNjb21wJDAgPSBzcmNTZXQgPyBzcmNTZXQgKyBcIlxcblwiICsgKHNpemVzIHx8IFwiXCIpIDogc3JjLFxuICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMsXG4gICAgICAgICAgICAgIHJlc291cmNlJGpzY29tcCQxID0gcHJvbW90YWJsZVByZWxvYWRzLmdldChrZXkkanNjb21wJDApO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlJGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLmRlbGV0ZShrZXkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICFyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkkanNjb21wJDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgIHZhciBpbnB1dCA9IHByb3BzLmNyb3NzT3JpZ2luO1xuICAgICAgICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBoZWFkZXI7XG4gICAgICAgICAgICAgIGhlYWRlcnMgJiZcbiAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyY1NldCAmJlxuICAgICAgICAgICAgICAoXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICA1MDAgPiBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgKChoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCBcImltYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldDogcHJvcHMuc3JjU2V0LFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXkkanNjb21wJDBdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChyZXNvdXJjZSRqc2NvbXAkMSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSRqc2NvbXAkMSwge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBzcmNTZXQgPyB2b2lkIDAgOiBzcmMsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBzcmNTZXQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXkkanNjb21wJDAsIHJlc291cmNlJGpzY29tcCQxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIFwiaW1nXCIpO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIHR5cGUpO1xuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgY2FzZSBcImNvbG9yLXByb2ZpbGVcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXVyaVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgY2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlLmhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8aGVhZD5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIHByZWFtYmxlLmhlYWRDaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDkgPSBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KFxuICAgICAgICAgICAgICBwcmVhbWJsZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDkgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOTtcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUkanNjb21wJDAgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8Ym9keT5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiYm9keVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImJvZHlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQxID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGh0bWw+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMSA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTEgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKC0xICE9PSB0eXBlLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTEgPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTEgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDExXTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTEgPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wVmFsdWUkanNjb21wJDExKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5JGpzY29tcCQxMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhMSAhPT0gcHJvcFZhbHVlJGpzY29tcCQxMVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDExID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIGNodW5rID0gZW5kVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICB2b2lkIDAgPT09IGNodW5rICYmXG4gICAgICAgICgoY2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L1wiICsgdGFnICsgXCI+XCIpKSxcbiAgICAgICAgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RQcmVhbWJsZVN0YXRlKHJlbmRlclN0YXRlLCBwcmVhbWJsZVN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuaHRtbENodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmh0bWxDaHVua3MgJiZcbiAgICAgICAgKChyZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gcHJlYW1ibGVTdGF0ZS5odG1sQ2h1bmtzKSxcbiAgICAgICAgKHByZWFtYmxlU3RhdGUuY29udHJpYnV0aW9uIHw9IDEpKTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlLmhlYWRDaHVua3MgJiZcbiAgICAgICAgcHJlYW1ibGVTdGF0ZS5oZWFkQ2h1bmtzICYmXG4gICAgICAgICgocmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyksXG4gICAgICAgIChwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbiB8PSA0KSk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5ib2R5Q2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICAoKHJlbmRlclN0YXRlLmJvZHlDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MpLFxuICAgICAgICAocHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb24gfD0gMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJTdGF0ZS5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlW2ldKTtcbiAgICAgIHJldHVybiBpIDwgcmVuZGVyU3RhdGUubGVuZ3RoXG4gICAgICAgID8gKChpID0gcmVuZGVyU3RhdGVbaV0pLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5sZW5ndGggPSAwKSxcbiAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBpKSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxKTtcbiAgICAgIGlmIChudWxsID09PSBpZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBbiBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBiZWZvcmUgd2UgY2FuIGNvbXBsZXRlIHRoZSBib3VuZGFyeS5cIlxuICAgICAgICApO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHByZWFtYmxlU3RhdGUpIHtcbiAgICAgIHByZWFtYmxlU3RhdGUgPSBwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbjtcbiAgICAgIHByZWFtYmxlU3RhdGUgIT09IE5vQ29udHJpYnV0aW9uICYmXG4gICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib3VuZGFyeVByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmtTdGFydCksXG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoXCJcIiArIHByZWFtYmxlU3RhdGUpKSxcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rRW5kKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dCwgaWQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IRUFEX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRyksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZVJvdyksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZVJvdzIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwMilcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICAgICAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICAgICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hFQURfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFNWRyk7XG4gICAgICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRNYXRoTUwpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlQm9keSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlUm93KTtcbiAgICAgICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyxcbiAgICAgICAgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSBcIiZcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDI2XCI7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2VcIjtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5KHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXMsXG4gICAgICAgIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcbiAgICAgIDAgPCBydWxlcy5sZW5ndGggJiZcbiAgICAgICAgMCA9PT0gaHJlZnMubGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCB0byBoYXZlIGF0IGxlYXN0IG9uZSBocmVmIGZvciBhbiBhIGhvaXN0YWJsZSBzdHlsZSBidXQgZm91bmQgbm9uZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcbiAgICAgICAgICBpIDwgaHJlZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpKytcbiAgICAgICAgKVxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pLCB3cml0ZUNodW5rKHRoaXMsIHNwYWNlU2VwYXJhdG9yKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tpXSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykgd3JpdGVDaHVuayh0aGlzLCBydWxlc1tpXSk7XG4gICAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB3cml0ZUNodW5rQW5kUmV0dXJuKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMDtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzU3R5bGVzVG9Ib2lzdChzdHlsZXNoZWV0KSB7XG4gICAgICByZXR1cm4gc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEVcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITApXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMTtcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSAhMDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ICYmXG4gICAgICAgIChyZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gITApO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHdyaXRlQ2h1bmsodGhpcywgcmVzb3VyY2VbaV0pO1xuICAgICAgcmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZUluUHJlYW1ibGUoc3R5bGVzaGVldCkge1xuICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBzdHlsZXNoZWV0LnByb3BzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVBTUJMRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZXNJblByZWFtYmxlKHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBoYXNTdHlsZXNoZWV0cyA9IDAgPCBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgICAgIHN0eWxlUXVldWUgPSAwO1xuICAgICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUgPCBocmVmcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tzdHlsZVF1ZXVlXSksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbc3R5bGVRdWV1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcbiAgICAgICAgZm9yIChzdHlsZVF1ZXVlID0gMDsgc3R5bGVRdWV1ZSA8IHJ1bGVzLmxlbmd0aDsgc3R5bGVRdWV1ZSsrKVxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbc3R5bGVRdWV1ZV0pO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VDbG9zZSk7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGUoc3R5bGVzaGVldCkge1xuICAgICAgaWYgKHN0eWxlc2hlZXQuc3RhdGUgPT09IFBFTkRJTkckMSkge1xuICAgICAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFTE9BREVEO1xuICAgICAgICB2YXIgcHJvcHMgPSBzdHlsZXNoZWV0LnByb3BzO1xuICAgICAgICBwdXNoTGlua0ltcGwoc3R5bGVzaGVldEZsdXNoaW5nUXVldWUsIHtcbiAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgIGFzOiBcInN0eWxlXCIsXG4gICAgICAgICAgaHJlZjogc3R5bGVzaGVldC5wcm9wcy5ocmVmLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpbixcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgIG1lZGlhOiBwcm9wcy5tZWRpYSxcbiAgICAgICAgICBocmVmTGFuZzogcHJvcHMuaHJlZkxhbmcsXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHN0eWxlc2hlZXQgPSAwO1xuICAgICAgICAgIHN0eWxlc2hlZXQgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgc3R5bGVzaGVldCsrXG4gICAgICAgIClcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW3N0eWxlc2hlZXRdKTtcbiAgICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZXMoc3R5bGVRdWV1ZSkge1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlLCB0aGlzKTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICAgICAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlICE9PSBQUkVBTUJMRSlcbiAgICAgICAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IExBVEUpXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IHJlc291cmNlLnByb3BzLmhyZWYpLFxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHJlc291cmNlLCBcImhyZWZcIiksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFwiXCIgKyByZXNvdXJjZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KSxcbiAgICAgICAgICAgICAgKG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSByZXNvdXJjZS5wcm9wc1tcImRhdGEtcHJlY2VkZW5jZVwiXSxcbiAgICAgICAgICAgICAgcHJvcHMgPSByZXNvdXJjZS5wcm9wcyxcbiAgICAgICAgICAgICAgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTChcIlwiICsgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCBcInByZWNlZGVuY2VcIik7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gXCJcIiArIHByZWNlZGVuY2U7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhwcmVjZWRlbmNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAoKHByZWNlZGVuY2UgPSBwcm9wc1twcm9wS2V5XSksIG51bGwgIT0gcHJlY2VkZW5jZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YS1wcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgICAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwiY2xhc3NcIjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgaWYgKCExID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoMiA8IG5hbWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgIChcIm9cIiA9PT0gbmFtZVswXSB8fCBcIk9cIiA9PT0gbmFtZVswXSkgJiZcbiAgICAgICAgICAgICAgKFwiblwiID09PSBuYW1lWzFdIHx8IFwiTlwiID09PSBuYW1lWzFdKSkgfHxcbiAgICAgICAgICAgICFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhuYW1lKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHsgc3R5bGVzOiBuZXcgU2V0KCksIHN0eWxlc2hlZXRzOiBuZXcgU2V0KCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGhyZWYsXG4gICAgICBwcm9wc1xuICAgICkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSB8fFxuICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IG9yIG1vZHVsZSB3aXRoIHNyYyBcIiVzXCIgdG8gbm90IGhhdmUgYmVlbiBwcmVsb2FkZWQgYWxyZWFkeS4gcGxlYXNlIGZpbGUgYW4gaXNzdWUnLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gW107XG4gICAgICBwdXNoTGlua0ltcGwocmVzdW1hYmxlU3RhdGUsIHByb3BzKTtcbiAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmNyb3NzT3JpZ2luICYmICh0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF0pO1xuICAgICAgbnVsbCA9PSB0YXJnZXQuaW50ZWdyaXR5ICYmICh0YXJnZXQuaW50ZWdyaXR5ID0gcHJlbG9hZFN0YXRlWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBwYXJhbXMpIHtcbiAgICAgIGhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gICAgICBhcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgXCJhc1wiKTtcbiAgICAgIGFzID0gXCI8XCIgKyBocmVmICsgJz47IHJlbD1wcmVsb2FkOyBhcz1cIicgKyBhcyArICdcIic7XG4gICAgICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKVxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcGFyYW1OYW1lKSAmJlxuICAgICAgICAgICgoaHJlZiA9IHBhcmFtc1twYXJhbU5hbWVdKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAgICAgKGFzICs9XG4gICAgICAgICAgICAgIFwiOyBcIiArXG4gICAgICAgICAgICAgIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICAgICAgJz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICdcIicpKTtcbiAgICAgIHJldHVybiBhcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWZJbnB1dCkge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmSW5wdXQsIFwiaHJlZlwiKTtcbiAgICAgIHJldHVybiAoXCJcIiArIGhyZWZJbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCxcbiAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNDXCI7XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNFXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlMEFcIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIiUwRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJlc2NhcGVMaW5rSHJlZkZvckhlYWRlckNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCh2YWx1ZSwgbmFtZSkge1xuICAgICAgd2lsbENvZXJjaW9uVGhyb3codmFsdWUpICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2Agb3B0aW9uIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkpO1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LFxuICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHJldHVybiBcIiUyMlwiO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIHJldHVybiBcIiUyN1wiO1xuICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgIHJldHVybiBcIiUzQlwiO1xuICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgIHJldHVybiBcIiUyQ1wiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgICAgIHRoaXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZXNoZWV0RGVwZW5kZW5jeShzdHlsZXNoZWV0KSB7XG4gICAgICB0aGlzLnN0eWxlc2hlZXRzLmFkZChzdHlsZXNoZWV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICAgICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICAgIGlmIChudWxsID09PSBwcmV2KSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHBhcmVudE5leHQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICAgICAgcHJldiA9IHByZXYucGFyZW50O1xuICAgICAgbnVsbCAhPT0gcHJldiAmJiBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHBhcmVudE5leHQgJiYgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gICAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzd2l0Y2hDb250ZXh0KG5ld1NuYXBzaG90KSB7XG4gICAgICB2YXIgcHJldiA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgICAgIHByZXYgIT09IG5ld1NuYXBzaG90ICYmXG4gICAgICAgIChudWxsID09PSBwcmV2XG4gICAgICAgICAgPyBwdXNoQWxsTmV4dChuZXdTbmFwc2hvdClcbiAgICAgICAgICA6IG51bGwgPT09IG5ld1NuYXBzaG90XG4gICAgICAgICAgICA/IHBvcEFsbFByZXZpb3VzKHByZXYpXG4gICAgICAgICAgICA6IHByZXYuZGVwdGggPT09IG5ld1NuYXBzaG90LmRlcHRoXG4gICAgICAgICAgICAgID8gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV3U25hcHNob3QpXG4gICAgICAgICAgICAgIDogcHJldi5kZXB0aCA+IG5ld1NuYXBzaG90LmRlcHRoXG4gICAgICAgICAgICAgICAgPyBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpXG4gICAgICAgICAgICAgICAgOiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXdTbmFwc2hvdCksXG4gICAgICAgIChjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdTbmFwc2hvdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmIChudWxsICE9PSBjYWxsYmFjayAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gU3RyaW5nKGNhbGxiYWNrKTtcbiAgICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpIHx8XG4gICAgICAgICAgKGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgICAgIHB1YmxpY0luc3RhbmNlID1cbiAgICAgICAgKChwdWJsaWNJbnN0YW5jZSA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwdWJsaWNJbnN0YW5jZSkpIHx8XG4gICAgICAgIFwiUmVhY3RDbGFzc1wiO1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBwdWJsaWNJbnN0YW5jZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gfHxcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiBUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LlwiLFxuICAgICAgICAgIGNhbGxlck5hbWUsXG4gICAgICAgICAgcHVibGljSW5zdGFuY2VcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUNvbnRleHQoYmFzZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSBiYXNlQ29udGV4dC5pZDtcbiAgICAgIGJhc2VDb250ZXh0ID0gYmFzZUNvbnRleHQub3ZlcmZsb3c7XG4gICAgICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICY9IH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gICAgICBpZiAoMzAgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIChiYXNlTGVuZ3RoICUgNSk7XG4gICAgICAgIGxlbmd0aCA9IChcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmXG4gICAgICAgICAgKCgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDEpXG4gICAgICAgICkudG9TdHJpbmcoMzIpO1xuICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCA+Pj0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIGJhc2VMZW5ndGggLT0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6XG4gICAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgICAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfFxuICAgICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQsXG4gICAgICAgICAgb3ZlcmZsb3c6IGxlbmd0aCArIGJhc2VDb250ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICBvdmVyZmxvdzogYmFzZUNvbnRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICAgICAgeCA+Pj49IDA7XG4gICAgICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2coeCkgLyBMTjIpIHwgMCkpIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQyKCkge31cbiAgICBmdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gdGhlbmFibGVTdGF0ZVtpbmRleF07XG4gICAgICB2b2lkIDAgPT09IGluZGV4XG4gICAgICAgID8gdGhlbmFibGVTdGF0ZS5wdXNoKHRoZW5hYmxlKVxuICAgICAgICA6IGluZGV4ICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICh0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKSwgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzXG4gICAgICAgICAgICA/IHRoZW5hYmxlLnRoZW4obm9vcCQyLCBub29wJDIpXG4gICAgICAgICAgICA6ICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgKHRoZW5hYmxlU3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIHtcbiAgICAgIGlmIChudWxsID09PSBzdXNwZW5kZWRUaGVuYWJsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgICApO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gICAgICBpZiAoMCA8IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiKTtcbiAgICAgIHJldHVybiB7IG1lbW9pemVkU3RhdGU6IG51bGwsIHF1ZXVlOiBudWxsLCBuZXh0OiBudWxsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICA/IG51bGwgPT09IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyAoKGlzUmVSZW5kZXIgPSAhMSksXG4gICAgICAgICAgICAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCkpKVxuICAgICAgICAgIDogKChpc1JlUmVuZGVyID0gITApLCAod29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2spKVxuICAgICAgICA6IG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9vay5uZXh0XG4gICAgICAgICAgPyAoKGlzUmVSZW5kZXIgPSAhMSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCkpKVxuICAgICAgICAgIDogKChpc1JlUmVuZGVyID0gITApLCAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgcmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIgJiYgKGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCIpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoaXNSZVJlbmRlcikge1xuICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgICAgICBpbml0aWFsQXJnID0gaW5pdC5kaXNwYXRjaDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlbmRlclBoYXNlVXBkYXRlcykge1xuICAgICAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChpbml0KTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKGluaXQpO1xuICAgICAgICAgICAgaW5pdCA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgICAgICAgICBpbml0ID0gcmVkdWNlcihpbml0LCBhY3Rpb24pO1xuICAgICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgICAgICAgICAgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgICAgICAgIH0gd2hpbGUgKG51bGwgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0O1xuICAgICAgICAgICAgcmV0dXJuIFtpbml0LCBpbml0aWFsQXJnXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgaW5pdGlhbEFyZ107XG4gICAgICB9XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMDtcbiAgICAgIHJlZHVjZXIgPVxuICAgICAgICByZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgICAgID8gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbEFyZ1xuICAgICAgICAgICAgPyBpbml0aWFsQXJnKClcbiAgICAgICAgICAgIDogaW5pdGlhbEFyZ1xuICAgICAgICAgIDogdm9pZCAwICE9PSBpbml0XG4gICAgICAgICAgICA/IGluaXQoaW5pdGlhbEFyZylcbiAgICAgICAgICAgIDogaW5pdGlhbEFyZztcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWR1Y2VyO1xuICAgICAgcmVkdWNlciA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHsgbGFzdDogbnVsbCwgZGlzcGF0Y2g6IG51bGwgfTtcbiAgICAgIHJlZHVjZXIgPSByZWR1Y2VyLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NIb29rKSB7XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHByZXZTdGF0ZSAmJiBudWxsICE9PSBkZXBzKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHByZXZTdGF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cIixcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZGVwcy5sZW5ndGggIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSBvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcblByZXZpb3VzOiAlc1xcbkluY29taW5nOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgICAgICAgICBcIltcIiArIGRlcHMuam9pbihcIiwgXCIpICsgXCJdXCIsXG4gICAgICAgICAgICAgICAgICBcIltcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5qb2luKFwiLCBcIikgKyBcIl1cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIGkgPCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQubGVuZ3RoICYmIGkgPCBkZXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZGVwc1tpXSwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgbmV4dENyZWF0ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dENyZWF0ZSwgZGVwc107XG4gICAgICByZXR1cm4gbmV4dENyZWF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGlmICgyNSA8PSBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICApO1xuICAgICAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMCksXG4gICAgICAgICAgKGNvbXBvbmVudElkZW50aXR5ID0geyBhY3Rpb246IGFjdGlvbiwgbmV4dDogbnVsbCB9KSxcbiAgICAgICAgICBudWxsID09PSByZW5kZXJQaGFzZVVwZGF0ZXMgJiYgKHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXAoKSksXG4gICAgICAgICAgKGFjdGlvbiA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpKSxcbiAgICAgICAgICB2b2lkIDAgPT09IGFjdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChxdWV1ZSA9IGFjdGlvbjsgbnVsbCAhPT0gcXVldWUubmV4dDsgKSBxdWV1ZSA9IHF1ZXVlLm5leHQ7XG4gICAgICAgICAgcXVldWUubmV4dCA9IGNvbXBvbmVudElkZW50aXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgdmFyIGFjdGlvblN0YXRlSG9va0luZGV4ID0gYWN0aW9uU3RhdGVDb3VudGVyKyssXG4gICAgICAgIHJlcXVlc3QgPSBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0O1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbi4kJEZPUk1fQUNUSU9OKSB7XG4gICAgICAgIHZhciBuZXh0UG9zdGJhY2tTdGF0ZUtleSA9IG51bGwsXG4gICAgICAgICAgY29tcG9uZW50S2V5UGF0aCA9IGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGg7XG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmZvcm1TdGF0ZTtcbiAgICAgICAgdmFyIGlzU2lnbmF0dXJlRXF1YWwgPSBhY3Rpb24uJCRJU19TSUdOQVRVUkVfRVFVQUw7XG4gICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0ICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGlzU2lnbmF0dXJlRXF1YWwpIHtcbiAgICAgICAgICB2YXIgcG9zdGJhY2tLZXkgPSByZXF1ZXN0WzFdO1xuICAgICAgICAgIGlzU2lnbmF0dXJlRXF1YWwuY2FsbChhY3Rpb24sIHJlcXVlc3RbMl0sIHJlcXVlc3RbM10pICYmXG4gICAgICAgICAgICAoKG5leHRQb3N0YmFja1N0YXRlS2V5ID1cbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgOiBcImtcIiArXG4gICAgICAgICAgICAgICAgICBtdXJtdXJoYXNoM18zMl9nYyhcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwb3N0YmFja0tleSA9PT0gbmV4dFBvc3RiYWNrU3RhdGVLZXkgJiZcbiAgICAgICAgICAgICAgKChhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSBhY3Rpb25TdGF0ZUhvb2tJbmRleCksXG4gICAgICAgICAgICAgIChpbml0aWFsU3RhdGUgPSByZXF1ZXN0WzBdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib3VuZEFjdGlvbiA9IGFjdGlvbi5iaW5kKG51bGwsIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04gJiZcbiAgICAgICAgICAoYWN0aW9uLiQkRk9STV9BQ1RJT04gPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgICAgICBwcmVmaXggPSBib3VuZEFjdGlvbi4kJEZPUk1fQUNUSU9OKHByZWZpeCk7XG4gICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGluayAmJlxuICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwZXJtYWxpbmssIFwidGFyZ2V0XCIpLFxuICAgICAgICAgICAgICAocGVybWFsaW5rICs9IFwiXCIpLFxuICAgICAgICAgICAgICAocHJlZml4LmFjdGlvbiA9IHBlcm1hbGluaykpO1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHJlZml4LmRhdGE7XG4gICAgICAgICAgICBmb3JtRGF0YSAmJlxuICAgICAgICAgICAgICAobnVsbCA9PT0gbmV4dFBvc3RiYWNrU3RhdGVLZXkgJiZcbiAgICAgICAgICAgICAgICAobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICAgICAgPyBcInBcIiArIHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBtdXJtdXJoYXNoM18zMl9nYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVIb29rSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCIkQUNUSU9OX0tFWVwiLCBuZXh0UG9zdGJhY2tTdGF0ZUtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGUsIGFjdGlvbiwgITFdO1xuICAgICAgfVxuICAgICAgdmFyIF9ib3VuZEFjdGlvbiA9IGFjdGlvbi5iaW5kKG51bGwsIGluaXRpYWxTdGF0ZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgX2JvdW5kQWN0aW9uKHBheWxvYWQpO1xuICAgICAgICB9LFxuICAgICAgICAhMVxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBbXSk7XG4gICAgICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRSZWZyZXNoKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDYWNoZSBjYW5ub3QgYmUgcmVmcmVzaGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE93bmVyU3RhY2soZXJyb3IpIHtcbiAgICAgIHZhciBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgZXJyb3IgPSBlcnJvci5zdGFjaztcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgZXJyb3Iuc3RhcnRzV2l0aChcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcXG5cIikgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UoMjkpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChlcnJvciA9IGVycm9yLnNsaWNlKHByZXZQcmVwYXJlU3RhY2tUcmFjZSArIDEpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBlcnJvci5sYXN0SW5kZXhPZihcbiAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZVxuICAgICAgICApKTtcbiAgICAgIGlmICgtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlKVxuICAgICAgICBlcnJvciA9IGVycm9yLnNsaWNlKDAsIHByZXZQcmVwYXJlU3RhY2tUcmFjZSk7XG4gICAgICBlbHNlIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XG4gICAgICAgICAgPyBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICEwKVxuICAgICAgICAgIDogZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMSk7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgITEpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS50eXBlLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGUsXG4gICAgICAgICAgICAgIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0eXBlID0gbGF6eUNvbXBvbmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZS5uYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocGF5bG9hZCA9IHR5cGUuZW52KSxcbiAgICAgICAgICAgIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICB0eXBlLm5hbWUgKyAocGF5bG9hZCA/IFwiIFtcIiArIHBheWxvYWQgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICApIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGVycm9yLmVudmlyb25tZW50TmFtZTtcbiAgICAgICAgZXJyb3IgPSBbZXJyb3JdLnNsaWNlKDApO1xuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3JbMF1cbiAgICAgICAgICA/IGVycm9yLnNwbGljZShcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgXCIlYyVzJWMgXCIgKyBlcnJvclswXSxcbiAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgICAgICAgICAgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIixcbiAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBcIiVjJXMlYyBcIixcbiAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgICAgICAgICAgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIixcbiAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZXJyb3IudW5zaGlmdChjb25zb2xlKTtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gYmluZC5hcHBseShjb25zb2xlLmVycm9yLCBlcnJvcik7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCgpO1xuICAgICAgfSBlbHNlIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIFJlcXVlc3RJbnN0YW5jZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uQWxsUmVhZHksXG4gICAgICBvblNoZWxsUmVhZHksXG4gICAgICBvblNoZWxsRXJyb3IsXG4gICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICBvblBvc3Rwb25lLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuZmx1c2hTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHRoaXMucmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZTtcbiAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICAgIHRoaXMucm9vdEZvcm1hdENvbnRleHQgPSByb290Rm9ybWF0Q29udGV4dDtcbiAgICAgIHRoaXMucHJvZ3Jlc3NpdmVDaHVua1NpemUgPVxuICAgICAgICB2b2lkIDAgPT09IHByb2dyZXNzaXZlQ2h1bmtTaXplID8gMTI4MDAgOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZTtcbiAgICAgIHRoaXMuc3RhdHVzID0gMTA7XG4gICAgICB0aGlzLmZhdGFsRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nUm9vdFRhc2tzID0gdGhpcy5hbGxQZW5kaW5nVGFza3MgPSB0aGlzLm5leHRTZWdtZW50SWQgPSAwO1xuICAgICAgdGhpcy5jb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzID0gdGhpcy5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0YWJsZVRhc2tzID0gYWJvcnRTZXQ7XG4gICAgICB0aGlzLnBpbmdlZFRhc2tzID0gW107XG4gICAgICB0aGlzLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5jb21wbGV0ZWRCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnBhcnRpYWxCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnRyYWNrZWRQb3N0cG9uZXMgPSBudWxsO1xuICAgICAgdGhpcy5vbkVycm9yID0gdm9pZCAwID09PSBvbkVycm9yID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IG9uRXJyb3I7XG4gICAgICB0aGlzLm9uUG9zdHBvbmUgPSB2b2lkIDAgPT09IG9uUG9zdHBvbmUgPyBub29wIDogb25Qb3N0cG9uZTtcbiAgICAgIHRoaXMub25BbGxSZWFkeSA9IHZvaWQgMCA9PT0gb25BbGxSZWFkeSA/IG5vb3AgOiBvbkFsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uU2hlbGxSZWFkeSA/IG5vb3AgOiBvblNoZWxsUmVhZHk7XG4gICAgICB0aGlzLm9uU2hlbGxFcnJvciA9IHZvaWQgMCA9PT0gb25TaGVsbEVycm9yID8gbm9vcCA6IG9uU2hlbGxFcnJvcjtcbiAgICAgIHRoaXMub25GYXRhbEVycm9yID0gdm9pZCAwID09PSBvbkZhdGFsRXJyb3IgPyBub29wIDogb25GYXRhbEVycm9yO1xuICAgICAgdGhpcy5mb3JtU3RhdGUgPSB2b2lkIDAgPT09IGZvcm1TdGF0ZSA/IG51bGwgOiBmb3JtU3RhdGU7XG4gICAgICB0aGlzLmRpZFdhcm5Gb3JLZXkgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxuICAgICAgY2hpbGRyZW4sXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdmFyIG5vdyA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAxZTMgPCBub3cgLSBsYXN0UmVzZXRUaW1lICYmXG4gICAgICAgICgoUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MgPSAwKSxcbiAgICAgICAgKGxhc3RSZXNldFRpbWUgPSBub3cpKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgIG9uUG9zdHBvbmUsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgITEsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC0xLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICAhMSxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcHVzaENvbXBvbmVudFN0YWNrKGNoaWxkcmVuKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnBpbmdlZFRhc2tzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIHJlc3VtYWJsZVN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJSZXF1ZXN0KFxuICAgICAgY2hpbGRyZW4sXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZVxuICAgICkge1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgIG9uUG9zdHBvbmUsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGNoaWxkcmVuLnRyYWNrZWRQb3N0cG9uZXMgPSB7XG4gICAgICAgIHdvcmtpbmdNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgcm9vdE5vZGVzOiBbXSxcbiAgICAgICAgcm9vdFNsb3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAxID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1c1xuICAgICAgICAgID8gc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICBjb250ZW50UHJlYW1ibGUsXG4gICAgICBmYWxsYmFja1ByZWFtYmxlXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgICAgIGJ5dGVTaXplOiAwLFxuICAgICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzOiBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgICAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICAgICAgY29udGVudFN0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBmYWxsYmFja1N0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBjb250ZW50UHJlYW1ibGU6IGNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZTogZmFsbGJhY2tQcmVhbWJsZSxcbiAgICAgICAgdHJhY2tlZENvbnRlbnRLZXlQYXRoOiBudWxsLFxuICAgICAgICB0cmFja2VkRmFsbGJhY2tOb2RlOiBudWxsLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgICAgIGVycm9yU3RhY2s6IG51bGwsXG4gICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2s6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgYmxvY2tlZFNlZ21lbnQsXG4gICAgICBibG9ja2VkUHJlYW1ibGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiBudWxsLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IGJsb2NrZWRTZWdtZW50LFxuICAgICAgICBibG9ja2VkUHJlYW1ibGU6IGJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICBpc0ZhbGxiYWNrOiBpc0ZhbGxiYWNrXG4gICAgICB9O1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBkZWJ1Z1Rhc2s7XG4gICAgICBhYm9ydFNldC5hZGQodGFzayk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgcmVwbGF5LFxuICAgICAgbm9kZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBibG9ja2VkQm91bmRhcnksXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICByZXBsYXkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiByZXBsYXksXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeTogYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBibG9ja2VkU2VnbWVudDogbnVsbCxcbiAgICAgICAgYmxvY2tlZFByZWFtYmxlOiBudWxsLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIGFib3J0U2V0OiBhYm9ydFNldCxcbiAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIGlzRmFsbGJhY2s6IGlzRmFsbGJhY2tcbiAgICAgIH07XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IGRlYnVnVGFzaztcbiAgICAgIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgIGxhc3RQdXNoZWRUZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHBhcmVudEZsdXNoZWQ6ICExLFxuICAgICAgICBpZDogLTEsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBwcmVhbWJsZUNoaWxkcmVuOiBbXSxcbiAgICAgICAgcGFyZW50Rm9ybWF0Q29udGV4dDogcGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgICAgIHRleHRFbWJlZGRlZDogdGV4dEVtYmVkZGVkXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50VGFza0luREVWIHx8IG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjb21wb25lbnRTdGFjay50eXBlKVxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoY29tcG9uZW50U3RhY2sudHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudFN0YWNrLnR5cGUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBvbmVudFN0YWNrLm93bmVyKSB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gaW5mbyxcbiAgICAgICAgICAgICAgZm4gPSBjb21wb25lbnRTdGFjay50eXBlLFxuICAgICAgICAgICAgICBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBuYW1lXG4gICAgICAgICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSlcbiAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaW5mbyA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbXBvbmVudFN0YWNrLm93bmVyIHx8XG4gICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKGNvbXBvbmVudFN0YWNrLnR5cGUpKTtcbiAgICAgICAgZm9yICg7IGNvbXBvbmVudFN0YWNrOyApXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPSBjb21wb25lbnRTdGFjay5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGZvcm1hdE93bmVyU3RhY2soXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGFjay5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiAoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICAgICAgICBudWxsICE9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjayAmJlxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2sgPSBmb3JtYXRPd25lclN0YWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2spKSxcbiAgICAgICAgICAgIChjb21wb25lbnRTdGFjayA9IGNvbXBvbmVudFN0YWNrLm93bmVyKSAmJlxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QgJiZcbiAgICAgICAgICAgICAgKGluZm8gKz0gXCJcXG5cIiArIEpTQ29tcGlsZXJfdGVtcF9jb25zdCk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50SW5mbyA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY29tcG9uZW50SW5mby5uYW1lICYmXG4gICAgICAgICAgICB2b2lkIDAgIT09IGNvbXBvbmVudEluZm8uZGVidWdTdGFjayAmJlxuICAgICAgICAgICAgKCh0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGNvbXBvbmVudEluZm8sXG4gICAgICAgICAgICAgIG93bmVyOiBjb21wb25lbnRJbmZvLm93bmVyLFxuICAgICAgICAgICAgICBzdGFjazogY29tcG9uZW50SW5mby5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICh0YXNrLmRlYnVnVGFzayA9IGNvbXBvbmVudEluZm8uZGVidWdUYXNrKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaENvbXBvbmVudFN0YWNrKHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlO1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyID0gbm9kZS5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrID0gbm9kZS5fZGVidWdTdGFjaztcbiAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBub2RlLl9kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IHN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4gJiZcbiAgICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGhyb3duSW5mbyhub2RlJGpzY29tcCQwKSB7XG4gICAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgICBub2RlJGpzY29tcCQwICYmXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckluZm8sIFwiY29tcG9uZW50U3RhY2tcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUkanNjb21wJDA7XG4gICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZShub2RlLnR5cGUpKSxcbiAgICAgICAgICAgICAgICAgIChub2RlID0gbm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICB3aGlsZSAobm9kZSk7XG4gICAgICAgICAgICAgIHZhciBzdGFjayA9IGluZm87XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIHN0YWNrID0gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBzdGFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBlcnJvckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICBib3VuZGFyeSxcbiAgICAgIGRpZ2VzdCxcbiAgICAgIGVycm9yLFxuICAgICAgdGhyb3duSW5mbyxcbiAgICAgIHdhc0Fib3J0ZWRcbiAgICApIHtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZGlnZXN0O1xuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/ICgoZGlnZXN0ID0gU3RyaW5nKGVycm9yLm1lc3NhZ2UpKSwgKGVycm9yID0gU3RyaW5nKGVycm9yLnN0YWNrKSkpXG4gICAgICAgIDogKChkaWdlc3QgPVxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmIG51bGwgIT09IGVycm9yXG4gICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoZXJyb3IpXG4gICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSksXG4gICAgICAgICAgKGVycm9yID0gbnVsbCkpO1xuICAgICAgd2FzQWJvcnRlZCA9IHdhc0Fib3J0ZWRcbiAgICAgICAgPyBcIlN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmluZyBhYm9ydGVkIGR1ZSB0bzpcXG5cXG5cIlxuICAgICAgICA6IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGVycm9yZWQ6XFxuXFxuXCI7XG4gICAgICBib3VuZGFyeS5lcnJvck1lc3NhZ2UgPSB3YXNBYm9ydGVkICsgZGlnZXN0O1xuICAgICAgYm91bmRhcnkuZXJyb3JTdGFjayA9IG51bGwgIT09IGVycm9yID8gd2FzQWJvcnRlZCArIGVycm9yIDogbnVsbDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2sgPSB0aHJvd25JbmZvLmNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIGRlYnVnVGFzaykge1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25FcnJvcjtcbiAgICAgIGVycm9yID0gZGVidWdUYXNrXG4gICAgICAgID8gZGVidWdUYXNrLnJ1bihyZXF1ZXN0LmJpbmQobnVsbCwgZXJyb3IsIGVycm9ySW5mbykpXG4gICAgICAgIDogcmVxdWVzdChlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgIGlmIChudWxsICE9IGVycm9yICYmIFwic3RyaW5nXCIgIT09IHR5cGVvZiBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnb25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcInN0cmluZ1wiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcIiVzXCIgaW5zdGVhZCcsXG4gICAgICAgICAgdHlwZW9mIGVycm9yXG4gICAgICAgICk7XG4gICAgICBlbHNlIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIGVycm9ySW5mbyA9IHJlcXVlc3Qub25TaGVsbEVycm9yO1xuICAgICAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICAgICAgZGVidWdUYXNrXG4gICAgICAgID8gKGRlYnVnVGFzay5ydW4oZXJyb3JJbmZvLmJpbmQobnVsbCwgZXJyb3IpKSxcbiAgICAgICAgICBkZWJ1Z1Rhc2sucnVuKG9uRmF0YWxFcnJvci5iaW5kKG51bGwsIGVycm9yKSkpXG4gICAgICAgIDogKGVycm9ySW5mbyhlcnJvciksIG9uRmF0YWxFcnJvcihlcnJvcikpO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgICA/ICgocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLFxuICAgICAgICAgIGNsb3NlV2l0aEVycm9yKHJlcXVlc3QuZGVzdGluYXRpb24sIGVycm9yKSlcbiAgICAgICAgOiAoKHJlcXVlc3Quc3RhdHVzID0gMTMpLCAocmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VGhlbmFibGVTdGF0ZSA9IHRhc2sudGhlbmFibGVTdGF0ZTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSB7fTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG4gICAgICBmb3IgKFxuICAgICAgICByZXF1ZXN0ID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIClcbiAgICAgICAgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSksXG4gICAgICAgICAgKGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMCksXG4gICAgICAgICAgKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xKSxcbiAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAobnVtYmVyT2ZSZVJlbmRlcnMgKz0gMSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBoYXNJZCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICApIHtcbiAgICAgIHZhciBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITE7XG4gICAgICBpZiAoMCAhPT0gYWN0aW9uU3RhdGVDb3VudCAmJiBudWxsICE9PSByZXF1ZXN0LmZvcm1TdGF0ZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICEwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvblN0YXRlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGkgPT09IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICA/IHNlZ21lbnQucHVzaChmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nKVxuICAgICAgICAgICAgICA6IHNlZ21lbnQucHVzaChmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IHRhc2sua2V5UGF0aDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBoYXNJZFxuICAgICAgICA/ICgoa2V5UGF0aCA9IHRhc2sudHJlZUNvbnRleHQpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KGtleVBhdGgsIDEsIDApKSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBrZXlQYXRoKSlcbiAgICAgICAgOiBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzXG4gICAgICAgICAgPyByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSlcbiAgICAgICAgICA6IHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgdGFzay5rZXlQYXRoID0gYWN0aW9uU3RhdGVDb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID09PSBwcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAodm9pZCAwID09PSBjb250ZXh0VHlwZSB8fFxuICAgICAgICAgICAgICBjb250ZXh0VHlwZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBjb250ZXh0VHlwZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgICA6IGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIn0uXCI7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAoY29udGV4dCA9IGNvbnRleHRUeXBlLl9jdXJyZW50VmFsdWUpO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0eXBlKHJlc29sdmVkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgfHwgdm9pZCAwID09PSBpbnN0YW5jZS5zdGF0ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsTW91bnROYW1lID0gXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsTW91bnROYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgICAgID8gXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4lcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXNcIixcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAgICh0eXBlLnByb3RvdHlwZSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImdldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIERpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyh0eXBlKSAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdHlwZS5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyBUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgdm9pZCAwICE9PSBpbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgICAgaGFzTXV0YXRlZFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyh0eXBlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgIHN0YXRlICYmXG4gICAgICAgICAgICAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0YXRlIHx8IGlzQXJyYXlJbXBsKHN0YXRlKSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgbmFtZSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdm9pZCAwICE9PSBpbnN0YW5jZS5zdGF0ZSA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZWRQcm9wcztcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHsgcXVldWU6IFtdLCByZXBsYWNlOiAhMSB9O1xuICAgICAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFscyA9IGludGVybmFsSW5zdGFuY2U7XG4gICAgICAgICAgdmFyIGNvbnRleHRUeXBlJGpzY29tcCQwID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUkanNjb21wJDBcbiAgICAgICAgICAgICAgPyBjb250ZXh0VHlwZSRqc2NvbXAkMC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gcmVzb2x2ZWRQcm9wcykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgICAgIGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSRqc2NvbXAkMSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDFcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgIDogYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB8fFxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMiA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSB8fFxuICAgICAgICAgICAgICAgICAgKGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSBvciB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSA9XG4gICAgICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICYmXG4gICAgICAgICAgICAgIDAgPCBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWUsXG4gICAgICAgICAgICAgICAgb2xkUmVwbGFjZSA9IGludGVybmFsSW5zdGFuY2UucmVwbGFjZTtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9ICExO1xuICAgICAgICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiAxID09PSBvbGRRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9ICEwLFxuICAgICAgICAgICAgICAgICAgICBpID0gb2xkUmVwbGFjZSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgaSA8IG9sZFF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnRpYWwuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRvbnRNdXRhdGVcbiAgICAgICAgICAgICAgICAgICAgICA/ICgoZG9udE11dGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBhc3NpZ24obmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUkanNjb21wJDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGNhbGxSZW5kZXJJbkRFVihpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyAhPT0gcmVzb2x2ZWRQcm9wcyAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITApKTtcbiAgICAgICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV4dENoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDMgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lJGpzY29tcCQzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIHZhciBoYXNJZCA9IDAgIT09IGxvY2FsSWRDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IGFjdGlvblN0YXRlQ291bnRlcixcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMCA9IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleDtcbiAgICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gfHxcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbX2NvbXBvbmVudE5hbWUkanNjb21wJDBdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgJiZcbiAgICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZTJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUuY29udGV4dFR5cGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPVxuICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBoYXNJZCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXgkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBwcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQwID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgICAgICAgIHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgdGFzay5pc0ZhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgICAgdmFyIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIF9wcmV2S2V5UGF0aDIgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAodGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBfcHJldkNvbnRleHQsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApKS5pbnNlcnRpb25Nb2RlID09PSBIVE1MX0hFQURfTU9ERVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlU2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlZ21lbnQucHJlYW1ibGVDaGlsZHJlbi5wdXNoKHByZWFtYmxlU2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGVUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgX2NoaWxkcmVuLFxuICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgIHByZWFtYmxlU2VnbWVudCxcbiAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHRhc2suaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhwcmVhbWJsZVRhc2spO1xuICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHByZWFtYmxlVGFzayk7XG4gICAgICAgICAgfSBlbHNlIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gX3ByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDI7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNCb2R5ID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Lmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDEgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgICBpZiAoXCJoaWRkZW5cIiAhPT0gcHJvcHMubW9kZSkge1xuICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDIgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHZhciBfcHJldktleVBhdGgzID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoMztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgYTogaWYgKG51bGwgIT09IHRhc2sucmVwbGF5KSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBfY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NvbnRlbnQsIC0xKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMyA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHBhcmVudFByZWFtYmxlID0gdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50SG9pc3RhYmxlU3RhdGUgPSB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gcHJvcHMuZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIHZhciBuZXdCb3VuZGFyeSA9XG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREVcbiAgICAgICAgICAgICAgICAgID8gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZWFtYmxlU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgICAgICAgICAobmV3Qm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoID0ga2V5UGF0aCk7XG4gICAgICAgICAgICAgIHZhciBib3VuZGFyeVNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5jaGlsZHJlbi5wdXNoKGJvdW5kYXJ5U2VnbWVudCk7XG4gICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnRSb290U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrS2V5UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgXCJTdXNwZW5zZSBGYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzJdXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlID0gW1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGhbMV0sXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsyXSxcbiAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS50cmFja2VkRmFsbGJhY2tOb2RlID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBib3VuZGFyeVNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgPSBuZXdCb3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGZhbGxiYWNrS2V5UGF0aDtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBmYWxsYmFjaywgLTEpLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQudGV4dEVtYmVkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LmNodW5rcy5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICAoYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gMTIgPT09IHJlcXVlc3Quc3RhdHVzID8gMyA6IDQpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IHBhcmVudFByZWFtYmxlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZFByaW1hcnlUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50UHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgICAgICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRQcmltYXJ5VGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IG5ld0JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlID0gbmV3Qm91bmRhcnkuY29udGVudFByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnRleHRFbWJlZGRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQobmV3Qm91bmRhcnksIGNvbnRlbnRSb290U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IG5ld0JvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORylcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQ7XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDIpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHJlcXVlc3QuZmF0YWxFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAoY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDQpLCAoZXJyb3IgPSB0aHJvd25WYWx1ZSQyKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIG5ld0JvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnkpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkUHJlYW1ibGUgPSBwYXJlbnRQcmVhbWJsZSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHBhcmVudFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuZmFsbGJhY2tQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmZhbGxiYWNrU3RhdGUsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGlmIChcInJlZlwiIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICAgIFwicmVmXCIgIT09IGtleSAmJiAocHJvcHNXaXRob3V0UmVmW2tleV0gPSBwcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IHByb3BzO1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgdHlwZS5yZW5kZXIsXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRob3V0UmVmLFxuICAgICAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAwICE9PSBsb2NhbElkQ291bnRlcixcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUudHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMSA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90ID0gdGFzay5jb250ZXh0O1xuICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDQgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSB0eXBlLl9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IG51bGwgPT09IHByZXZOb2RlID8gMCA6IHByZXZOb2RlLmRlcHRoICsgMSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHR5cGUsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuJGpzY29tcCQxLCAtMSk7XG4gICAgICAgICAgICAgIHZhciBwcmV2U25hcHNob3QkanNjb21wJDAgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBwcmV2U25hcHNob3QkanNjb21wJDApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRyaWVkIHRvIHBvcCBhIENvbnRleHQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5jb250ZXh0ICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIHBhcmVudCBjb250ZXh0IGlzIG5vdCB0aGUgZXhwZWN0ZWQgY29udGV4dC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPVxuICAgICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5wYXJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50KTtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICB2YXIgY29udGV4dCRqc2NvbXAkMCA9IHR5cGUuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlbmRlciAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKGNvbnRleHQkanNjb21wJDAuX2N1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgICAgICAgcHJldktleVBhdGgkanNjb21wJDUgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXdDaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBjYWxsTGF6eUluaXRJbkRFVih0eXBlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBDb21wb25lbnQsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGluZm8gKz1cbiAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICgobnVsbCA9PSB0eXBlID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCBzZWdtZW50SWQsIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2UmVwbGF5ID0gdGFzay5yZXBsYXksXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICByZXN1bWVkU2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAhMSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgcmVzdW1lZFNlZ21lbnQuaWQgPSBzZWdtZW50SWQ7XG4gICAgICByZXN1bWVkU2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICB0cnkge1xuICAgICAgICAodGFzay5yZXBsYXkgPSBudWxsKSxcbiAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHJlc3VtZWRTZWdtZW50KSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpLFxuICAgICAgICAgIChyZXN1bWVkU2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgIG51bGwgPT09IGJsb2NrZWRCb3VuZGFyeVxuICAgICAgICAgICAgPyAocmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHJlc3VtZWRTZWdtZW50KVxuICAgICAgICAgICAgOiAocXVldWVDb21wbGV0ZWRTZWdtZW50KGJsb2NrZWRCb3VuZGFyeSwgcmVzdW1lZFNlZ21lbnQpLFxuICAgICAgICAgICAgICBibG9ja2VkQm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChibG9ja2VkQm91bmRhcnkpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICh0YXNrLnJlcGxheSA9IHByZXZSZXBsYXkpLCAodGFzay5ibG9ja2VkU2VnbWVudCA9IG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlFbGVtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgbmFtZSxcbiAgICAgIGtleU9ySW5kZXgsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgcmVwbGF5XG4gICAgKSB7XG4gICAgICBjaGlsZEluZGV4ID0gcmVwbGF5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGRJbmRleFtpXTtcbiAgICAgICAgaWYgKGtleU9ySW5kZXggPT09IG5vZGVbMV0pIHtcbiAgICAgICAgICBpZiAoNCA9PT0gbm9kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBuYW1lICYmIG5hbWUgIT09IG5vZGVbMF0pXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPFwiICtcbiAgICAgICAgICAgICAgICAgIG5vZGVbMF0gK1xuICAgICAgICAgICAgICAgICAgXCI+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8XCIgK1xuICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVbMl07XG4gICAgICAgICAgICBub2RlID0gbm9kZVszXTtcbiAgICAgICAgICAgIG5hbWUgPSB0YXNrLm5vZGU7XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IGNoaWxkTm9kZXMsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDEgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlbilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93ICh0YXNrLm5vZGUgPT09IG5hbWUgJiYgKHRhc2sucmVwbGF5ID0gcmVwbGF5KSwgeCk7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICB0eXBlID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgcHJvcHMgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gICAgICAgICAgICAgIGtleVBhdGggPSB4O1xuICAgICAgICAgICAgICByZWYgPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbG9nUmVjb3ZlcmFibGVFcnJvcihwcm9wcywga2V5UGF0aCwgdHlwZSwgdGFzay5kZWJ1Z1Rhc2spO1xuICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8U3VzcGVuc2U+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8XCIgK1xuICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgXCI+LiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICByZXBsYXkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHR5cGUgPSBub2RlWzVdO1xuICAgICAgICAgICAgICByZWYgPSBub2RlWzJdO1xuICAgICAgICAgICAgICBuYW1lID0gbm9kZVszXTtcbiAgICAgICAgICAgICAga2V5T3JJbmRleCA9IG51bGwgPT09IG5vZGVbNF0gPyBbXSA6IG5vZGVbNF1bMl07XG4gICAgICAgICAgICAgIG5vZGUgPSBudWxsID09PSBub2RlWzRdID8gbnVsbCA6IG5vZGVbNF1bM107XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5LFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50SG9pc3RhYmxlU3RhdGUgPSB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIHByb3BzID1cbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByb3BzLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgcHJvcHMucm9vdFNlZ21lbnRJRCA9IHR5cGU7XG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcHJvcHM7XG4gICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBwcm9wcy5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogcmVmLCBzbG90czogbmFtZSwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcHJvcHMucGVuZGluZ1Rhc2tzICYmIHByb3BzLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKHByb3BzLnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAgICAgICAoY2hpbGROb2RlcyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjaykpLFxuICAgICAgICAgICAgICAgICAgKHJlcGxheSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KHByb3BzLCByZXBsYXksIGVycm9yLCBjaGlsZE5vZGVzLCAhMSksXG4gICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldmlvdXNSZXBsYXlTZXQpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wcyA9IGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHsgbm9kZXM6IGtleU9ySW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDAgfSxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayxcbiAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwcm9wcy5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgITAsXG4gICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhwcm9wcyk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkSW5kZXguc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJiBcIm51bWJlclwiID09PSB0eXBlb2YgdGFzay5yZXBsYXkuc2xvdHNcbiAgICAgICAgPyByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHRhc2sucmVwbGF5LnNsb3RzLCBub2RlLCBjaGlsZEluZGV4KVxuICAgICAgICA6ICgodGFzay5ub2RlID0gbm9kZSksXG4gICAgICAgICAgKHRhc2suY2hpbGRJbmRleCA9IGNoaWxkSW5kZXgpLFxuICAgICAgICAgIChub2RlID0gdGFzay5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgKGNoaWxkSW5kZXggPSB0YXNrLmRlYnVnVGFzayksXG4gICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHRhc2spLFxuICAgICAgICAgIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSxcbiAgICAgICAgICAodGFzay5jb21wb25lbnRTdGFjayA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmRlYnVnVGFzayA9IGNoaWxkSW5kZXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlOb2RlKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlLFxuICAgICAgICBjaGlsZEluZGV4ID0gdGFzay5jaGlsZEluZGV4O1xuICAgICAgaWYgKG51bGwgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlKSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAga2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgcmVmUHJvcCA9IG5vZGUucmVmO1xuICAgICAgICAgICAgICByZWZQcm9wID0gdm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBkZWJ1Z1Rhc2sgPSB0YXNrLmRlYnVnVGFzayxcbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgICAgICBrZXkgPSBudWxsID09IGtleSA/ICgtMSA9PT0gY2hpbGRJbmRleCA/IDAgOiBjaGlsZEluZGV4KSA6IGtleTtcbiAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBuYW1lLCBrZXldO1xuICAgICAgICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgID8gZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5RWxlbWVudC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVwbGF5RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlByb3BcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBub2RlLCByZWZQcm9wKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIG5vZGUgPSBjYWxsTGF6eUluaXRJbkRFVihub2RlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSkge1xuICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCA9PT0gbm9kZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAoa2V5ID0gbnVsbClcbiAgICAgICAgICAgIDogKCh0eXBlID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChrZXkgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlID8gdHlwZSA6IG51bGwpKTtcbiAgICAgICAgICBpZiAoa2V5ICYmICh0eXBlID0ga2V5LmNhbGwobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLTEgIT09IGNoaWxkSW5kZXggfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSB0YXNrLmNvbXBvbmVudFN0YWNrIHx8XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdGFzay5jb21wb25lbnRTdGFjay50eXBlIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhc2suY29tcG9uZW50U3RhY2sudHlwZSkgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgfHxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVXNpbmcgSXRlcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCB1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiBZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBZb3UgY2FuIGFsc28gdXNlIGFuIEl0ZXJhYmxlIHRoYXQgY2FuIGl0ZXJhdGUgbXVsdGlwbGUgdGltZXMgb3ZlciB0aGUgc2FtZSBpdGVtcy5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITApO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG5vZGUuZW50cmllcyAhPT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKTtcbiAgICAgICAgICAgIG5vZGUgPSB0eXBlLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghbm9kZS5kb25lKSB7XG4gICAgICAgICAgICAgIGtleSA9IFtdO1xuICAgICAgICAgICAgICBkbyBrZXkucHVzaChub2RlLnZhbHVlKSwgKG5vZGUgPSB0eXBlLm5leHQoKSk7XG4gICAgICAgICAgICAgIHdoaWxlICghbm9kZS5kb25lKTtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBrZXksIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5vZGUpLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgbm9kZS5fY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlcXVlc3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gcmVxdWVzdFxuICAgICAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKG5vZGUpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICAgICAgOiByZXF1ZXN0KSArXG4gICAgICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgID8gKCh0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICBudWxsICE9PSB0YXNrICYmXG4gICAgICAgICAgICAgICh0YXNrLmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB0YXNrLmNodW5rcyxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgdGFzay5sYXN0UHVzaGVkVGV4dFxuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiBub2RlIHx8IFwiYmlnaW50XCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/ICgodGFzayA9IHRhc2suYmxvY2tlZFNlZ21lbnQpLFxuICAgICAgICAgICAgICBudWxsICE9PSB0YXNrICYmXG4gICAgICAgICAgICAgICAgKHRhc2subGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgdGFzay5jaHVua3MsXG4gICAgICAgICAgICAgICAgICBcIlwiICsgbm9kZSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgICB0YXNrLmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgICAgICAgKChyZXF1ZXN0ID0gbm9kZS5kaXNwbGF5TmFtZSB8fCBub2RlLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlwiLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gICVzXCIsXG4gICAgICAgICAgICAgICAgICBTdHJpbmcobm9kZSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrO1xuICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIHRhc2subm9kZS5fZGVidWdJbmZvKTtcbiAgICAgIGlmIChcbiAgICAgICAgLTEgIT09IGNoaWxkSW5kZXggJiZcbiAgICAgICAgKCh0YXNrLmtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBcIkZyYWdtZW50XCIsIGNoaWxkSW5kZXhdKSxcbiAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcmVwbGF5ID0gdGFzay5yZXBsYXksIHJlcGxheU5vZGVzID0gcmVwbGF5Lm5vZGVzLCBqID0gMDtcbiAgICAgICAgICBqIDwgcmVwbGF5Tm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGorK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHJlcGxheU5vZGVzW2pdO1xuICAgICAgICAgIGlmIChub2RlWzFdID09PSBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZEluZGV4ID0gbm9kZVsyXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlWzNdO1xuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7IG5vZGVzOiBjaGlsZEluZGV4LCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlbilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IHg7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IHgsXG4gICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMgPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICAgIHJlcGxheU5vZGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcGxheSA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICByZXBsYXlOb2RlcyA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkgJiZcbiAgICAgICAgKChqID0gdGFzay5yZXBsYXkuc2xvdHMpLCBudWxsICE9PSBqICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiBqKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCByZXBsYXlOb2RlczsgY2hpbGRJbmRleCsrKVxuICAgICAgICAgIChub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF0pLFxuICAgICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQoXG4gICAgICAgICAgICAgIHJlcGxheSxcbiAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGVycm9yID0galtjaGlsZEluZGV4XSksXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZXJyb3JcbiAgICAgICAgICAgICAgPyAocmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCBlcnJvciwgbm9kZSwgY2hpbGRJbmRleCksXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpbY2hpbGRJbmRleF0pXG4gICAgICAgICAgICAgIDogcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHJlcGxheTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVwbGF5Tm9kZXM7IGorKykge1xuICAgICAgICBjaGlsZEluZGV4ID0gY2hpbGRyZW5bal07XG4gICAgICAgIHJlc3VtZVNsb3RzID0gcmVxdWVzdDtcbiAgICAgICAgbm9kZSA9IHRhc2s7XG4gICAgICAgIGVycm9yID0gY2hpbGRJbmRleDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgKGVycm9yLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgfHxcbiAgICAgICAgICAgIGVycm9yLiQkdHlwZW9mID09PSBSRUFDVF9QT1JUQUxfVFlQRSkgJiZcbiAgICAgICAgICBlcnJvci5fc3RvcmUgJiZcbiAgICAgICAgICAoKCFlcnJvci5fc3RvcmUudmFsaWRhdGVkICYmIG51bGwgPT0gZXJyb3Iua2V5KSB8fFxuICAgICAgICAgICAgMiA9PT0gZXJyb3IuX3N0b3JlLnZhbGlkYXRlZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBlcnJvci5fc3RvcmUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZXJyb3IuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgICAgdGhyb3duSW5mbyA9IHJlc3VtZVNsb3RzLmRpZFdhcm5Gb3JLZXk7XG4gICAgICAgICAgbnVsbCA9PSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAodGhyb3duSW5mbyA9IHJlc3VtZVNsb3RzLmRpZFdhcm5Gb3JLZXkgPSBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgICByZXN1bWVTbG90cyA9IG5vZGUuY29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHJlc3VtZVNsb3RzICYmICF0aHJvd25JbmZvLmhhcyhyZXN1bWVTbG90cykpIHtcbiAgICAgICAgICAgIHRocm93bkluZm8uYWRkKHJlc3VtZVNsb3RzKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVycm9yLnR5cGUpO1xuICAgICAgICAgICAgdGhyb3duSW5mbyA9IGVycm9yLl9vd25lcjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRPd25lciA9IHJlc3VtZVNsb3RzLm93bmVyO1xuICAgICAgICAgICAgcmVzdW1lU2xvdHMgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHBhcmVudE93bmVyICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwYXJlbnRPd25lci50eXBlKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudE93bmVyLnR5cGUpO1xuICAgICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICAgICAgKHJlc3VtZVNsb3RzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgbmFtZSArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bWVTbG90cyB8fFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgIChyZXN1bWVTbG90cyA9XG4gICAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT0gdGhyb3duSW5mbyAmJlxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAhPT0gdGhyb3duSW5mbyAmJlxuICAgICAgICAgICAgICAoKHBhcmVudE93bmVyID0gbnVsbCksXG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aHJvd25JbmZvLnR5cGVcbiAgICAgICAgICAgICAgICA/IChwYXJlbnRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aHJvd25JbmZvLnR5cGUpKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRocm93bkluZm8ubmFtZSAmJlxuICAgICAgICAgICAgICAgICAgKHBhcmVudE93bmVyID0gdGhyb3duSW5mby5uYW1lKSxcbiAgICAgICAgICAgICAgcGFyZW50T3duZXIgJiZcbiAgICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHBhcmVudE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgICAgIHRocm93bkluZm8gPSBub2RlLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBub2RlLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiBlcnJvci50eXBlLFxuICAgICAgICAgICAgICBvd25lcjogZXJyb3IuX293bmVyLFxuICAgICAgICAgICAgICBzdGFjazogZXJyb3IuX2RlYnVnU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgIHJlc3VtZVNsb3RzLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IHRocm93bkluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocmVwbGF5LCByZXBsYXlOb2Rlcywgaik7XG4gICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRJbmRleCwgaik7XG4gICAgICB9XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSkge1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcztcbiAgICAgIG51bGwgIT09IHJlcXVlc3QgJiZcbiAgICAgICAgKChib3VuZGFyeSA9IGJvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCksXG4gICAgICAgIG51bGwgIT09IGJvdW5kYXJ5ICYmXG4gICAgICAgICAgKChib3VuZGFyeSA9IHJlcXVlc3Qud29ya2luZ01hcC5nZXQoYm91bmRhcnkpKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGJvdW5kYXJ5ICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5Lmxlbmd0aCA9IDQpLCAoYm91bmRhcnlbMl0gPSBbXSksIChib3VuZGFyeVszXSA9IG51bGwpKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2sucmVwbGF5LFxuICAgICAgICB0YXNrLm5vZGUsXG4gICAgICAgIHRhc2suY2hpbGRJbmRleCxcbiAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRhc2suaXNGYWxsYmFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIHRhc2ssIHRoZW5hYmxlU3RhdGUpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgbmV3U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgc2VnbWVudC5jaHVua3MubGVuZ3RoLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXdTZWdtZW50KTtcbiAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgIHJldHVybiBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgICB0YXNrLm5vZGUsXG4gICAgICAgIHRhc2suY2hpbGRJbmRleCxcbiAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIG5ld1NlZ21lbnQsXG4gICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0YXNrLmlzRmFsbGJhY2ssXG4gICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZpb3VzRm9ybWF0Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJldmlvdXNDb250ZXh0ID0gdGFzay5jb250ZXh0LFxuICAgICAgICBwcmV2aW91c0tleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgIHByZXZpb3VzVHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgcHJldmlvdXNEZWJ1Z1Rhc2sgPSB0YXNrLmRlYnVnVGFzayxcbiAgICAgICAgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gc2VnbWVudClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChyZXNldEhvb2tzU3RhdGUoKSxcbiAgICAgICAgICAgIChub2RlID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZSksXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICkucGluZztcbiAgICAgICAgICAgICAgbm9kZS50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiA9PT0gbm9kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIG5vZGUgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2socmVxdWVzdCwgdGFzaywgbm9kZSk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlc2V0SG9va3NTdGF0ZSgpLFxuICAgICAgICAgICAgKHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGgpLFxuICAgICAgICAgICAgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9IGNodW5rTGVuZ3RoKSxcbiAgICAgICAgICAgIChub2RlID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUkMyA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlJDMpLFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgICApLnBpbmc7XG4gICAgICAgICAgICAgIG5vZGUudGhlbihyZXF1ZXN0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgPT09IG5vZGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICBub2RlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICBub2RlID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgIHRocm93IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0VGFza1NvZnQodGFzaykge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gICAgICB0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIG51bGwgIT09IHRhc2sgJiYgKCh0YXNrLnN0YXR1cyA9IDMpLCBmaW5pc2hlZFRhc2sodGhpcywgYm91bmRhcnksIHRhc2spKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIG5vZGVzLFxuICAgICAgc2xvdHMsXG4gICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgYWJvcnRlZFxuICAgICkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoNCA9PT0gbm9kZS5sZW5ndGgpXG4gICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIG5vZGVbMl0sXG4gICAgICAgICAgICBub2RlWzNdLFxuICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIGFib3J0ZWRcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgbm9kZSA9IG5vZGVbNV07XG4gICAgICAgICAgdmFyIGVycm9yID0gZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvID0gZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgd2FzQWJvcnRlZCA9IGFib3J0ZWQsXG4gICAgICAgICAgICByZXN1bWVkQm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBuZXcgU2V0KCksXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IG5vZGU7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgIHdhc0Fib3J0ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHJlc3VtZWRCb3VuZGFyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAobnVsbCAhPT0gc2xvdHMpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJXZSBzaG91bGQgbm90IGhhdmUgYW55IHJlc3VtYWJsZSBub2RlcyBpbiB0aGUgc2hlbGwuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBib3VuZGFyeS5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICgoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgYWJvcnRlZFxuICAgICAgICAgICksXG4gICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSkpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNsb3RzKVxuICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIHNsb3RzKSBkZWxldGUgc2xvdHNbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgIGlmICg2ID09PSBzZWdtZW50LnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBzZWdtZW50LnN0YXR1cyA9IDM7XG4gICAgICB9XG4gICAgICBzZWdtZW50ID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAoMTMgIT09IHJlcXVlc3Quc3RhdHVzICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgICAgICBib3VuZGFyeSA9IHRhc2sucmVwbGF5O1xuICAgICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgc2VnbWVudCwgbnVsbCk7XG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAwIDwgYm91bmRhcnkubm9kZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAoKHRhc2sgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKSksXG4gICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBib3VuZGFyeS5ub2RlcyxcbiAgICAgICAgICAgICAgYm91bmRhcnkuc2xvdHMsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICBib3VuZGFyeS5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICAgKChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgKHRhc2sgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKSksXG4gICAgICAgICAgICAoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoYm91bmRhcnksIHRhc2ssIGVycm9yLCBzZWdtZW50LCAhMCksXG4gICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpLFxuICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSksXG4gICAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uIChmYWxsYmFja1Rhc2spIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydFRhc2soZmFsbGJhY2tUYXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCBzaGVsbENvbXBsZXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgIG9uSGVhZGVycyA9IHJlbmRlclN0YXRlLm9uSGVhZGVycztcbiAgICAgICAgaWYgKG9uSGVhZGVycykge1xuICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGVhZGVycyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbGlua0hlYWRlciA9IGhlYWRlcnMucHJlY29ubmVjdHM7XG4gICAgICAgICAgICBoZWFkZXJzLmZvbnRQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAobGlua0hlYWRlciAmJiAobGlua0hlYWRlciArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXJzLmZvbnRQcmVsb2FkcykpO1xuICAgICAgICAgICAgaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAobGlua0hlYWRlciAmJiAobGlua0hlYWRlciArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzKSk7XG4gICAgICAgICAgICBpZiAoIXNoZWxsQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXVlSXRlciA9IHJlbmRlclN0YXRlLnN0eWxlcy52YWx1ZXMoKSxcbiAgICAgICAgICAgICAgICBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICBiOiBmb3IgKFxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJiAhcXVldWVTdGVwLmRvbmU7XG4gICAgICAgICAgICAgICAgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHZhciBzaGVldEl0ZXIgPSBxdWV1ZVN0ZXAudmFsdWUuc2hlZXRzLnZhbHVlcygpLFxuICAgICAgICAgICAgICAgICAgICBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiYgIXNoZWV0U3RlcC5kb25lO1xuICAgICAgICAgICAgICAgICAgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNoZWV0ID0gc2hlZXRTdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IHNoZWV0LnByb3BzLFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyRqc2NvbXAkMCA9IHNoZWV0LnByb3BzO1xuICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMkanNjb21wJDAuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHByb3BzJGpzY29tcCQwLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMkanNjb21wJDAuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiBwcm9wcyRqc2NvbXAkMC5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcyRqc2NvbXAkMC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzJGpzY29tcCQwLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzJGpzY29tcCQwLnJlZmVycmVyUG9saWN5LFxuICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiBwcm9wcyRqc2NvbXAkMC5tZWRpYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUucmVzZXRzLnN0eWxlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUucmVzZXRzLnN0eWxlW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNyb3NzT3JpZ2luIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gW3Byb3BzLmNyb3NzT3JpZ2luLCBwcm9wcy5pbnRlZ3JpdHldXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogUFJFTE9BRF9OT19DUkVEUyk7XG4gICAgICAgICAgICAgICAgICBlbHNlIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua0hlYWRlciA/IG9uSGVhZGVycyh7IExpbms6IGxpbmtIZWFkZXIgfSkgOiBvbkhlYWRlcnMoe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwge30sIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpIHtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJiBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCAhMCk7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiYgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpO1xuICAgICAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25TaGVsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFsbChyZXF1ZXN0KSB7XG4gICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCB8fFxuICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyAhPT0gUE9TVFBPTkVEXG4gICAgICApO1xuICAgICAgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICAgIHJlcXVlc3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHNlZ21lbnQuY2h1bmtzLmxlbmd0aCAmJlxuICAgICAgICAxID09PSBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICBudWxsID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ICYmXG4gICAgICAgIC0xID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmlkXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgICAgIGNoaWxkU2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgIGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgY2hpbGRTZWdtZW50KTtcbiAgICAgIH0gZWxzZSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZXJlIGNhbiBvbmx5IGJlIG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG4gICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzXG4gICAgICAgICAgICAgID8gKGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORyAmJiAoYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgICAoYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRhc2tTb2Z0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBib3VuZGFyeS5jb250ZW50UHJlYW1ibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpKSlcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpLFxuICAgICAgICAgICAgICAgIDEgPT09IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSkpO1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29yayhyZXF1ZXN0JGpzY29tcCQyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QkanNjb21wJDIuc3RhdHVzICE9PSBDTE9TRUQgJiZcbiAgICAgICAgMTMgIT09IHJlcXVlc3QkanNjb21wJDIuc3RhdHVzXG4gICAgICApIHtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZSZXF1ZXN0ID0gY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMjtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdCRqc2NvbXAkMi5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0JGpzY29tcCQyLnBpbmdlZFRhc2tzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMixcbiAgICAgICAgICAgICAgdGFzayA9IHBpbmdlZFRhc2tzW2ldLFxuICAgICAgICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VGFza0luREVWID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gdGFzaztcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocmVxdWVzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJlcXVlc3QucmVwbGF5LnNsb3RzXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdW1lTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkuc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogcmV0cnlOb2RlKHJlcXVlc3QkanNjb21wJDAsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAxID09PSByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA8IHJlcXVlc3QucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluZyA9IHJlcXVlc3QucGluZztcbiAgICAgICAgICAgICAgICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QuY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEgPSByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMTIgPT09IHJlcXVlc3QkanNjb21wJDAuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdCRqc2NvbXAkMC5mYXRhbEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogeCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAgPSBlcnJvckluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMgPSByZXF1ZXN0LnJlcGxheS5ub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bWVTbG90cyA9IHJlcXVlc3QucmVwbGF5LnNsb3RzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGxheU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAoKHJlcXVlc3QkanNjb21wJDAgPSBwcmV2VGFza0luREVWID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgKGVycm9yRGlnZXN0ID0gdGFzayksXG4gICAgICAgICAgICAgIChyZXF1ZXN0JGpzY29tcCQxID0gc2VnbWVudCksXG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID09PSBQRU5ESU5HKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChlcnJvckRpZ2VzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBlcnJvckRpZ2VzdDtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gcmVxdWVzdCRqc2NvbXAkMS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2h1bmtMZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0cnlOb2RlKHJlcXVlc3QsIGVycm9yRGlnZXN0KSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS50ZXh0RW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICAgICAgICAocmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgeCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgIDogMTIgPT09IHJlcXVlc3Quc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0LmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4JGpzY29tcCQwLnRoZW5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcGluZyRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LnBpbmc7XG4gICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLnRoZW4ocGluZyRqc2NvbXAkMCwgcGluZyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8kanNjb21wJDEgPSBnZXRUaHJvd25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IDQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayA9IGVycm9yRGlnZXN0LmRlYnVnVGFzaztcbiAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgID8gZmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IChib3VuZGFyeSRqc2NvbXAkMC5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QkanNjb21wJDIuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChwaW5nZWRUYXNrcyA9IHt9KSxcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcHJldlJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCksXG4gICAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9PT0gSG9va3NEaXNwYXRjaGVyICYmIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMucHVzaChzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4pO1xuICAgICAgZm9yICh2YXIgcGVuZGluZ1ByZWFtYmxlcyA9ICExLCBpID0gMDsgaSA8IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHBlbmRpbmdQcmVhbWJsZXMgPVxuICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSB8fCBwZW5kaW5nUHJlYW1ibGVzO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcmVhbWJsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcmVhbWJsZSA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZSA9IGJvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICBpZiAobnVsbCA9PT0gcHJlYW1ibGUgfHwgbnVsbCA9PT0gZmFsbGJhY2tQcmVhbWJsZSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoIChib3VuZGFyeS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgaG9pc3RQcmVhbWJsZVN0YXRlKHJlcXVlc3QucmVuZGVyU3RhdGUsIHByZWFtYmxlKTtcbiAgICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgICAgICAgaWYgKCFzZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBDTElFTlRfUkVOREVSRUQ6XG4gICAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBob2lzdFByZWFtYmxlU3RhdGUocmVxdWVzdC5yZW5kZXJTdGF0ZSwgZmFsbGJhY2tQcmVhbWJsZSksXG4gICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkge1xuICAgICAgaWYgKFxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICYmXG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgKSB7XG4gICAgICAgIHZhciBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzID0gW10sXG4gICAgICAgICAgaGFzUGVuZGluZ1ByZWFtYmxlcyA9IHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwcmVhbWJsZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhMSA9PT0gaGFzUGVuZGluZ1ByZWFtYmxlcyB8fFxuICAgICAgICAgIChwcmVhbWJsZS5oZWFkQ2h1bmtzICYmIHByZWFtYmxlLmJvZHlDaHVua3MpXG4gICAgICAgIClcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBQRU5ESU5HOlxuICAgICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChob2lzdGFibGVTdGF0ZSA9IHNlZ21lbnQuaWQpLFxuICAgICAgICAgICAgKHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMSksXG4gICAgICAgICAgICAoc2VnbWVudC50ZXh0RW1iZWRkZWQgPSAhMSksXG4gICAgICAgICAgICAocmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIxKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QucGxhY2Vob2xkZXJQcmVmaXgpLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSBzdHJpbmdUb0NodW5rKGhvaXN0YWJsZVN0YXRlLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdCksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBGTFVTSEVEO1xuICAgICAgICAgIHZhciByID0gITAsXG4gICAgICAgICAgICBjaHVua3MgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgIGNodW5rSWR4ID0gMDtcbiAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZElkeCA9IDA7IGNoaWxkSWR4IDwgc2VnbWVudC5sZW5ndGg7IGNoaWxkSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAociA9IHNlZ21lbnRbY2hpbGRJZHhdOyBjaHVua0lkeCA8IHIuaW5kZXg7IGNodW5rSWR4KyspXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgICAgciA9IGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgciwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoIC0gMTsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHIgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKSk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgcmV0dXJuIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICBlcnJvclN0YWNrID0gYm91bmRhcnkuZXJyb3JTdGFjayxcbiAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuICAgICAgICBlcnJvckRpZ2VzdCAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICBlcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UpKVxuICAgICAgICAgICksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgKSk7XG4gICAgICAgIGVycm9yU3RhY2sgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvclN0YWNrKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrICYmXG4gICAgICAgICAgKHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUQpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICApKTtcbiAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyKTtcbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgIChyZXF1ZXN0ID0gYm91bmRhcnkuZmFsbGJhY2tQcmVhbWJsZSkgJiZcbiAgICAgICAgICB3cml0ZVByZWFtYmxlQ29udHJpYnV0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgfVxuICAgICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ09NUExFVEVEKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORyAmJlxuICAgICAgICAgICAgKGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKyksXG4gICAgICAgICAgMCA8IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgKSxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgKChib3VuZGFyeSA9IGJvdW5kYXJ5LmZhbGxiYWNrU3RhdGUpLFxuICAgICAgICAgICAgYm91bmRhcnkuc3R5bGVzLmZvckVhY2goaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSwgaG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgYm91bmRhcnkuc3R5bGVzaGVldHMuZm9yRWFjaChcbiAgICAgICAgICAgICAgaG9pc3RTdHlsZXNoZWV0RGVwZW5kZW5jeSxcbiAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBpZiAoYm91bmRhcnkuYnl0ZVNpemUgPiByZXF1ZXN0LnByb2dyZXNzaXZlQ2h1bmtTaXplKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KVxuICAgICAgICApO1xuICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgKChzZWdtZW50ID0gYm91bmRhcnkuY29udGVudFN0YXRlKSxcbiAgICAgICAgc2VnbWVudC5zdHlsZXMuZm9yRWFjaChob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgIHNlZ21lbnQuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBob2lzdGFibGVTdGF0ZSkpO1xuICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgIGlmICgxICE9PSBzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudFswXSwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgKHJlcXVlc3QgPSBib3VuZGFyeS5jb250ZW50UHJlYW1ibGUpICYmXG4gICAgICAgIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBzZWdtZW50LFxuICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICApIHtcbiAgICAgIHdyaXRlU3RhcnRTZWdtZW50KFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgICBzZWdtZW50LmlkXG4gICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICByZXR1cm4gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMsIGkgPSAwO1xuICAgICAgICBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgIClcbiAgICAgICAgZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgY29tcGxldGVkU2VnbWVudHNbaV1cbiAgICAgICAgKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZVxuICAgICAgKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZTtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgaSA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG4gICAgICBib3VuZGFyeSA9IGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZTtcbiAgICAgIHZhciByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uID0gcmVxdWVzdC5zdHlsZXNUb0hvaXN0O1xuICAgICAgcmVxdWVzdC5zdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09XG4gICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zID1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHxcbiAgICAgICAgICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfFxuICAgICAgICAgICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoKSlcbiAgICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbikgPT09XG4gICAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbFxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKVxuICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBzdHJpbmdUb0NodW5rKGkudG9TdHJpbmcoMTYpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlZFNlZ21lbnRzKTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhKSxcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeSkpXG4gICAgICAgIDogd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QpICYmIGJvdW5kYXJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHNlZ21lbnRcbiAgICApIHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gRkxVU0hFRCkgcmV0dXJuICEwO1xuICAgICAgdmFyIGhvaXN0YWJsZVN0YXRlID0gYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICBzZWdtZW50SUQgPSBzZWdtZW50LmlkO1xuICAgICAgaWYgKC0xID09PSBzZWdtZW50SUQpIHtcbiAgICAgICAgaWYgKC0xID09PSAoc2VnbWVudC5pZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRJRCA9PT0gYm91bmRhcnkucm9vdFNlZ21lbnRJRClcbiAgICAgICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIChib3VuZGFyeS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudFxuICAgICAgICA/ICgoYm91bmRhcnkuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiksXG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpKVxuICAgICAgICA6IHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3Quc2VnbWVudFByZWZpeCk7XG4gICAgICBzZWdtZW50SUQgPSBzdHJpbmdUb0NodW5rKHNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc2VnbWVudElEKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5wbGFjZWhvbGRlclByZWZpeCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzZWdtZW50SUQpO1xuICAgICAgZGVzdGluYXRpb24gPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoISgwIDwgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRSb290U2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBwcmVhbWJsZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlLFxuICAgICAgICAgICAgICBodG1sQ2h1bmtzID0gcHJlYW1ibGUuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyA9IHByZWFtYmxlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIGkkanNjb21wJDA7XG4gICAgICAgICAgICBpZiAoaHRtbENodW5rcykge1xuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaHRtbENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBodG1sQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydENodW5rRm9yVGFnKFwiaGVhZFwiKSksXG4gICAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZENodW5rcylcbiAgICAgICAgICAgICAgZm9yIChpJGpzY29tcCQwID0gMDsgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoOyBpJGpzY29tcCQwKyspXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2YXIgY2hhcnNldENodW5rcyA9IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGNoYXJzZXRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2hhcnNldENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MgPSByZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgdmlld3BvcnRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgdmlld3BvcnRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgdmlld3BvcnRDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLmZvckVhY2goZmx1c2hTdHlsZXNJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICB2YXIgaW1wb3J0TWFwQ2h1bmtzID0gcmVuZGVyU3RhdGUuaW1wb3J0TWFwQ2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBpbXBvcnRNYXBDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaW1wb3J0TWFwQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSBob2lzdGFibGVDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUgPCBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHNbcmVuZGVyU3RhdGVdO1xuICAgICAgICAgICAgICBmb3IgKHByZWFtYmxlID0gMDsgcHJlYW1ibGUgPCBzZWdtZW50cy5sZW5ndGg7IHByZWFtYmxlKyspXG4gICAgICAgICAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50c1twcmVhbWJsZV0sIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQwID0gcmVxdWVzdC5yZW5kZXJTdGF0ZS5wcmVhbWJsZSxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyRqc2NvbXAkMCA9IHByZWFtYmxlJGpzY29tcCQwLmhlYWRDaHVua3M7XG4gICAgICAgICAgICAocHJlYW1ibGUkanNjb21wJDAuaHRtbENodW5rcyB8fCBoZWFkQ2h1bmtzJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZyhcImhlYWRcIikpO1xuICAgICAgICAgICAgdmFyIGJvZHlDaHVua3MgPSBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzO1xuICAgICAgICAgICAgaWYgKGJvZHlDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IDA7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA8IGJvZHlDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm9keUNodW5rc1tjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXSk7XG4gICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMC52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwW2NvbXBsZXRlZFJvb3RTZWdtZW50XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGggPSAwO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnByZWNvbm5lY3RzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goXG4gICAgICAgICAgICBmbHVzaFJlc291cmNlLFxuICAgICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc3R5bGVzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnNjcmlwdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuYnVsa1ByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgdmFyIGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMCA9IHJlbmRlclN0YXRlJGpzY29tcCQwLmhvaXN0YWJsZUNodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXNbaV07XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBpZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gYm91bmRhcnkuZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgZXJyb3JTdGFjayA9IGJvdW5kYXJ5LmVycm9yU3RhY2ssXG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnN0YXJ0SW5saW5lU2NyaXB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgICAgICA/ICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMCwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpKVxuICAgICAgICAgICAgICA6IHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDAsIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5ib3VuZGFyeVByZWZpeFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDAsIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKHJlbmRlclN0YXRlJGpzY29tcCQwLCBjbGllbnRSZW5kZXJTY3JpcHQxQSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICBlcnJvclN0YWNrIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvclN0YWNrIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgJiZcbiAgICAgICAgICAgICAgKHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXNbaV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgICAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgICAgICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgYm91bmRhcnkgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5JGpzY29tcCQwID0gcGFydGlhbEJvdW5kYXJpZXNbaV0sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeSRqc2NvbXAkMC5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW0pTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrO1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucmVuZGVyU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbGFyZ2VCb3VuZGFyaWVzW2ldKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGggJiZcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aFxuICAgICAgICAgID8gKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITEpLFxuICAgICAgICAgICAgKGkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGkuaGFzQm9keSAmJiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZyhcImJvZHlcIikpLFxuICAgICAgICAgICAgaS5oYXNIdG1sICYmIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKFwiaHRtbFwiKSksXG4gICAgICAgICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pLFxuICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jbG9zZSgpLFxuICAgICAgICAgICAgKHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsKSlcbiAgICAgICAgICA6IGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgICAxMCA9PT0gcmVxdWVzdC5zdGF0dXMgJiYgKHJlcXVlc3Quc3RhdHVzID0gMTEpO1xuICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVGbHVzaChyZXF1ZXN0KSB7XG4gICAgICAhMSA9PT0gcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSByZXF1ZXN0LmRlc3RpbmF0aW9uO1xuICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICA/IGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgOiAocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pIHtcbiAgICAgIGlmICgxMyA9PT0gcmVxdWVzdC5zdGF0dXMpXG4gICAgICAgIChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksXG4gICAgICAgICAgY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEICYmIG51bGwgPT09IHJlcXVlc3QuZGVzdGluYXRpb24pIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAoZGVzdGluYXRpb24gPSB7fSksXG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCksXG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICBpZiAoMTEgPT09IHJlcXVlc3Quc3RhdHVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1cykgcmVxdWVzdC5zdGF0dXMgPSAxMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgICAgIGlmICgwIDwgYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IHJlYXNvblxuICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uXCIpXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWFzb24udGhlblxuICAgICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aCBhIHByb21pc2UuXCIpXG4gICAgICAgICAgICAgICAgOiByZWFzb247XG4gICAgICAgICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvciQ0KSB7XG4gICAgICAgIChyZWFzb24gPSB7fSksXG4gICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciQ0LCByZWFzb24sIG51bGwpLFxuICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwgcmVhc29uLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKSB7XG4gICAgICB2YXIgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24gPSBSZWFjdC52ZXJzaW9uO1xuICAgICAgaWYgKFwiMTkuMS4wXCIgIT09IGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnSW5jb21wYXRpYmxlIFJlYWN0IHZlcnNpb25zOiBUaGUgXCJyZWFjdFwiIGFuZCBcInJlYWN0LWRvbVwiIHBhY2thZ2VzIG11c3QgaGF2ZSB0aGUgZXhhY3Qgc2FtZSB2ZXJzaW9uLiBJbnN0ZWFkIGdvdDpcXG4gIC0gcmVhY3Q6ICAgICAgJyArXG4gICAgICAgICAgICAoaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24gK1xuICAgICAgICAgICAgICBcIlxcbiAgLSByZWFjdC1kb206ICAxOS4xLjBcXG5MZWFybiBtb3JlOiBodHRwczovL3JlYWN0LmRldi93YXJuaW5ncy92ZXJzaW9uLW1pc21hdGNoXCIpXG4gICAgICAgICk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX1NDT1BFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIiksXG4gICAgICBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gICAgICBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC52aWV3X3RyYW5zaXRpb25cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBqc3hQcm9wc1BhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAganN4Q2hpbGRyZW5QYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIENMSUVOVF9SRUZFUkVOQ0VfVEFHID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICB0YXNrUXVldWUgPSBbXTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0YXNrID0gdGFza1F1ZXVlLnNoaWZ0KCk7XG4gICAgICB0YXNrICYmIHRhc2soKTtcbiAgICB9O1xuICAgIHZhciBMb2NhbFByb21pc2UgPSBQcm9taXNlLFxuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAgID8gcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBMb2NhbFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgIGN1cnJlbnRWaWV3ID0gbnVsbCxcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDAsXG4gICAgICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpLFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gUmVnRXhwKFxuICAgICAgICBcIl5bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRF1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgICAgIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoXG4gICAgICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgYXNwZWN0UmF0aW8gYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVdpZHRoIGJveEZsZXggYm94RmxleEdyb3VwIGJveE9yZGluYWxHcm91cCBjb2x1bW5Db3VudCBjb2x1bW5zIGZsZXggZmxleEdyb3cgZmxleFBvc2l0aXZlIGZsZXhTaHJpbmsgZmxleE5lZ2F0aXZlIGZsZXhPcmRlciBncmlkQXJlYSBncmlkUm93IGdyaWRSb3dFbmQgZ3JpZFJvd1NwYW4gZ3JpZFJvd1N0YXJ0IGdyaWRDb2x1bW4gZ3JpZENvbHVtbkVuZCBncmlkQ29sdW1uU3BhbiBncmlkQ29sdW1uU3RhcnQgZm9udFdlaWdodCBsaW5lQ2xhbXAgbGluZUhlaWdodCBvcGFjaXR5IG9yZGVyIG9ycGhhbnMgc2NhbGUgdGFiU2l6ZSB3aWRvd3MgekluZGV4IHpvb20gZmlsbE9wYWNpdHkgZmxvb2RPcGFjaXR5IHN0b3BPcGFjaXR5IHN0cm9rZURhc2hhcnJheSBzdHJva2VEYXNob2Zmc2V0IHN0cm9rZU1pdGVybGltaXQgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCBNb3pCb3hGbGV4IE1vekJveEZsZXhHcm91cCBNb3pMaW5lQ2xhbXAgbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCBtc0ZsZXggbXNab29tIG1zRmxleEdyb3cgbXNGbGV4TmVnYXRpdmUgbXNGbGV4T3JkZXIgbXNGbGV4UG9zaXRpdmUgbXNGbGV4U2hyaW5rIG1zR3JpZENvbHVtbiBtc0dyaWRDb2x1bW5TcGFuIG1zR3JpZFJvdyBtc0dyaWRSb3dTcGFuIFdlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IFdlYmtpdEJveEZsZXggV2ViS2l0Qm94RmxleEdyb3VwIFdlYmtpdEJveE9yZGluYWxHcm91cCBXZWJraXRDb2x1bW5Db3VudCBXZWJraXRDb2x1bW5zIFdlYmtpdEZsZXggV2Via2l0RmxleEdyb3cgV2Via2l0RmxleFBvc2l0aXZlIFdlYmtpdEZsZXhTaHJpbmsgV2Via2l0TGluZUNsYW1wXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGFsaWFzZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2VwdC1jaGFyc2V0XCJdLFxuICAgICAgICBbXCJodG1sRm9yXCIsIFwiZm9yXCJdLFxuICAgICAgICBbXCJodHRwRXF1aXZcIiwgXCJodHRwLWVxdWl2XCJdLFxuICAgICAgICBbXCJjcm9zc09yaWdpblwiLCBcImNyb3Nzb3JpZ2luXCJdLFxuICAgICAgICBbXCJhY2NlbnRIZWlnaHRcIiwgXCJhY2NlbnQtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJhbGlnbm1lbnRCYXNlbGluZVwiLCBcImFsaWdubWVudC1iYXNlbGluZVwiXSxcbiAgICAgICAgW1wiYXJhYmljRm9ybVwiLCBcImFyYWJpYy1mb3JtXCJdLFxuICAgICAgICBbXCJiYXNlbGluZVNoaWZ0XCIsIFwiYmFzZWxpbmUtc2hpZnRcIl0sXG4gICAgICAgIFtcImNhcEhlaWdodFwiLCBcImNhcC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImNsaXBQYXRoXCIsIFwiY2xpcC1wYXRoXCJdLFxuICAgICAgICBbXCJjbGlwUnVsZVwiLCBcImNsaXAtcnVsZVwiXSxcbiAgICAgICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiXSxcbiAgICAgICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiXSxcbiAgICAgICAgW1wiY29sb3JQcm9maWxlXCIsIFwiY29sb3ItcHJvZmlsZVwiXSxcbiAgICAgICAgW1wiY29sb3JSZW5kZXJpbmdcIiwgXCJjb2xvci1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImRvbWluYW50QmFzZWxpbmVcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiXSxcbiAgICAgICAgW1wiZW5hYmxlQmFja2dyb3VuZFwiLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCJdLFxuICAgICAgICBbXCJmaWxsT3BhY2l0eVwiLCBcImZpbGwtb3BhY2l0eVwiXSxcbiAgICAgICAgW1wiZmlsbFJ1bGVcIiwgXCJmaWxsLXJ1bGVcIl0sXG4gICAgICAgIFtcImZsb29kQ29sb3JcIiwgXCJmbG9vZC1jb2xvclwiXSxcbiAgICAgICAgW1wiZmxvb2RPcGFjaXR5XCIsIFwiZmxvb2Qtb3BhY2l0eVwiXSxcbiAgICAgICAgW1wiZm9udEZhbWlseVwiLCBcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICBbXCJmb250U2l6ZVwiLCBcImZvbnQtc2l6ZVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVBZGp1c3RcIiwgXCJmb250LXNpemUtYWRqdXN0XCJdLFxuICAgICAgICBbXCJmb250U3RyZXRjaFwiLCBcImZvbnQtc3RyZXRjaFwiXSxcbiAgICAgICAgW1wiZm9udFN0eWxlXCIsIFwiZm9udC1zdHlsZVwiXSxcbiAgICAgICAgW1wiZm9udFZhcmlhbnRcIiwgXCJmb250LXZhcmlhbnRcIl0sXG4gICAgICAgIFtcImZvbnRXZWlnaHRcIiwgXCJmb250LXdlaWdodFwiXSxcbiAgICAgICAgW1wiZ2x5cGhOYW1lXCIsIFwiZ2x5cGgtbmFtZVwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiXSxcbiAgICAgICAgW1wiaG9yaXpBZHZYXCIsIFwiaG9yaXotYWR2LXhcIl0sXG4gICAgICAgIFtcImhvcml6T3JpZ2luWFwiLCBcImhvcml6LW9yaWdpbi14XCJdLFxuICAgICAgICBbXCJpbWFnZVJlbmRlcmluZ1wiLCBcImltYWdlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wibGV0dGVyU3BhY2luZ1wiLCBcImxldHRlci1zcGFjaW5nXCJdLFxuICAgICAgICBbXCJsaWdodGluZ0NvbG9yXCIsIFwibGlnaHRpbmctY29sb3JcIl0sXG4gICAgICAgIFtcIm1hcmtlckVuZFwiLCBcIm1hcmtlci1lbmRcIl0sXG4gICAgICAgIFtcIm1hcmtlck1pZFwiLCBcIm1hcmtlci1taWRcIl0sXG4gICAgICAgIFtcIm1hcmtlclN0YXJ0XCIsIFwibWFya2VyLXN0YXJ0XCJdLFxuICAgICAgICBbXCJvdmVybGluZVBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lVGhpY2tuZXNzXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJwYWludE9yZGVyXCIsIFwicGFpbnQtb3JkZXJcIl0sXG4gICAgICAgIFtcInBhbm9zZS0xXCIsIFwicGFub3NlLTFcIl0sXG4gICAgICAgIFtcInBvaW50ZXJFdmVudHNcIiwgXCJwb2ludGVyLWV2ZW50c1wiXSxcbiAgICAgICAgW1wicmVuZGVyaW5nSW50ZW50XCIsIFwicmVuZGVyaW5nLWludGVudFwiXSxcbiAgICAgICAgW1wic2hhcGVSZW5kZXJpbmdcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcInN0b3BDb2xvclwiLCBcInN0b3AtY29sb3JcIl0sXG4gICAgICAgIFtcInN0b3BPcGFjaXR5XCIsIFwic3RvcC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInN0cm9rZURhc2hhcnJheVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIl0sXG4gICAgICAgIFtcInN0cm9rZURhc2hvZmZzZXRcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWNhcFwiLCBcInN0cm9rZS1saW5lY2FwXCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lam9pblwiLCBcInN0cm9rZS1saW5lam9pblwiXSxcbiAgICAgICAgW1wic3Ryb2tlTWl0ZXJsaW1pdFwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCJdLFxuICAgICAgICBbXCJzdHJva2VPcGFjaXR5XCIsIFwic3Ryb2tlLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cm9rZVdpZHRoXCIsIFwic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgICBbXCJ0ZXh0QW5jaG9yXCIsIFwidGV4dC1hbmNob3JcIl0sXG4gICAgICAgIFtcInRleHREZWNvcmF0aW9uXCIsIFwidGV4dC1kZWNvcmF0aW9uXCJdLFxuICAgICAgICBbXCJ0ZXh0UmVuZGVyaW5nXCIsIFwidGV4dC1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcInRyYW5zZm9ybU9yaWdpblwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVBvc2l0aW9uXCIsIFwidW5kZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVUaGlja25lc3NcIiwgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJ1bmljb2RlQmlkaVwiLCBcInVuaWNvZGUtYmlkaVwiXSxcbiAgICAgICAgW1widW5pY29kZVJhbmdlXCIsIFwidW5pY29kZS1yYW5nZVwiXSxcbiAgICAgICAgW1widW5pdHNQZXJFbVwiLCBcInVuaXRzLXBlci1lbVwiXSxcbiAgICAgICAgW1widkFscGhhYmV0aWNcIiwgXCJ2LWFscGhhYmV0aWNcIl0sXG4gICAgICAgIFtcInZIYW5naW5nXCIsIFwidi1oYW5naW5nXCJdLFxuICAgICAgICBbXCJ2SWRlb2dyYXBoaWNcIiwgXCJ2LWlkZW9ncmFwaGljXCJdLFxuICAgICAgICBbXCJ2TWF0aGVtYXRpY2FsXCIsIFwidi1tYXRoZW1hdGljYWxcIl0sXG4gICAgICAgIFtcInZlY3RvckVmZmVjdFwiLCBcInZlY3Rvci1lZmZlY3RcIl0sXG4gICAgICAgIFtcInZlcnRBZHZZXCIsIFwidmVydC1hZHYteVwiXSxcbiAgICAgICAgW1widmVydE9yaWdpblhcIiwgXCJ2ZXJ0LW9yaWdpbi14XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWVwiLCBcInZlcnQtb3JpZ2luLXlcIl0sXG4gICAgICAgIFtcIndvcmRTcGFjaW5nXCIsIFwid29yZC1zcGFjaW5nXCJdLFxuICAgICAgICBbXCJ3cml0aW5nTW9kZVwiLCBcIndyaXRpbmctbW9kZVwiXSxcbiAgICAgICAgW1wieG1sbnNYbGlua1wiLCBcInhtbG5zOnhsaW5rXCJdLFxuICAgICAgICBbXCJ4SGVpZ2h0XCIsIFwieC1oZWlnaHRcIl1cbiAgICAgIF0pLFxuICAgICAgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICAgICAgYnV0dG9uOiAhMCxcbiAgICAgICAgY2hlY2tib3g6ICEwLFxuICAgICAgICBpbWFnZTogITAsXG4gICAgICAgIGhpZGRlbjogITAsXG4gICAgICAgIHJhZGlvOiAhMCxcbiAgICAgICAgcmVzZXQ6ICEwLFxuICAgICAgICBzdWJtaXQ6ICEwXG4gICAgICB9LFxuICAgICAgYXJpYVByb3BlcnRpZXMgPSB7XG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtZGV0YWlsc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiAwLFxuICAgICAgICBcImFyaWEtaW52YWxpZFwiOiAwLFxuICAgICAgICBcImFyaWEta2V5c2hvcnRjdXRzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiAwLFxuICAgICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogMCxcbiAgICAgICAgXCJhcmlhLWNoZWNrZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiAwLFxuICAgICAgICBcImFyaWEtbGV2ZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW1vZGFsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiAwLFxuICAgICAgICBcImFyaWEtb3JpZW50YXRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLXBsYWNlaG9sZGVyXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wcmVzc2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWFkb25seVwiOiAwLFxuICAgICAgICBcImFyaWEtcmVxdWlyZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zb3J0XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtaW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZXRleHRcIjogMCxcbiAgICAgICAgXCJhcmlhLWF0b21pY1wiOiAwLFxuICAgICAgICBcImFyaWEtYnVzeVwiOiAwLFxuICAgICAgICBcImFyaWEtbGl2ZVwiOiAwLFxuICAgICAgICBcImFyaWEtcmVsZXZhbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRyb3BlZmZlY3RcIjogMCxcbiAgICAgICAgXCJhcmlhLWdyYWJiZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGNvdW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xpbmRleFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sc3BhblwiOiAwLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1lcnJvcm1lc3NhZ2VcIjogMCxcbiAgICAgICAgXCJhcmlhLWZsb3d0b1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtb3duc1wiOiAwLFxuICAgICAgICBcImFyaWEtcG9zaW5zZXRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2NvdW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dpbmRleFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93c3BhblwiOiAwLFxuICAgICAgICBcImFyaWEtc2V0c2l6ZVwiOiAwXG4gICAgICB9LFxuICAgICAgd2FybmVkUHJvcGVydGllcyQxID0ge30sXG4gICAgICByQVJJQSQxID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSktWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgckFSSUFDYW1lbCQxID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSAhMSxcbiAgICAgIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgICAgICAgYWNjZXB0OiBcImFjY2VwdFwiLFxuICAgICAgICBhY2NlcHRjaGFyc2V0OiBcImFjY2VwdENoYXJzZXRcIixcbiAgICAgICAgXCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgICAgICAgYWNjZXNza2V5OiBcImFjY2Vzc0tleVwiLFxuICAgICAgICBhY3Rpb246IFwiYWN0aW9uXCIsXG4gICAgICAgIGFsbG93ZnVsbHNjcmVlbjogXCJhbGxvd0Z1bGxTY3JlZW5cIixcbiAgICAgICAgYWx0OiBcImFsdFwiLFxuICAgICAgICBhczogXCJhc1wiLFxuICAgICAgICBhc3luYzogXCJhc3luY1wiLFxuICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJhdXRvQ2FwaXRhbGl6ZVwiLFxuICAgICAgICBhdXRvY29tcGxldGU6IFwiYXV0b0NvbXBsZXRlXCIsXG4gICAgICAgIGF1dG9jb3JyZWN0OiBcImF1dG9Db3JyZWN0XCIsXG4gICAgICAgIGF1dG9mb2N1czogXCJhdXRvRm9jdXNcIixcbiAgICAgICAgYXV0b3BsYXk6IFwiYXV0b1BsYXlcIixcbiAgICAgICAgYXV0b3NhdmU6IFwiYXV0b1NhdmVcIixcbiAgICAgICAgY2FwdHVyZTogXCJjYXB0dXJlXCIsXG4gICAgICAgIGNlbGxwYWRkaW5nOiBcImNlbGxQYWRkaW5nXCIsXG4gICAgICAgIGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG4gICAgICAgIGNoYWxsZW5nZTogXCJjaGFsbGVuZ2VcIixcbiAgICAgICAgY2hhcnNldDogXCJjaGFyU2V0XCIsXG4gICAgICAgIGNoZWNrZWQ6IFwiY2hlY2tlZFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjaGlsZHJlblwiLFxuICAgICAgICBjaXRlOiBcImNpdGVcIixcbiAgICAgICAgY2xhc3M6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIGNsYXNzaWQ6IFwiY2xhc3NJRFwiLFxuICAgICAgICBjbGFzc25hbWU6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIGNvbHM6IFwiY29sc1wiLFxuICAgICAgICBjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgICAgICAgY29udGVudDogXCJjb250ZW50XCIsXG4gICAgICAgIGNvbnRlbnRlZGl0YWJsZTogXCJjb250ZW50RWRpdGFibGVcIixcbiAgICAgICAgY29udGV4dG1lbnU6IFwiY29udGV4dE1lbnVcIixcbiAgICAgICAgY29udHJvbHM6IFwiY29udHJvbHNcIixcbiAgICAgICAgY29udHJvbHNsaXN0OiBcImNvbnRyb2xzTGlzdFwiLFxuICAgICAgICBjb29yZHM6IFwiY29vcmRzXCIsXG4gICAgICAgIGNyb3Nzb3JpZ2luOiBcImNyb3NzT3JpZ2luXCIsXG4gICAgICAgIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIsXG4gICAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgICBkYXRldGltZTogXCJkYXRlVGltZVwiLFxuICAgICAgICBkZWZhdWx0OiBcImRlZmF1bHRcIixcbiAgICAgICAgZGVmYXVsdGNoZWNrZWQ6IFwiZGVmYXVsdENoZWNrZWRcIixcbiAgICAgICAgZGVmYXVsdHZhbHVlOiBcImRlZmF1bHRWYWx1ZVwiLFxuICAgICAgICBkZWZlcjogXCJkZWZlclwiLFxuICAgICAgICBkaXI6IFwiZGlyXCIsXG4gICAgICAgIGRpc2FibGVkOiBcImRpc2FibGVkXCIsXG4gICAgICAgIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCIsXG4gICAgICAgIGRpc2FibGVyZW1vdGVwbGF5YmFjazogXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIixcbiAgICAgICAgZG93bmxvYWQ6IFwiZG93bmxvYWRcIixcbiAgICAgICAgZHJhZ2dhYmxlOiBcImRyYWdnYWJsZVwiLFxuICAgICAgICBlbmN0eXBlOiBcImVuY1R5cGVcIixcbiAgICAgICAgZW50ZXJrZXloaW50OiBcImVudGVyS2V5SGludFwiLFxuICAgICAgICBmZXRjaHByaW9yaXR5OiBcImZldGNoUHJpb3JpdHlcIixcbiAgICAgICAgZm9yOiBcImh0bWxGb3JcIixcbiAgICAgICAgZm9ybTogXCJmb3JtXCIsXG4gICAgICAgIGZvcm1tZXRob2Q6IFwiZm9ybU1ldGhvZFwiLFxuICAgICAgICBmb3JtYWN0aW9uOiBcImZvcm1BY3Rpb25cIixcbiAgICAgICAgZm9ybWVuY3R5cGU6IFwiZm9ybUVuY1R5cGVcIixcbiAgICAgICAgZm9ybW5vdmFsaWRhdGU6IFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgICAgICAgZm9ybXRhcmdldDogXCJmb3JtVGFyZ2V0XCIsXG4gICAgICAgIGZyYW1lYm9yZGVyOiBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIGhlYWRlcnM6IFwiaGVhZGVyc1wiLFxuICAgICAgICBoZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gICAgICAgIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgICAgICAgaGlnaDogXCJoaWdoXCIsXG4gICAgICAgIGhyZWY6IFwiaHJlZlwiLFxuICAgICAgICBocmVmbGFuZzogXCJocmVmTGFuZ1wiLFxuICAgICAgICBodG1sZm9yOiBcImh0bWxGb3JcIixcbiAgICAgICAgaHR0cGVxdWl2OiBcImh0dHBFcXVpdlwiLFxuICAgICAgICBcImh0dHAtZXF1aXZcIjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgaWNvbjogXCJpY29uXCIsXG4gICAgICAgIGlkOiBcImlkXCIsXG4gICAgICAgIGltYWdlc2l6ZXM6IFwiaW1hZ2VTaXplc1wiLFxuICAgICAgICBpbWFnZXNyY3NldDogXCJpbWFnZVNyY1NldFwiLFxuICAgICAgICBpbmVydDogXCJpbmVydFwiLFxuICAgICAgICBpbm5lcmh0bWw6IFwiaW5uZXJIVE1MXCIsXG4gICAgICAgIGlucHV0bW9kZTogXCJpbnB1dE1vZGVcIixcbiAgICAgICAgaW50ZWdyaXR5OiBcImludGVncml0eVwiLFxuICAgICAgICBpczogXCJpc1wiLFxuICAgICAgICBpdGVtaWQ6IFwiaXRlbUlEXCIsXG4gICAgICAgIGl0ZW1wcm9wOiBcIml0ZW1Qcm9wXCIsXG4gICAgICAgIGl0ZW1yZWY6IFwiaXRlbVJlZlwiLFxuICAgICAgICBpdGVtc2NvcGU6IFwiaXRlbVNjb3BlXCIsXG4gICAgICAgIGl0ZW10eXBlOiBcIml0ZW1UeXBlXCIsXG4gICAgICAgIGtleXBhcmFtczogXCJrZXlQYXJhbXNcIixcbiAgICAgICAga2V5dHlwZTogXCJrZXlUeXBlXCIsXG4gICAgICAgIGtpbmQ6IFwia2luZFwiLFxuICAgICAgICBsYWJlbDogXCJsYWJlbFwiLFxuICAgICAgICBsYW5nOiBcImxhbmdcIixcbiAgICAgICAgbGlzdDogXCJsaXN0XCIsXG4gICAgICAgIGxvb3A6IFwibG9vcFwiLFxuICAgICAgICBsb3c6IFwibG93XCIsXG4gICAgICAgIG1hbmlmZXN0OiBcIm1hbmlmZXN0XCIsXG4gICAgICAgIG1hcmdpbndpZHRoOiBcIm1hcmdpbldpZHRoXCIsXG4gICAgICAgIG1hcmdpbmhlaWdodDogXCJtYXJnaW5IZWlnaHRcIixcbiAgICAgICAgbWF4OiBcIm1heFwiLFxuICAgICAgICBtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gICAgICAgIG1lZGlhOiBcIm1lZGlhXCIsXG4gICAgICAgIG1lZGlhZ3JvdXA6IFwibWVkaWFHcm91cFwiLFxuICAgICAgICBtZXRob2Q6IFwibWV0aG9kXCIsXG4gICAgICAgIG1pbjogXCJtaW5cIixcbiAgICAgICAgbWlubGVuZ3RoOiBcIm1pbkxlbmd0aFwiLFxuICAgICAgICBtdWx0aXBsZTogXCJtdWx0aXBsZVwiLFxuICAgICAgICBtdXRlZDogXCJtdXRlZFwiLFxuICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgbm9tb2R1bGU6IFwibm9Nb2R1bGVcIixcbiAgICAgICAgbm9uY2U6IFwibm9uY2VcIixcbiAgICAgICAgbm92YWxpZGF0ZTogXCJub1ZhbGlkYXRlXCIsXG4gICAgICAgIG9wZW46IFwib3BlblwiLFxuICAgICAgICBvcHRpbXVtOiBcIm9wdGltdW1cIixcbiAgICAgICAgcGF0dGVybjogXCJwYXR0ZXJuXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHBsYXlzaW5saW5lOiBcInBsYXlzSW5saW5lXCIsXG4gICAgICAgIHBvc3RlcjogXCJwb3N0ZXJcIixcbiAgICAgICAgcHJlbG9hZDogXCJwcmVsb2FkXCIsXG4gICAgICAgIHByb2ZpbGU6IFwicHJvZmlsZVwiLFxuICAgICAgICByYWRpb2dyb3VwOiBcInJhZGlvR3JvdXBcIixcbiAgICAgICAgcmVhZG9ubHk6IFwicmVhZE9ubHlcIixcbiAgICAgICAgcmVmZXJyZXJwb2xpY3k6IFwicmVmZXJyZXJQb2xpY3lcIixcbiAgICAgICAgcmVsOiBcInJlbFwiLFxuICAgICAgICByZXF1aXJlZDogXCJyZXF1aXJlZFwiLFxuICAgICAgICByZXZlcnNlZDogXCJyZXZlcnNlZFwiLFxuICAgICAgICByb2xlOiBcInJvbGVcIixcbiAgICAgICAgcm93czogXCJyb3dzXCIsXG4gICAgICAgIHJvd3NwYW46IFwicm93U3BhblwiLFxuICAgICAgICBzYW5kYm94OiBcInNhbmRib3hcIixcbiAgICAgICAgc2NvcGU6IFwic2NvcGVcIixcbiAgICAgICAgc2NvcGVkOiBcInNjb3BlZFwiLFxuICAgICAgICBzY3JvbGxpbmc6IFwic2Nyb2xsaW5nXCIsXG4gICAgICAgIHNlYW1sZXNzOiBcInNlYW1sZXNzXCIsXG4gICAgICAgIHNlbGVjdGVkOiBcInNlbGVjdGVkXCIsXG4gICAgICAgIHNoYXBlOiBcInNoYXBlXCIsXG4gICAgICAgIHNpemU6IFwic2l6ZVwiLFxuICAgICAgICBzaXplczogXCJzaXplc1wiLFxuICAgICAgICBzcGFuOiBcInNwYW5cIixcbiAgICAgICAgc3BlbGxjaGVjazogXCJzcGVsbENoZWNrXCIsXG4gICAgICAgIHNyYzogXCJzcmNcIixcbiAgICAgICAgc3JjZG9jOiBcInNyY0RvY1wiLFxuICAgICAgICBzcmNsYW5nOiBcInNyY0xhbmdcIixcbiAgICAgICAgc3Jjc2V0OiBcInNyY1NldFwiLFxuICAgICAgICBzdGFydDogXCJzdGFydFwiLFxuICAgICAgICBzdGVwOiBcInN0ZXBcIixcbiAgICAgICAgc3R5bGU6IFwic3R5bGVcIixcbiAgICAgICAgc3VtbWFyeTogXCJzdW1tYXJ5XCIsXG4gICAgICAgIHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gICAgICAgIHRhcmdldDogXCJ0YXJnZXRcIixcbiAgICAgICAgdGl0bGU6IFwidGl0bGVcIixcbiAgICAgICAgdHlwZTogXCJ0eXBlXCIsXG4gICAgICAgIHVzZW1hcDogXCJ1c2VNYXBcIixcbiAgICAgICAgdmFsdWU6IFwidmFsdWVcIixcbiAgICAgICAgd2lkdGg6IFwid2lkdGhcIixcbiAgICAgICAgd21vZGU6IFwid21vZGVcIixcbiAgICAgICAgd3JhcDogXCJ3cmFwXCIsXG4gICAgICAgIGFib3V0OiBcImFib3V0XCIsXG4gICAgICAgIGFjY2VudGhlaWdodDogXCJhY2NlbnRIZWlnaHRcIixcbiAgICAgICAgXCJhY2NlbnQtaGVpZ2h0XCI6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIGFjY3VtdWxhdGU6IFwiYWNjdW11bGF0ZVwiLFxuICAgICAgICBhZGRpdGl2ZTogXCJhZGRpdGl2ZVwiLFxuICAgICAgICBhbGlnbm1lbnRiYXNlbGluZTogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBcImFsaWdubWVudC1iYXNlbGluZVwiOiBcImFsaWdubWVudEJhc2VsaW5lXCIsXG4gICAgICAgIGFsbG93cmVvcmRlcjogXCJhbGxvd1Jlb3JkZXJcIixcbiAgICAgICAgYWxwaGFiZXRpYzogXCJhbHBoYWJldGljXCIsXG4gICAgICAgIGFtcGxpdHVkZTogXCJhbXBsaXR1ZGVcIixcbiAgICAgICAgYXJhYmljZm9ybTogXCJhcmFiaWNGb3JtXCIsXG4gICAgICAgIFwiYXJhYmljLWZvcm1cIjogXCJhcmFiaWNGb3JtXCIsXG4gICAgICAgIGFzY2VudDogXCJhc2NlbnRcIixcbiAgICAgICAgYXR0cmlidXRlbmFtZTogXCJhdHRyaWJ1dGVOYW1lXCIsXG4gICAgICAgIGF0dHJpYnV0ZXR5cGU6IFwiYXR0cmlidXRlVHlwZVwiLFxuICAgICAgICBhdXRvcmV2ZXJzZTogXCJhdXRvUmV2ZXJzZVwiLFxuICAgICAgICBhemltdXRoOiBcImF6aW11dGhcIixcbiAgICAgICAgYmFzZWZyZXF1ZW5jeTogXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgICAgIGJhc2VsaW5lc2hpZnQ6IFwiYmFzZWxpbmVTaGlmdFwiLFxuICAgICAgICBcImJhc2VsaW5lLXNoaWZ0XCI6IFwiYmFzZWxpbmVTaGlmdFwiLFxuICAgICAgICBiYXNlcHJvZmlsZTogXCJiYXNlUHJvZmlsZVwiLFxuICAgICAgICBiYm94OiBcImJib3hcIixcbiAgICAgICAgYmVnaW46IFwiYmVnaW5cIixcbiAgICAgICAgYmlhczogXCJiaWFzXCIsXG4gICAgICAgIGJ5OiBcImJ5XCIsXG4gICAgICAgIGNhbGNtb2RlOiBcImNhbGNNb2RlXCIsXG4gICAgICAgIGNhcGhlaWdodDogXCJjYXBIZWlnaHRcIixcbiAgICAgICAgXCJjYXAtaGVpZ2h0XCI6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIGNsaXA6IFwiY2xpcFwiLFxuICAgICAgICBjbGlwcGF0aDogXCJjbGlwUGF0aFwiLFxuICAgICAgICBcImNsaXAtcGF0aFwiOiBcImNsaXBQYXRoXCIsXG4gICAgICAgIGNsaXBwYXRodW5pdHM6IFwiY2xpcFBhdGhVbml0c1wiLFxuICAgICAgICBjbGlwcnVsZTogXCJjbGlwUnVsZVwiLFxuICAgICAgICBcImNsaXAtcnVsZVwiOiBcImNsaXBSdWxlXCIsXG4gICAgICAgIGNvbG9yOiBcImNvbG9yXCIsXG4gICAgICAgIGNvbG9yaW50ZXJwb2xhdGlvbjogXCJjb2xvckludGVycG9sYXRpb25cIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6IFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgY29sb3Jwcm9maWxlOiBcImNvbG9yUHJvZmlsZVwiLFxuICAgICAgICBcImNvbG9yLXByb2ZpbGVcIjogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgY29sb3JyZW5kZXJpbmc6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgXCJjb2xvci1yZW5kZXJpbmdcIjogXCJjb2xvclJlbmRlcmluZ1wiLFxuICAgICAgICBjb250ZW50c2NyaXB0dHlwZTogXCJjb250ZW50U2NyaXB0VHlwZVwiLFxuICAgICAgICBjb250ZW50c3R5bGV0eXBlOiBcImNvbnRlbnRTdHlsZVR5cGVcIixcbiAgICAgICAgY3Vyc29yOiBcImN1cnNvclwiLFxuICAgICAgICBjeDogXCJjeFwiLFxuICAgICAgICBjeTogXCJjeVwiLFxuICAgICAgICBkOiBcImRcIixcbiAgICAgICAgZGF0YXR5cGU6IFwiZGF0YXR5cGVcIixcbiAgICAgICAgZGVjZWxlcmF0ZTogXCJkZWNlbGVyYXRlXCIsXG4gICAgICAgIGRlc2NlbnQ6IFwiZGVzY2VudFwiLFxuICAgICAgICBkaWZmdXNlY29uc3RhbnQ6IFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgICAgIGRpcmVjdGlvbjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgZGlzcGxheTogXCJkaXNwbGF5XCIsXG4gICAgICAgIGRpdmlzb3I6IFwiZGl2aXNvclwiLFxuICAgICAgICBkb21pbmFudGJhc2VsaW5lOiBcImRvbWluYW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJkb21pbmFudC1iYXNlbGluZVwiOiBcImRvbWluYW50QmFzZWxpbmVcIixcbiAgICAgICAgZHVyOiBcImR1clwiLFxuICAgICAgICBkeDogXCJkeFwiLFxuICAgICAgICBkeTogXCJkeVwiLFxuICAgICAgICBlZGdlbW9kZTogXCJlZGdlTW9kZVwiLFxuICAgICAgICBlbGV2YXRpb246IFwiZWxldmF0aW9uXCIsXG4gICAgICAgIGVuYWJsZWJhY2tncm91bmQ6IFwiZW5hYmxlQmFja2dyb3VuZFwiLFxuICAgICAgICBcImVuYWJsZS1iYWNrZ3JvdW5kXCI6IFwiZW5hYmxlQmFja2dyb3VuZFwiLFxuICAgICAgICBlbmQ6IFwiZW5kXCIsXG4gICAgICAgIGV4cG9uZW50OiBcImV4cG9uZW50XCIsXG4gICAgICAgIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6IFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgICAgICBmaWxsOiBcImZpbGxcIixcbiAgICAgICAgZmlsbG9wYWNpdHk6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogXCJmaWxsT3BhY2l0eVwiLFxuICAgICAgICBmaWxscnVsZTogXCJmaWxsUnVsZVwiLFxuICAgICAgICBcImZpbGwtcnVsZVwiOiBcImZpbGxSdWxlXCIsXG4gICAgICAgIGZpbHRlcjogXCJmaWx0ZXJcIixcbiAgICAgICAgZmlsdGVycmVzOiBcImZpbHRlclJlc1wiLFxuICAgICAgICBmaWx0ZXJ1bml0czogXCJmaWx0ZXJVbml0c1wiLFxuICAgICAgICBmbG9vZG9wYWNpdHk6IFwiZmxvb2RPcGFjaXR5XCIsXG4gICAgICAgIFwiZmxvb2Qtb3BhY2l0eVwiOiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBmbG9vZGNvbG9yOiBcImZsb29kQ29sb3JcIixcbiAgICAgICAgXCJmbG9vZC1jb2xvclwiOiBcImZsb29kQ29sb3JcIixcbiAgICAgICAgZm9jdXNhYmxlOiBcImZvY3VzYWJsZVwiLFxuICAgICAgICBmb250ZmFtaWx5OiBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgZm9udHNpemU6IFwiZm9udFNpemVcIixcbiAgICAgICAgXCJmb250LXNpemVcIjogXCJmb250U2l6ZVwiLFxuICAgICAgICBmb250c2l6ZWFkanVzdDogXCJmb250U2l6ZUFkanVzdFwiLFxuICAgICAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogXCJmb250U2l6ZUFkanVzdFwiLFxuICAgICAgICBmb250c3RyZXRjaDogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBcImZvbnQtc3RyZXRjaFwiOiBcImZvbnRTdHJldGNoXCIsXG4gICAgICAgIGZvbnRzdHlsZTogXCJmb250U3R5bGVcIixcbiAgICAgICAgXCJmb250LXN0eWxlXCI6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIGZvbnR2YXJpYW50OiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIFwiZm9udC12YXJpYW50XCI6IFwiZm9udFZhcmlhbnRcIixcbiAgICAgICAgZm9udHdlaWdodDogXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIjogXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIGZvcm1hdDogXCJmb3JtYXRcIixcbiAgICAgICAgZnJvbTogXCJmcm9tXCIsXG4gICAgICAgIGZ4OiBcImZ4XCIsXG4gICAgICAgIGZ5OiBcImZ5XCIsXG4gICAgICAgIGcxOiBcImcxXCIsXG4gICAgICAgIGcyOiBcImcyXCIsXG4gICAgICAgIGdseXBobmFtZTogXCJnbHlwaE5hbWVcIixcbiAgICAgICAgXCJnbHlwaC1uYW1lXCI6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiBcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiBcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsXG4gICAgICAgIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiOiBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICAgICAgICBnbHlwaHJlZjogXCJnbHlwaFJlZlwiLFxuICAgICAgICBncmFkaWVudHRyYW5zZm9ybTogXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgICAgICBncmFkaWVudHVuaXRzOiBcImdyYWRpZW50VW5pdHNcIixcbiAgICAgICAgaGFuZ2luZzogXCJoYW5naW5nXCIsXG4gICAgICAgIGhvcml6YWR2eDogXCJob3JpekFkdlhcIixcbiAgICAgICAgXCJob3Jpei1hZHYteFwiOiBcImhvcml6QWR2WFwiLFxuICAgICAgICBob3Jpem9yaWdpbng6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIFwiaG9yaXotb3JpZ2luLXhcIjogXCJob3Jpek9yaWdpblhcIixcbiAgICAgICAgaWRlb2dyYXBoaWM6IFwiaWRlb2dyYXBoaWNcIixcbiAgICAgICAgaW1hZ2VyZW5kZXJpbmc6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgXCJpbWFnZS1yZW5kZXJpbmdcIjogXCJpbWFnZVJlbmRlcmluZ1wiLFxuICAgICAgICBpbjI6IFwiaW4yXCIsXG4gICAgICAgIGluOiBcImluXCIsXG4gICAgICAgIGlubGlzdDogXCJpbmxpc3RcIixcbiAgICAgICAgaW50ZXJjZXB0OiBcImludGVyY2VwdFwiLFxuICAgICAgICBrMTogXCJrMVwiLFxuICAgICAgICBrMjogXCJrMlwiLFxuICAgICAgICBrMzogXCJrM1wiLFxuICAgICAgICBrNDogXCJrNFwiLFxuICAgICAgICBrOiBcImtcIixcbiAgICAgICAga2VybmVsbWF0cml4OiBcImtlcm5lbE1hdHJpeFwiLFxuICAgICAgICBrZXJuZWx1bml0bGVuZ3RoOiBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgICAgICAga2VybmluZzogXCJrZXJuaW5nXCIsXG4gICAgICAgIGtleXBvaW50czogXCJrZXlQb2ludHNcIixcbiAgICAgICAga2V5c3BsaW5lczogXCJrZXlTcGxpbmVzXCIsXG4gICAgICAgIGtleXRpbWVzOiBcImtleVRpbWVzXCIsXG4gICAgICAgIGxlbmd0aGFkanVzdDogXCJsZW5ndGhBZGp1c3RcIixcbiAgICAgICAgbGV0dGVyc3BhY2luZzogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgICAgIFwibGV0dGVyLXNwYWNpbmdcIjogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgICAgIGxpZ2h0aW5nY29sb3I6IFwibGlnaHRpbmdDb2xvclwiLFxuICAgICAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IFwibGlnaHRpbmdDb2xvclwiLFxuICAgICAgICBsaW1pdGluZ2NvbmVhbmdsZTogXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgICAgICBsb2NhbDogXCJsb2NhbFwiLFxuICAgICAgICBtYXJrZXJlbmQ6IFwibWFya2VyRW5kXCIsXG4gICAgICAgIFwibWFya2VyLWVuZFwiOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBtYXJrZXJoZWlnaHQ6IFwibWFya2VySGVpZ2h0XCIsXG4gICAgICAgIG1hcmtlcm1pZDogXCJtYXJrZXJNaWRcIixcbiAgICAgICAgXCJtYXJrZXItbWlkXCI6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIG1hcmtlcnN0YXJ0OiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIFwibWFya2VyLXN0YXJ0XCI6IFwibWFya2VyU3RhcnRcIixcbiAgICAgICAgbWFya2VydW5pdHM6IFwibWFya2VyVW5pdHNcIixcbiAgICAgICAgbWFya2Vyd2lkdGg6IFwibWFya2VyV2lkdGhcIixcbiAgICAgICAgbWFzazogXCJtYXNrXCIsXG4gICAgICAgIG1hc2tjb250ZW50dW5pdHM6IFwibWFza0NvbnRlbnRVbml0c1wiLFxuICAgICAgICBtYXNrdW5pdHM6IFwibWFza1VuaXRzXCIsXG4gICAgICAgIG1hdGhlbWF0aWNhbDogXCJtYXRoZW1hdGljYWxcIixcbiAgICAgICAgbW9kZTogXCJtb2RlXCIsXG4gICAgICAgIG51bW9jdGF2ZXM6IFwibnVtT2N0YXZlc1wiLFxuICAgICAgICBvZmZzZXQ6IFwib2Zmc2V0XCIsXG4gICAgICAgIG9wYWNpdHk6IFwib3BhY2l0eVwiLFxuICAgICAgICBvcGVyYXRvcjogXCJvcGVyYXRvclwiLFxuICAgICAgICBvcmRlcjogXCJvcmRlclwiLFxuICAgICAgICBvcmllbnQ6IFwib3JpZW50XCIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBcIm9yaWVudGF0aW9uXCIsXG4gICAgICAgIG9yaWdpbjogXCJvcmlnaW5cIixcbiAgICAgICAgb3ZlcmZsb3c6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgb3ZlcmxpbmVwb3NpdGlvbjogXCJvdmVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwib3ZlcmxpbmUtcG9zaXRpb25cIjogXCJvdmVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIG92ZXJsaW5ldGhpY2tuZXNzOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCI6IFwib3ZlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgcGFpbnRvcmRlcjogXCJwYWludE9yZGVyXCIsXG4gICAgICAgIFwicGFpbnQtb3JkZXJcIjogXCJwYWludE9yZGVyXCIsXG4gICAgICAgIHBhbm9zZTE6IFwicGFub3NlMVwiLFxuICAgICAgICBcInBhbm9zZS0xXCI6IFwicGFub3NlMVwiLFxuICAgICAgICBwYXRobGVuZ3RoOiBcInBhdGhMZW5ndGhcIixcbiAgICAgICAgcGF0dGVybmNvbnRlbnR1bml0czogXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gICAgICAgIHBhdHRlcm50cmFuc2Zvcm06IFwicGF0dGVyblRyYW5zZm9ybVwiLFxuICAgICAgICBwYXR0ZXJudW5pdHM6IFwicGF0dGVyblVuaXRzXCIsXG4gICAgICAgIHBvaW50ZXJldmVudHM6IFwicG9pbnRlckV2ZW50c1wiLFxuICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwicG9pbnRlckV2ZW50c1wiLFxuICAgICAgICBwb2ludHM6IFwicG9pbnRzXCIsXG4gICAgICAgIHBvaW50c2F0eDogXCJwb2ludHNBdFhcIixcbiAgICAgICAgcG9pbnRzYXR5OiBcInBvaW50c0F0WVwiLFxuICAgICAgICBwb2ludHNhdHo6IFwicG9pbnRzQXRaXCIsXG4gICAgICAgIHBvcG92ZXI6IFwicG9wb3ZlclwiLFxuICAgICAgICBwb3BvdmVydGFyZ2V0OiBcInBvcG92ZXJUYXJnZXRcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldGFjdGlvbjogXCJwb3BvdmVyVGFyZ2V0QWN0aW9uXCIsXG4gICAgICAgIHByZWZpeDogXCJwcmVmaXhcIixcbiAgICAgICAgcHJlc2VydmVhbHBoYTogXCJwcmVzZXJ2ZUFscGhhXCIsXG4gICAgICAgIHByZXNlcnZlYXNwZWN0cmF0aW86IFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFxuICAgICAgICBwcmltaXRpdmV1bml0czogXCJwcmltaXRpdmVVbml0c1wiLFxuICAgICAgICBwcm9wZXJ0eTogXCJwcm9wZXJ0eVwiLFxuICAgICAgICByOiBcInJcIixcbiAgICAgICAgcmFkaXVzOiBcInJhZGl1c1wiLFxuICAgICAgICByZWZ4OiBcInJlZlhcIixcbiAgICAgICAgcmVmeTogXCJyZWZZXCIsXG4gICAgICAgIHJlbmRlcmluZ2ludGVudDogXCJyZW5kZXJpbmdJbnRlbnRcIixcbiAgICAgICAgXCJyZW5kZXJpbmctaW50ZW50XCI6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIHJlcGVhdGNvdW50OiBcInJlcGVhdENvdW50XCIsXG4gICAgICAgIHJlcGVhdGR1cjogXCJyZXBlYXREdXJcIixcbiAgICAgICAgcmVxdWlyZWRleHRlbnNpb25zOiBcInJlcXVpcmVkRXh0ZW5zaW9uc1wiLFxuICAgICAgICByZXF1aXJlZGZlYXR1cmVzOiBcInJlcXVpcmVkRmVhdHVyZXNcIixcbiAgICAgICAgcmVzb3VyY2U6IFwicmVzb3VyY2VcIixcbiAgICAgICAgcmVzdGFydDogXCJyZXN0YXJ0XCIsXG4gICAgICAgIHJlc3VsdDogXCJyZXN1bHRcIixcbiAgICAgICAgcmVzdWx0czogXCJyZXN1bHRzXCIsXG4gICAgICAgIHJvdGF0ZTogXCJyb3RhdGVcIixcbiAgICAgICAgcng6IFwicnhcIixcbiAgICAgICAgcnk6IFwicnlcIixcbiAgICAgICAgc2NhbGU6IFwic2NhbGVcIixcbiAgICAgICAgc2VjdXJpdHk6IFwic2VjdXJpdHlcIixcbiAgICAgICAgc2VlZDogXCJzZWVkXCIsXG4gICAgICAgIHNoYXBlcmVuZGVyaW5nOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwic2hhcGUtcmVuZGVyaW5nXCI6IFwic2hhcGVSZW5kZXJpbmdcIixcbiAgICAgICAgc2xvcGU6IFwic2xvcGVcIixcbiAgICAgICAgc3BhY2luZzogXCJzcGFjaW5nXCIsXG4gICAgICAgIHNwZWN1bGFyY29uc3RhbnQ6IFwic3BlY3VsYXJDb25zdGFudFwiLFxuICAgICAgICBzcGVjdWxhcmV4cG9uZW50OiBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICAgICAgc3BlZWQ6IFwic3BlZWRcIixcbiAgICAgICAgc3ByZWFkbWV0aG9kOiBcInNwcmVhZE1ldGhvZFwiLFxuICAgICAgICBzdGFydG9mZnNldDogXCJzdGFydE9mZnNldFwiLFxuICAgICAgICBzdGRkZXZpYXRpb246IFwic3RkRGV2aWF0aW9uXCIsXG4gICAgICAgIHN0ZW1oOiBcInN0ZW1oXCIsXG4gICAgICAgIHN0ZW12OiBcInN0ZW12XCIsXG4gICAgICAgIHN0aXRjaHRpbGVzOiBcInN0aXRjaFRpbGVzXCIsXG4gICAgICAgIHN0b3Bjb2xvcjogXCJzdG9wQ29sb3JcIixcbiAgICAgICAgXCJzdG9wLWNvbG9yXCI6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIHN0b3BvcGFjaXR5OiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIFwic3RvcC1vcGFjaXR5XCI6IFwic3RvcE9wYWNpdHlcIixcbiAgICAgICAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiBcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsXG4gICAgICAgIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIjogXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsXG4gICAgICAgIHN0cmluZzogXCJzdHJpbmdcIixcbiAgICAgICAgc3Ryb2tlOiBcInN0cm9rZVwiLFxuICAgICAgICBzdHJva2VkYXNoYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBzdHJva2VkYXNob2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICAgICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICAgICAgc3Ryb2tlbGluZWNhcDogXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgICAgIHN0cm9rZWxpbmVqb2luOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwic3Ryb2tlTGluZWpvaW5cIixcbiAgICAgICAgc3Ryb2tlbWl0ZXJsaW1pdDogXCJzdHJva2VNaXRlcmxpbWl0XCIsXG4gICAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogXCJzdHJva2VNaXRlcmxpbWl0XCIsXG4gICAgICAgIHN0cm9rZXdpZHRoOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwic3Ryb2tlV2lkdGhcIixcbiAgICAgICAgc3Ryb2tlb3BhY2l0eTogXCJzdHJva2VPcGFjaXR5XCIsXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogXCJzdHJva2VPcGFjaXR5XCIsXG4gICAgICAgIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIixcbiAgICAgICAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiLFxuICAgICAgICBzdXJmYWNlc2NhbGU6IFwic3VyZmFjZVNjYWxlXCIsXG4gICAgICAgIHN5c3RlbWxhbmd1YWdlOiBcInN5c3RlbUxhbmd1YWdlXCIsXG4gICAgICAgIHRhYmxldmFsdWVzOiBcInRhYmxlVmFsdWVzXCIsXG4gICAgICAgIHRhcmdldHg6IFwidGFyZ2V0WFwiLFxuICAgICAgICB0YXJnZXR5OiBcInRhcmdldFlcIixcbiAgICAgICAgdGV4dGFuY2hvcjogXCJ0ZXh0QW5jaG9yXCIsXG4gICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJ0ZXh0QW5jaG9yXCIsXG4gICAgICAgIHRleHRkZWNvcmF0aW9uOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IFwidGV4dERlY29yYXRpb25cIixcbiAgICAgICAgdGV4dGxlbmd0aDogXCJ0ZXh0TGVuZ3RoXCIsXG4gICAgICAgIHRleHRyZW5kZXJpbmc6IFwidGV4dFJlbmRlcmluZ1wiLFxuICAgICAgICBcInRleHQtcmVuZGVyaW5nXCI6IFwidGV4dFJlbmRlcmluZ1wiLFxuICAgICAgICB0bzogXCJ0b1wiLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybW9yaWdpbjogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIHR5cGVvZjogXCJ0eXBlb2ZcIixcbiAgICAgICAgdTE6IFwidTFcIixcbiAgICAgICAgdTI6IFwidTJcIixcbiAgICAgICAgdW5kZXJsaW5lcG9zaXRpb246IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIjogXCJ1bmRlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICB1bmRlcmxpbmV0aGlja25lc3M6IFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICB1bmljb2RlOiBcInVuaWNvZGVcIixcbiAgICAgICAgdW5pY29kZWJpZGk6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgXCJ1bmljb2RlLWJpZGlcIjogXCJ1bmljb2RlQmlkaVwiLFxuICAgICAgICB1bmljb2RlcmFuZ2U6IFwidW5pY29kZVJhbmdlXCIsXG4gICAgICAgIFwidW5pY29kZS1yYW5nZVwiOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICB1bml0c3BlcmVtOiBcInVuaXRzUGVyRW1cIixcbiAgICAgICAgXCJ1bml0cy1wZXItZW1cIjogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIHVuc2VsZWN0YWJsZTogXCJ1bnNlbGVjdGFibGVcIixcbiAgICAgICAgdmFscGhhYmV0aWM6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgXCJ2LWFscGhhYmV0aWNcIjogXCJ2QWxwaGFiZXRpY1wiLFxuICAgICAgICB2YWx1ZXM6IFwidmFsdWVzXCIsXG4gICAgICAgIHZlY3RvcmVmZmVjdDogXCJ2ZWN0b3JFZmZlY3RcIixcbiAgICAgICAgXCJ2ZWN0b3ItZWZmZWN0XCI6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIHZlcnNpb246IFwidmVyc2lvblwiLFxuICAgICAgICB2ZXJ0YWR2eTogXCJ2ZXJ0QWR2WVwiLFxuICAgICAgICBcInZlcnQtYWR2LXlcIjogXCJ2ZXJ0QWR2WVwiLFxuICAgICAgICB2ZXJ0b3JpZ2lueDogXCJ2ZXJ0T3JpZ2luWFwiLFxuICAgICAgICBcInZlcnQtb3JpZ2luLXhcIjogXCJ2ZXJ0T3JpZ2luWFwiLFxuICAgICAgICB2ZXJ0b3JpZ2lueTogXCJ2ZXJ0T3JpZ2luWVwiLFxuICAgICAgICBcInZlcnQtb3JpZ2luLXlcIjogXCJ2ZXJ0T3JpZ2luWVwiLFxuICAgICAgICB2aGFuZ2luZzogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICBcInYtaGFuZ2luZ1wiOiBcInZIYW5naW5nXCIsXG4gICAgICAgIHZpZGVvZ3JhcGhpYzogXCJ2SWRlb2dyYXBoaWNcIixcbiAgICAgICAgXCJ2LWlkZW9ncmFwaGljXCI6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIHZpZXdib3g6IFwidmlld0JveFwiLFxuICAgICAgICB2aWV3dGFyZ2V0OiBcInZpZXdUYXJnZXRcIixcbiAgICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmlsaXR5XCIsXG4gICAgICAgIHZtYXRoZW1hdGljYWw6IFwidk1hdGhlbWF0aWNhbFwiLFxuICAgICAgICBcInYtbWF0aGVtYXRpY2FsXCI6IFwidk1hdGhlbWF0aWNhbFwiLFxuICAgICAgICB2b2NhYjogXCJ2b2NhYlwiLFxuICAgICAgICB3aWR0aHM6IFwid2lkdGhzXCIsXG4gICAgICAgIHdvcmRzcGFjaW5nOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIFwid29yZC1zcGFjaW5nXCI6IFwid29yZFNwYWNpbmdcIixcbiAgICAgICAgd3JpdGluZ21vZGU6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgXCJ3cml0aW5nLW1vZGVcIjogXCJ3cml0aW5nTW9kZVwiLFxuICAgICAgICB4MTogXCJ4MVwiLFxuICAgICAgICB4MjogXCJ4MlwiLFxuICAgICAgICB4OiBcInhcIixcbiAgICAgICAgeGNoYW5uZWxzZWxlY3RvcjogXCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgICAgIHhoZWlnaHQ6IFwieEhlaWdodFwiLFxuICAgICAgICBcIngtaGVpZ2h0XCI6IFwieEhlaWdodFwiLFxuICAgICAgICB4bGlua2FjdHVhdGU6IFwieGxpbmtBY3R1YXRlXCIsXG4gICAgICAgIFwieGxpbms6YWN0dWF0ZVwiOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICB4bGlua2FyY3JvbGU6IFwieGxpbmtBcmNyb2xlXCIsXG4gICAgICAgIFwieGxpbms6YXJjcm9sZVwiOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICB4bGlua2hyZWY6IFwieGxpbmtIcmVmXCIsXG4gICAgICAgIFwieGxpbms6aHJlZlwiOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICB4bGlua3JvbGU6IFwieGxpbmtSb2xlXCIsXG4gICAgICAgIFwieGxpbms6cm9sZVwiOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICB4bGlua3Nob3c6IFwieGxpbmtTaG93XCIsXG4gICAgICAgIFwieGxpbms6c2hvd1wiOiBcInhsaW5rU2hvd1wiLFxuICAgICAgICB4bGlua3RpdGxlOiBcInhsaW5rVGl0bGVcIixcbiAgICAgICAgXCJ4bGluazp0aXRsZVwiOiBcInhsaW5rVGl0bGVcIixcbiAgICAgICAgeGxpbmt0eXBlOiBcInhsaW5rVHlwZVwiLFxuICAgICAgICBcInhsaW5rOnR5cGVcIjogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgeG1sYmFzZTogXCJ4bWxCYXNlXCIsXG4gICAgICAgIFwieG1sOmJhc2VcIjogXCJ4bWxCYXNlXCIsXG4gICAgICAgIHhtbGxhbmc6IFwieG1sTGFuZ1wiLFxuICAgICAgICBcInhtbDpsYW5nXCI6IFwieG1sTGFuZ1wiLFxuICAgICAgICB4bWxuczogXCJ4bWxuc1wiLFxuICAgICAgICBcInhtbDpzcGFjZVwiOiBcInhtbFNwYWNlXCIsXG4gICAgICAgIHhtbG5zeGxpbms6IFwieG1sbnNYbGlua1wiLFxuICAgICAgICBcInhtbG5zOnhsaW5rXCI6IFwieG1sbnNYbGlua1wiLFxuICAgICAgICB4bWxzcGFjZTogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB5MTogXCJ5MVwiLFxuICAgICAgICB5MjogXCJ5MlwiLFxuICAgICAgICB5OiBcInlcIixcbiAgICAgICAgeWNoYW5uZWxzZWxlY3RvcjogXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgICAgIHo6IFwielwiLFxuICAgICAgICB6b29tYW5kcGFuOiBcInpvb21BbmRQYW5cIlxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMgPSB7fSxcbiAgICAgIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi8sXG4gICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLyxcbiAgICAgIHJBUklBID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSktWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgckFSSUFDYW1lbCA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS8sXG4gICAgICBtc1BhdHRlcm4kMSA9IC9eLW1zLS8sXG4gICAgICBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZyxcbiAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvLFxuICAgICAgd2FybmVkU3R5bGVOYW1lcyA9IHt9LFxuICAgICAgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fSxcbiAgICAgIHdhcm5lZEZvck5hTlZhbHVlID0gITEsXG4gICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITEsXG4gICAgICBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vLFxuICAgICAgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2csXG4gICAgICBtc1BhdHRlcm4gPSAvXm1zLS8sXG4gICAgICBpc0phdmFTY3JpcHRQcm90b2NvbCA9XG4gICAgICAgIC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSo6L2ksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3RET00uX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgTm90UGVuZGluZyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBwZW5kaW5nOiAhMSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICBhY3Rpb246IG51bGxcbiAgICAgIH0pLFxuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5kID0ge1xuICAgICAgZjogcHJldmlvdXNEaXNwYXRjaGVyLmYsXG4gICAgICByOiBwcmV2aW91c0Rpc3BhdGNoZXIucixcbiAgICAgIEQ6IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICgoaGVhZGVyID1cbiAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZikgK1xuICAgICAgICAgICAgICAgICAgICBcIj47IHJlbD1kbnMtcHJlZmV0Y2hcIiksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmRuc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChoZWFkZXIgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoaGVhZGVyLCB7IGhyZWY6IGhyZWYsIHJlbDogXCJkbnMtcHJlZmV0Y2hcIiB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChoZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuRChocmVmKTtcbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiAoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID1cbiAgICAgICAgICAgICAgXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICA/IFwiY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICA/IFwiYW5vbnltb3VzXCJcbiAgICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICBpZiAoIXJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XS5oYXNPd25Qcm9wZXJ0eShocmVmKSkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF1baHJlZl0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgdmFyIGhlYWRlciwgSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJiAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZikgK1xuICAgICAgICAgICAgICAgICAgXCI+OyByZWw9cHJlY29ubmVjdFwiO1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkQ3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJjcm9zc09yaWdpblwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgKz1cbiAgICAgICAgICAgICAgICAgICAgJzsgY3Jvc3NvcmlnaW49XCInICsgZXNjYXBlZENyb3NzT3JpZ2luICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICgoaGVhZGVyID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5jb25uZWN0W2J1Y2tldF1baHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgoYnVja2V0ID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKGJ1Y2tldCwge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlY29ubmVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuYWRkKGJ1Y2tldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5DKGhyZWYsIGNyb3NzT3JpZ2luKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbiAoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChhcyAmJiBocmVmKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTcmNTZXQgPSBvcHRpb25zLmltYWdlU3JjU2V0O1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU2l6ZXMgPSBvcHRpb25zLmltYWdlU2l6ZXM7XG4gICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hQcmlvcml0eSA9IG9wdGlvbnMuZmV0Y2hQcmlvcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGltYWdlU3JjU2V0XG4gICAgICAgICAgICAgICAgICA/IGltYWdlU3JjU2V0ICsgXCJcXG5cIiArIChpbWFnZVNpemVzIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgICA6IGhyZWY7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlc1trZXldID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBpbWFnZVNyY1NldCAmJlxuICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5ICYmXG4gICAgICAgICAgICAgICAgKChoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgICA6ICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGltYWdlU3JjU2V0ID8gdm9pZCAwIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXM6IGFzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLmltYWdlcy5zZXQoa2V5LCByZXN1bWFibGVTdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCxcbiAgICAgICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuc2V0KGhyZWYsIGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCA9IFtdO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuc2V0KGhyZWYsIGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCxcbiAgICAgICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGFzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoKGltYWdlU3JjU2V0ID0gcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10pLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldC5oYXNPd25Qcm9wZXJ0eShocmVmKSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKGltYWdlU3JjU2V0ID0ge30pLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10gPSBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXRbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnMpICYmXG4gICAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZm9udFwiID09PSBhcyAmJlxuICAgICAgICAgICAgICAgICAgKChrZXkgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGtleS5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUucmVzZXRzLmZvbnRbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICs9IGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgKGhyZWYgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwocmVzdW1hYmxlU3RhdGUsIGhyZWYpLFxuICAgICAgICAgICAgICAgICAgICBhcylcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9udFwiOlxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5MKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhcyA9XG4gICAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5zZXQoaHJlZiwgYXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGFzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzKTtcbiAgICAgICAgICAgICAgICBhcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc291cmNlc1tocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChhcyk7XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLm0oaHJlZiwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgWDogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tzcmNdXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW3NyY10gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAob3B0aW9ucyA9IGFzc2lnbih7IHNyYzogc3JjLCBhc3luYzogITAgfSwgb3B0aW9ucykpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhvcHRpb25zLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAoc3JjID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cy5nZXQoc3JjKSkpICYmXG4gICAgICAgICAgICAgICAgKHNyYy5sZW5ndGggPSAwKSxcbiAgICAgICAgICAgICAgKHNyYyA9IFtdKSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQoc3JjKSxcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuWChzcmMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uIChocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHByZWNlZGVuY2UgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKVxuICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl1cbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZSB8fFxuICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKSxcbiAgICAgICAgICAgICAgKHByZWNlZGVuY2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IFBFTkRJTkckMSxcbiAgICAgICAgICAgICAgICBwcm9wczogYXNzaWduKFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtcHJlY2VkZW5jZVwiOiBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByZWNlZGVuY2UucHJvcHMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLmdldChocmVmKSkgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVuZGVyU3RhdGUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgOiAocHJlY2VkZW5jZS5zdGF0ZSA9IFBSRUxPQURFRCkpLFxuICAgICAgICAgICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5zZXQoaHJlZiwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLlMoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUgPVxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoc3JjKVxuICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgeyBzcmM6IHNyYywgdHlwZTogXCJtb2R1bGVcIiwgYXN5bmM6ICEwIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLk0oc3JjLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBOb3RoaW5nU2VudCA9IDAsXG4gICAgICBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24gPSAxLFxuICAgICAgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiA9IDIsXG4gICAgICBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24gPSA0LFxuICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gPSA4LFxuICAgICAgRVhJU1RTID0gbnVsbCxcbiAgICAgIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcbiAgICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbiAgICB2YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8c2NyaXB0PlwiKSxcbiAgICAgIGVuZElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjL3NjcmlwdD5cIiksXG4gICAgICBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKSxcbiAgICAgIHN0YXJ0TW9kdWxlU3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCInKSxcbiAgICAgIHNjcmlwdE5vbmNlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBub25jZT1cIicpLFxuICAgICAgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKSxcbiAgICAgIHNjcmlwdENyb3NzT3JpZ2luID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBjcm9zc29yaWdpbj1cIicpLFxuICAgICAgZW5kQXN5bmNTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGFzeW5jPVwiXCI+XFx4M2Mvc2NyaXB0PicpLFxuICAgICAgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0U3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c2NyaXB0IHR5cGU9XCJpbXBvcnRtYXBcIj4nXG4gICAgICApLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICB2YXIgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlID0ge307XG4gICAgdmFyIE5vQ29udHJpYnV0aW9uID0gMCxcbiAgICAgIFJPT1RfSFRNTF9NT0RFID0gMCxcbiAgICAgIEhUTUxfSFRNTF9NT0RFID0gMSxcbiAgICAgIEhUTUxfTU9ERSA9IDIsXG4gICAgICBIVE1MX0hFQURfTU9ERSA9IDMsXG4gICAgICBTVkdfTU9ERSA9IDQsXG4gICAgICBNQVRITUxfTU9ERSA9IDUsXG4gICAgICBIVE1MX1RBQkxFX01PREUgPSA2LFxuICAgICAgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA3LFxuICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDgsXG4gICAgICBIVE1MX0NPTEdST1VQX01PREUgPSA5LFxuICAgICAgdGV4dFNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpLFxuICAgICAgc3R5bGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI6XCIpLFxuICAgICAgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI7XCIpLFxuICAgICAgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiIFwiKSxcbiAgICAgIGF0dHJpYnV0ZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiJyksXG4gICAgICBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKSxcbiAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKSxcbiAgICAgIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI+XCIpLFxuICAgICAgZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLz5cIiksXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICExLFxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMSxcbiAgICAgIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpLFxuICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLm93bmVyRG9jdW1lbnR8fGMsKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxkLGIpKX19KTsnXG4gICAgICApLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRiEtLVxceDNlXCIpLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRi0tXFx4M2VcIiksXG4gICAgICBzdHlsZVJlZ2V4ID0gLyg8XFwvfDwpKHMpKHR5bGUpL2dpLFxuICAgICAgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXG5cIiksXG4gICAgICBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLyxcbiAgICAgIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPCFET0NUWVBFIGh0bWw+XCIpLFxuICAgICAgZW5kVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBwbGFjZWhvbGRlcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBpZD1cIicpLFxuICAgICAgcGxhY2Vob2xkZXIyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpLFxuICAgICAgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2MhLS0kLS1cXHgzZVwiKSxcbiAgICAgIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnXFx4M2MhLS0kPy0tXFx4M2U8dGVtcGxhdGUgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+JyksXG4gICAgICBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tJCEtLVxceDNlXCIpLFxuICAgICAgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tLyQtLVxceDNlXCIpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPHRlbXBsYXRlXCIpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtZGdzdD1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1zdGNrPVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFEID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1jc3Rjaz1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPjwvdGVtcGxhdGU+XCIpLFxuICAgICAgYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rU3RhcnQgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLVwiKSxcbiAgICAgIGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua0VuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIi0tXFx4M2VcIiksXG4gICAgICBzdGFydFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8ZGl2IGhpZGRlbiBpZD1cIicpLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L2Rpdj5cIiksXG4gICAgICBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50U1ZHID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdmc+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRNYXRoTUwyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L21hdGg+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4gaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RhYmxlPlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzx0YWJsZSBoaWRkZW4+PHRib2R5IGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvdGJvZHk+PC90YWJsZT5cIiksXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlUm93MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RyPjwvdGFibGU+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9jb2xncm91cD48L3RhYmxlPlwiKSxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJTPWZ1bmN0aW9uKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9OyRSUyhcIidcbiAgICAgICksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJTKFwiJyksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIilcXHgzYy9zY3JpcHQ+Jyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yc2k9XCJcIiBkYXRhLXNpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbiAgICB2YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JFJDKFwiJ1xuICAgICAgKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19OyRSTT1uZXcgTWFwO1xcbiRSUj1mdW5jdGlvbih0LHUseSl7ZnVuY3Rpb24gdihuKXt0aGlzLl9wPW51bGw7bigpfWZvcih2YXIgdz0kUkMscD0kUk0scT1uZXcgTWFwLHI9ZG9jdW1lbnQsZyxiLGg9ci5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIikseD1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT94LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZwLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscS5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZT15W2IrK107aWYoIWUpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1lW20rK107aWYoYT1wLmdldChkKSl7dmFyIGY9YS5fcDtjPSEwfWVsc2V7YT1yLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1cXG5kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1sPWVbbSsrXTtmPWVbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZixlW20rK10pO2Y9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbihuLHope2Eub25sb2FkPXYuYmluZChhLG4pO2Eub25lcnJvcj12LmJpbmQoYSx6KX0pO3Auc2V0KGQsYSl9ZD1hLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpOyFmfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZik7aWYoYyljb250aW51ZX1lbHNle2E9eFtiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXEuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtxLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXIuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4ody5iaW5kKG51bGwsXFxudCx1LFwiXCIpLHcuYmluZChudWxsLHQsdSxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JFJSKFwiJ1xuICAgICAgKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJNPW5ldyBNYXA7XFxuJFJSPWZ1bmN0aW9uKHQsdSx5KXtmdW5jdGlvbiB2KG4pe3RoaXMuX3A9bnVsbDtuKCl9Zm9yKHZhciB3PSRSQyxwPSRSTSxxPW5ldyBNYXAscj1kb2N1bWVudCxnLGIsaD1yLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiKSx4PVtdLGs9MDtiPWhbaysrXTspXCJub3QgYWxsXCI9PT1iLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpP3gucHVzaChiKTooXCJMSU5LXCI9PT1iLnRhZ05hbWUmJnAuc2V0KGIuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSxxLnNldChiLmRhdGFzZXQucHJlY2VkZW5jZSxnPWIpKTtiPTA7aD1bXTt2YXIgbCxhO2ZvcihrPSEwOzspe2lmKGspe3ZhciBlPXlbYisrXTtpZighZSl7az0hMTtiPTA7Y29udGludWV9dmFyIGM9ITEsbT0wO3ZhciBkPWVbbSsrXTtpZihhPXAuZ2V0KGQpKXt2YXIgZj1hLl9wO2M9ITB9ZWxzZXthPXIuY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPVxcbmQ7YS5yZWw9XCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWw9ZVttKytdO2Y9ZVttKytdOylhLnNldEF0dHJpYnV0ZShmLGVbbSsrXSk7Zj1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKG4seil7YS5vbmxvYWQ9di5iaW5kKGEsbik7YS5vbmVycm9yPXYuYmluZChhLHopfSk7cC5zZXQoZCxhKX1kPWEuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7IWZ8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChmKTtpZihjKWNvbnRpbnVlfWVsc2V7YT14W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cS5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Euc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9ci5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih3LmJpbmQobnVsbCxcXG50LHUsXCJcIiksdy5iaW5kKG51bGwsdCx1LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTskUlIoXCInXG4gICAgICApLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJSKFwiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiKVxceDNjL3NjcmlwdD5cIik7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yY2k9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnJpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc2lkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0eT1cIicpO1xuICAgIHZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJyRSWD1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxmJiYoYS5jc3Rjaz1mKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTs7JFJYKFwiJ1xuICAgICAgKSxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlgoXCInKSxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpLFxuICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIsXCIpLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiKVxceDNjL3NjcmlwdD5cIik7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yeGk9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1kZ3N0PVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLW1zZz1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdGNrPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWNzdGNrPVwiJyk7XG4gICAgdmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3R5bGUgbWVkaWE9XCJub3QgYWxsXCIgZGF0YS1wcmVjZWRlbmNlPVwiJ1xuICAgICAgKSxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdHlsZT5cIiksXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMSxcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSAhMCxcbiAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlID0gW10sXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyksXG4gICAgICBzcGFjZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIiBcIiksXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdHlsZT5cIiksXG4gICAgICBhcnJheUZpcnN0T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJbXCIpLFxuICAgICAgYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIsW1wiKSxcbiAgICAgIGFycmF5SW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLFwiKSxcbiAgICAgIGFycmF5Q2xvc2VCcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXVwiKSxcbiAgICAgIFBFTkRJTkckMSA9IDAsXG4gICAgICBQUkVMT0FERUQgPSAxLFxuICAgICAgUFJFQU1CTEUgPSAyLFxuICAgICAgTEFURSA9IDMsXG4gICAgICByZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0ID0gL1s8Plxcclxcbl0vZyxcbiAgICAgIHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0ID0gL1tcIic7LFxcclxcbl0vZyxcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpbnRlcm5hbHMgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICBudWxsID09PSBpbnRlcm5hbHMucXVldWVcbiAgICAgICAgICAgID8gd2Fybk5vb3AoaW5zdCwgXCJzZXRTdGF0ZVwiKVxuICAgICAgICAgICAgOiAoaW50ZXJuYWxzLnF1ZXVlLnB1c2gocGF5bG9hZCksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgaW5zdC5yZXBsYWNlID0gITA7XG4gICAgICAgICAgaW5zdC5xdWV1ZSA9IFtwYXlsb2FkXTtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBudWxsID09PSBpbnN0Ll9yZWFjdEludGVybmFscy5xdWV1ZVxuICAgICAgICAgICAgPyB3YXJuTm9vcChpbnN0LCBcImZvcmNlVXBkYXRlXCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVtcHR5VHJlZUNvbnRleHQgPSB7IGlkOiAxLCBvdmVyZmxvdzogXCJcIiB9LFxuICAgICAgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2ssXG4gICAgICBsb2cgPSBNYXRoLmxvZyxcbiAgICAgIExOMiA9IE1hdGguTE4yLFxuICAgICAgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyIHJldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgLlwiXG4gICAgICApLFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGwsXG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgaXNSZVJlbmRlciA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExLFxuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwLFxuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gMCxcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsLFxuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwLFxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITEsXG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgIEhvb2tzRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICAgICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdXNhYmxlICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1c2FibGUpIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbilcbiAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcFRoZW5hYmxlKHVzYWJsZSk7XG4gICAgICAgICAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICAgIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiBcIiArIFN0cmluZyh1c2FibGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vOiB1c2VNZW1vLFxuICAgICAgICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICAgICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZpb3VzUmVmXG4gICAgICAgICAgICA/ICgoaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksXG4gICAgICAgICAgICAgIE9iamVjdC5zZWFsKGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSkpXG4gICAgICAgICAgICA6IHByZXZpb3VzUmVmO1xuICAgICAgICB9LFxuICAgICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICAgIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AkMSxcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgfSwgZGVwcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AkMSxcbiAgICAgICAgdXNlRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZURlYnVnVmFsdWU6IG5vb3AkMSxcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaW5pdGlhbFZhbHVlID8gaW5pdGlhbFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFshMSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmVlSWQgPSBjdXJyZW50bHlSZW5kZXJpbmdUYXNrLnRyZWVDb250ZXh0O1xuICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHRyZWVJZC5vdmVyZmxvdztcbiAgICAgICAgICB0cmVlSWQgPSB0cmVlSWQuaWQ7XG4gICAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAgICh0cmVlSWQgJiB+KDEgPDwgKDMyIC0gY2x6MzIodHJlZUlkKSAtIDEpKSkudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG92ZXJmbG93ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgICB0cmVlSWQgPSBcIlxcdTAwYWJcIiArIHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgXCJSXCIgKyB0cmVlSWQ7XG4gICAgICAgICAgMCA8IG92ZXJmbG93ICYmICh0cmVlSWQgKz0gXCJIXCIgKyBvdmVyZmxvdy50b1N0cmluZygzMikpO1xuICAgICAgICAgIHJldHVybiB0cmVlSWQgKyBcIlxcdTAwYmJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUFjdGlvblN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlRm9ybVN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIE5vdFBlbmRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICBmb3IgKHZhciBkYXRhID0gQXJyYXkoc2l6ZSksIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgY3VycmVudFRhc2tJbkRFViA9IG51bGwsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVZcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBjYWxsQ29tcG9uZW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxSZW5kZXIgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxSZW5kZXJJbkRFViA9IGNhbGxSZW5kZXJbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsUmVuZGVyKSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICBsYXN0UmVzZXRUaW1lID0gMDtcbiAgICBpZiAoXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vd1xuICAgICkge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIHZhciBnZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgICAgIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIENMSUVOVF9SRU5ERVJFRCA9IDQsXG4gICAgICBQRU5ESU5HID0gMCxcbiAgICAgIENPTVBMRVRFRCA9IDEsXG4gICAgICBGTFVTSEVEID0gMixcbiAgICAgIFBPU1RQT05FRCA9IDUsXG4gICAgICBDTE9TRUQgPSAxNCxcbiAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9ICExO1xuICAgIGVuc3VyZUNvcnJlY3RJc29tb3JwaGljUmVhY3RWZXJzaW9uKCk7XG4gICAgZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKTtcbiAgICBleHBvcnRzLnByZXJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9uSGVhZGVycyA9IG9wdGlvbnMgPyBvcHRpb25zLm9uSGVhZGVycyA6IHZvaWQgMCxcbiAgICAgICAgICBvbkhlYWRlcnNJbXBsO1xuICAgICAgICBvbkhlYWRlcnMgJiZcbiAgICAgICAgICAob25IZWFkZXJzSW1wbCA9IGZ1bmN0aW9uIChoZWFkZXJzRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgb25IZWFkZXJzKG5ldyBIZWFkZXJzKGhlYWRlcnNEZXNjcmlwdG9yKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRDb250ZW50IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcE1vZHVsZXMgOiB2b2lkIDBcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlcXVlc3QgPSBjcmVhdGVQcmVyZW5kZXJSZXF1ZXN0KFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICByZXNvdXJjZXMsXG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuaW1wb3J0TWFwIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvbkhlYWRlcnNJbXBsLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5tYXhIZWFkZXJzTGVuZ3RoIDogdm9pZCAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdm9pZCAwKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25FcnJvciA6IHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBwcmVsdWRlOiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uUG9zdHBvbmUgOiB2b2lkIDBcbiAgICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgIHZhciBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgb25GYXRhbEVycm9yLFxuICAgICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgICAgYWxsUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgIG9uQWxsUmVhZHkgPSByZXM7XG4gICAgICAgICAgICBvbkZhdGFsRXJyb3IgPSByZWo7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgb25IZWFkZXJzID0gb3B0aW9ucyA/IG9wdGlvbnMub25IZWFkZXJzIDogdm9pZCAwLFxuICAgICAgICAgIG9uSGVhZGVyc0ltcGw7XG4gICAgICAgIG9uSGVhZGVycyAmJlxuICAgICAgICAgIChvbkhlYWRlcnNJbXBsID0gZnVuY3Rpb24gKGhlYWRlcnNEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBvbkhlYWRlcnMobmV3IEhlYWRlcnMoaGVhZGVyc0Rlc2NyaXB0b3IpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMudW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcFNjcmlwdHMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBNb2R1bGVzIDogdm9pZCAwXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmltcG9ydE1hcCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb25IZWFkZXJzSW1wbCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMubWF4SGVhZGVyc0xlbmd0aCA6IHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG9wdGlvbnMgPyBvcHRpb25zLm5hbWVzcGFjZVVSSSA6IHZvaWQgMCksXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgIHB1bGw6IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHJlYW0uYWxsUmVhZHkgPSBhbGxSZWFkeTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBhbGxSZWFkeS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmZvcm1TdGF0ZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjEuMFwiO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server.browser.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-dom/server.browser.js":
/*!**************************************************!*\
  !*** ./node_modules/react-dom/server.browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar l, s;\nif (false) {} else {\n  l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.browser.development.js */ \"(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js\");\n  s = __webpack_require__(/*! ./cjs/react-dom-server.browser.development.js */ \"(pages-dir-browser)/./node_modules/react-dom/cjs/react-dom-server.browser.development.js\");\n}\n\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToReadableStream = s.renderToReadableStream;\nif (s.resume) {\n  exports.resume = s.resume;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxJQUFJLEtBQXFDLEVBQUUsRUFHMUMsQ0FBQztBQUNGLE1BQU0sbUJBQU8sQ0FBQyw2SkFBc0Q7QUFDcEUsTUFBTSxtQkFBTyxDQUFDLCtJQUErQztBQUM3RDs7QUFFQSxlQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQSxFQUFFLGNBQWM7QUFDaEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXGNvbWVyY2FcXG5vZGVfbW9kdWxlc1xccmVhY3QtZG9tXFxzZXJ2ZXIuYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBsLCBzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIucHJvZHVjdGlvbi5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5icm93c2VyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIGwgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzJyk7XG4gIHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuZXhwb3J0cy52ZXJzaW9uID0gbC52ZXJzaW9uO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IGwucmVuZGVyVG9TdHJpbmc7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gbC5yZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9SZWFkYWJsZVN0cmVhbSA9IHMucmVuZGVyVG9SZWFkYWJsZVN0cmVhbTtcbmlmIChzLnJlc3VtZSkge1xuICBleHBvcnRzLnJlc3VtZSA9IHMucmVzdW1lO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-dom/server.browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxyZWFjdFxcY2pzXFxyZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd25Pd25lcigpIHtcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3RbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDJLQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxcbm9kZV9tb2R1bGVzXFxyZWFjdFxcanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MyApp)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var _plasmic_init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plasmic/init */ \"(pages-dir-browser)/./plasmic/init.js\");\n\n\n\nfunction MyApp(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n        ...pageProps\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\admin\\\\comerca\\\\pages\\\\_app.js\",\n        lineNumber: 5,\n        columnNumber: 10\n    }, this);\n}\n_c = MyApp;\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL19hcHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDRDtBQUVWLFNBQVNDLE1BQU0sS0FBd0I7UUFBeEIsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBeEI7SUFDNUIscUJBQU8sOERBQUNEO1FBQVcsR0FBR0MsU0FBUzs7Ozs7O0FBQ2pDO0tBRndCRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxccGFnZXNcXF9hcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgXCIuLi9wbGFzbWljL2luaXRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHMgfSkge1xyXG4gIHJldHVybiA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIk15QXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/_app.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./plasmic/init.js":
/*!*************************!*\
  !*** ./plasmic/init.js ***!
  \*************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLASMIC: () => (/* binding */ PLASMIC)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-nextjs */ \"(pages-dir-browser)/./node_modules/@plasmicapp/loader-nextjs/dist/index.esm.js\");\n\nconst PLASMIC = (0,_plasmicapp_loader_nextjs__WEBPACK_IMPORTED_MODULE_0__.initPlasmicLoader)({\n    projects: [\n        {\n            id: \"8y5fC3dqCKUzU3LTeCmeNt\",\n            token: \"8iPglZjy6ojTSBas5bEvggRqr1EcVN0Mos922QQ2E0tGSmZu9VxWC7GoPLsCn2XbGkDzHnlJ6rsQU8ImmVMOA\"\n        }\n    ]\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BsYXNtaWMvaW5pdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUV2RCxNQUFNQyxVQUFVRCw0RUFBaUJBLENBQUM7SUFDdkNFLFVBQVU7UUFDUjtZQUNFQyxJQUFJO1lBQ0pDLE9BQU87UUFDVDtLQUNEO0FBQ0gsR0FBRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcY29tZXJjYVxccGxhc21pY1xcaW5pdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0UGxhc21pY0xvYWRlciB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItbmV4dGpzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUExBU01JQyA9IGluaXRQbGFzbWljTG9hZGVyKHtcclxuICBwcm9qZWN0czogW1xyXG4gICAge1xyXG4gICAgICBpZDogXCI4eTVmQzNkcUNLVXpVM0xUZUNtZU50XCIsIC8vIHJlcGxhY2Ugd2l0aCB5b3VyIGFjdHVhbCBwcm9qZWN0IElEIGlmIGRpZmZlcmVudFxyXG4gICAgICB0b2tlbjogXCI4aVBnbFpqeTZvalRTQmFzNWJFdmdnUnFyMUVjVk4wTW9zOTIyUVEyRTB0R1NtWnU5VnhXQzdHb1BMc0NuMlhiR2tEekhubEo2cnNRVThJbW1WTU9BXCJcclxuICAgIH1cclxuICBdLFxyXG59KTtcclxuIl0sIm5hbWVzIjpbImluaXRQbGFzbWljTG9hZGVyIiwiUExBU01JQyIsInByb2plY3RzIiwiaWQiLCJ0b2tlbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./plasmic/init.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/client/router.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);